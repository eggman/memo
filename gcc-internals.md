
## GCC と互換性

GCC の第一の目標は、品質の良い、高速なコンパイラを、 GNU システムが動作することをねらいとするクラスのマシン向けに作ることであった。そのクラスのマシンとは、32 ビットマシンで、8ビットを一バイトとするアドレッシングを持ち、汎用レジスタがたくさん持つものである。洗練されているとか、理論的な能力とか簡潔さなどは二の次である。

GCC はターゲット機種についての情報のほとんどを、機種記述から得る。機種記述はその機種の命令毎に代数式を与える。これはターゲットを記述する方法としては非常に明解な方法である。ただし、コンパイラが、この形式で表現するのが困難な情報が必要な時は、筆者は機種記述にその場しのぎのパラメータの定義をためらわずに入れる。移植性の目的はコンパイラについて必要な全作業を少なくすることにあり、それ自身には興味がない。

GCC は機種依存コードは含んでいないが、エンディアン(最上位バイトがワードの中のバイトの最上位アドレスを占めるのか、最下位アドレスを占めるのか) や自動インクリメント・アドレッシングが利用可能かなどの機種パラメータに依存するコードは含んでいる。RTL 生成パスでは、ある特定の種類の構文木に対してコード生成の戦略を複数持つ必要があることが多い。これらの戦略はパラメータの異なる組合せに対して使用可能である。著者は可能な場合全てを取り扱うことせず、共通に現れるものや、著者が出会ったものに絞っている。取り扱っていない組合せに出会ったら、GCC が abort を呼び出すので読者も気が付くだろう。幸いにも、新たな戦略を機種独立な形で追加することができ、その新たな戦略を必要とするターゲット機種にしか影響を及ぼさない。


## GCC の出力に対するインターフェース

GCC は、ターゲットシステム上で通常使われるのと同じ関数呼び出し規約を使うように、通常は構成される。これは、マシン記述マクロの記述によりなされる。

しかし、構造体と共用体の返し方は機種によって異なることがある。その結果、PCC でコンパイルしたそのような型を返す関数をGCC でコンパイルした関数から呼び出せないことがあるし、その逆もある。これはあまり問題にはならない。Unix のライブラリルーチンで構造体や共用体を返すものは滅多にないからである。

GCC は、1、2、4、8 バイト長の構造体と共用体は、int や double の戻り値に使うのと同じレジスタに入れて返す。(GCC は普通はそのような型の変数もレジスタに割り当てる。) それ以外の大きさの構造体と共用体は、呼び出し側によって渡されるアドレス(通常、レジスタで渡される)に格納することで返される。マシン記述マクロの STRUCT_VALUE と STRUCT_INCOMING_VALUE により、GCC に、このアドレスをどこに渡すかを指定する。

対照的に、多くのターゲット機種上の PCC は、どの大きさの構造体と共用体でも静的な領域にデータをコピーし、その領域のアドレスをポインタ値であるかのように返すことで、返す。呼び出し側は、そのメモリ領域からその値が必要とされる場所にデータをコピーしなければならない。この方法は、GCC の方法よりも遅く、また再入可能でない。

ターゲット機種によっては、RISC マシンや 80386 のように、システム標準の規約が、サブルーチンに、戻り値を置くアドレスを渡すようになっている。こういう機種では、この方法が使われている場合は、GCC は標準のコンパイラと互換になるようにコンフィギュレーションされる。1,2,4,8バイトの構造体については互換でない可能性がある。

GCC は、引数渡しについてはシステム標準の規約を使う。機種によっては、最初の幾つかの引数はレジスタで渡し、その他は全てスタックで渡される。どの機種でも引数を渡すのにレジスタを使うようにすることができる。それにより、おそらく、非常に速度が速くなるだろう。だが、その結果、標準の規約に従っているコードとの互換性が全く無くなってしまう。このため、この変更は GCC をシステムに取っての唯一の C コンパイラとして切り替えた場合にのみ意味がある。完全な GNU システムができた暁には、ある種の機種ではレジスタによる引数渡しを実装し、ライブラリを GCC でコンパイルできるようにする予定である。

機種によっては(特に SPARC)、特定の型の引数は「不可視の参照」により渡される。これは、渡すべき値がメモリに置かれ、そのメモリ位置のアドレスがサブルーチンに渡されることを意味する。

longjmp を使う場合には、自動変数に注意しなければならない。ANSI C によれば、volatile 宣言されていない自動変数の値は、longjmp 呼び出しの後、未定義になる。そしてこれは GCC が行なうと約束する全てでもある。なぜなら、レジスタ変数を正しくリストアするのは非常に困難であり、GCC の目玉の一つが、特に指定しなくても、変数をレジスタに置くことができる点にあるからである。

変数の値を longjmp によって変えられたくないが、古い C コンパイラが受け付けないので volatile も使いたくないという場合は、単にその変数のアドレスを取れば良い。変数のアドレスが一度でも取られると、それがアドレスの値を単に計算するだけでその値を使わなくても、その変数はレジスタに置かれなくなる。

```
{
  int careful;
  &careful;
  ...
}
```

GCC でコンパイルしたコードは、特定のライブラリルーチンを呼び出す可能性がある。その大部分は、算術演算を行なう命令がない場合に、代わりに算術演算を取り扱う。これは、ある機種では乗算と除算が含まれ、また、任意の機種で浮動小数点サポートが -msoft-float により無効になっている場合の浮動小数点演算が含まれる。C 標準ライブラリの一部、例えば bcopy や memcpy 等もまた、自動的に呼び出される。通常の関数呼びだし方法が、これらのライブラリルーチン呼び出しに使われる。

これらのライブラリルーチンはライブラリ libgcc.a で定義されるべきであり、GCC はプログラムをリンクするときに自動的にこれを探す。乗算命令と除算命令のある機種では、ハードウェア浮動小数点が使われていれば、普通は libgcc.a は必要ないが、その場合でも検索される。

各算術演算関数は libgcc1.c で定義されており、対応するC の算術演算子を使っている。このファイルが何か別の C コンパイラでコンパイルする限り、そのコンパイラは全ての C の算術演算子をサポートしているので、このファイルは正しく動作するはずである。だが、GCC でコンパイルすると libgcc1.c は動作しない。なぜなら、各算術関数がそれ自身への呼び出しにコンパイルされてしまうからである。

##コンパイラの各パスとソースファイル

コンパイラ全体の制御構造は、toplev.c に記述されている。このファイルは、初期化、引数の解析、ファイルのオープン／クローズ、各パスの順次実行を受け持つ。

構文解析パスは一度だけ起動され、入力全体を構文解析する。関数が文単位で構文解析されるにつれ、その関数に対する RTL 中間コードが、生成される。各文は、構文木として読み込まれ、その後 RTL に変換される。その後、その文の構文木用のメモリ領域が再利用される。型(とその大きさを表す式)、宣言、結合の概略と何重に入れ子になっているかの表現は、関数のコンパイルが完了するまで残っている。これは、全てデバッグ情報を出力するのに必要である。

構文解析パスが、完全な関数定義か最上位の宣言を読み込む度に、関数 rest_of_compilation か rest_of_decl_compilation を呼び出す。これらの関数は toplev.c にあり、アセンブラ言語の出力で終わる、以後必要な全ての処理に責任がある。コンパイラの他の全てのパスは、順番に、rest_of_compilation の中で実行される。この関数がある関数定義をコンパイルする処理から戻ると、その関数定義のコンパイルに使われた記憶領域はインライン関数でない限り完全に解放される(see An Inline Function is As Fast As a Macro)。

以下にコンパイラの全パスとそのソースファイルの一覧を示す。また、-d で始まるオプションで要求されるデバッグダンプについての解説も含めた。

###構文解析

このパスは、一個の関数定義の全テキストを読み込み、部分的な構文木を構成する。このパスと RTL 生成パスはもはや実際には別々のパスではない(以前は別々であった)が、独立したパスと考えると考えやすい。
木表現は完全には C の文法にしたがっていない。他の言語も同様にサポートすることを意図しているからである。

言語固有のデータ型解析もこのパスで行なわれ、式を表現するあらゆる木ノードには、あるデータ型が付いている。変数は宣言ノードとして表現される。

定数フォールディングといくつかの演算の単純化もこのパスで行なわれる。

言語独立のパース部のソースファイルは、stor-layout.c、fold-const.c、tree.c である。また、tree.h と tree.def というヘッダファイルで、木構造の表現形式で定義している。

C 言語のパース部のソースファイルは、c-parse.in、c-decl.c、c-typeck.c、c-aux-info.c、c-convert.c、c-lang.c であり、関連するヘッダファイルはc-lex.h と c-tree.h である。

C++ 言語のパース部のソースファイルは、cp-parse.y、cp-class.c、
cp-cvt.c、cp-decl.c、cp-decl2.c、cp-dem.c、cp-except.c、
cp-expr.c、cp-init.c、cp-lex.c、cp-method.c、cp-ptree.c、
cp-search.c、cp-tree.c、cp-type2.c、cp-typeck.c、であり、関連するヘッダファイルは cp-tree.def、cp-tree.h、cp-decl.h である。

Objective C をパースする特別なソースファイルは、objc-parse.y、objc-actions.c、objc-tree.def、それにobjc-actions.hである。C 言語固有のファイルの幾つかも使われる。

ファイル c-common.c は、上記の全ての言語で使われる。

###RTL 生成

構文木を RTL コードに変換する。実際には構文解析のパスで一文毎に変換されるのだが、別のパスとして考えておくと色々便利である。

この部分には、ターゲットのパラメータに依存するコードが大量にある。これは、ある種の標準的な命令が利用可能な場合にのみ適用する必要がある戦略が多いためである。名前付き命令パターンの目的は、この情報を RTL 生成パスに提供することにある。

このパスでは、比較や真偽値演算、三項演算子式である if 節の条件に対する最適化が行なわれる。末尾再帰もこのときに検出される。ループをどのように編成するのが最適か、それに switch 文をどのように出力するかの決定が行なわれる。

RTL 生成に関係するソースファイルは、stmt.c、calls.c、expr.c、explow.c、expmed.c、function.c、optabs.c、emit-rtl.c である。また、ファイル insn-emit.c が、genemit プログラムによりマシン記述から生成され、このパスで使われる。ヘッダファイル expr.h がこのパス内の通信に使われる。

ヘッダファイル insn-flags.h と insn-codes.h は、マシン記述から genflags プログラムと gencodes プログラムにより生成される。これらのファイルにより、このパスで利用可能な標準パターン名とそれに対応するパターンが分かる。

デバッグ情報の出力を別として、これ以降のパスでは関数の木構造表現(これは部分的にしかセーブされない)を参照しない。

後続の呼び出しにおいて、関数がインライン展開可能か、そしてインライ展開すべきかは、RTL 生成の終了時に決定される。インライン展開される関数は幾つかの規準を満たさなければならない。この規準は現在は、関数の大きさと仮引数の型と数に関係する。これを満たす関数は、ループや自分自身の再帰呼び出し(末尾再帰関数もインライン展開可能!)、goto 等、つまるところ、GCC がサポートしている全ての構文を含んでいて良いことに注意して欲しい。ファイル integrate.c には、後のインライン展開に備えて関数の RTL をセーブし、その関数が呼び出されたときにその RTL をインライン展開するコードが含まれている。ヘッダファイル integrate.h もまたこの目的に使われる。

-dr オプションを指定すると、このパス後の RTL コードのデバッグ出力が行なわれる。デバッグ出力のファイル名は入力ファイル名に .rtl を付けたものになる。

###ジャンプ最適化

このパスでは、ジャンプを越えるジャンプ、ジャンプへのジャンプといった命令へのジャンプを単純化する。未参照のラベルと到達不能コードを削除する。ただし、このパスでは到達不能と認識されないループを含む到達不能コードは削除されない。(そのようなループは、後の基本ブロック解析で削除される。) また、もともとはジャンプで書かれていたコードを、比較の結果から直接値を設定する命令の列に変換する。これは、その機種がそのような命令を持っている場合に行われる。

ジャンプ最適化は二回か三回実行される。最初は、RTL 生成の直後である。二回目は、CSE の後だが、ただし CSE がジャンプ最適化を繰り返す必要があると判断した場合だけである。最後は、最終パスの直前に行なわれる。このとき、クロスジャンプと no-op 移動命令の削除が、上記の最適化と合わせて行なわれる。

このパスのソースファイルは jump.c である。

-dj オプションを指定すると、このパス後の RTL コードのデバッグ出力が行なわれる。デバッグ出力のファイル名は入力ファイル名に .jump を付けたものになる。

###レジスタ走査
このパスでは、各レジスタの最初と最後に使われているところを探し、共通部分式削除の指針とする。ソースは regclass.c である。

###ジャンプの一本化
このパスは、全く同一の、あるいはその逆のテストへ分岐する条件ジャンプを検出する。このようなジャンプは、二番目の条件のテストに「一本化」できる。このパスのソースコードは jump.c である。この最適化は、-fthread-jumps が有効になっているときだけ実行される。

###共通部分式削除
このパスでは、定数伝搬も行なう。この部分のソースファイルは、cse.c である。定数伝搬により、条件ジャンプが無条件ジャンプまたは NOP に変わる場合は、ジャンプ最適化が CSE が終わった後に再度実行される。

-ds オプションを指定すると、このパス後の RTL コードのデバッグ出力が行なわれる。デバッグ出力のファイル名は入力ファイル名に .cse を付けたものになる。

###グローバル共通部分式削除
このパスは、Morel-Renvoise の部分冗長性削除を使って GCSE を行う。ただし、ループ不変の移動は行わない。これはループ最適化パスに任せている。このパスは、グローバル定数とコピーの伝播も行う。

このパスのソースファイルは gcse.c である。

-dG オプションを指定すると、このパス後の RTL コードのデバッグ出力が行われる。デバッグ出力のファイル名は入力ファイル名に .gcse を付けたものになる。

###ループ最適化
定数式をループの外側に移動し、強度削減やループ展開も必要に応じて行なう。関連するソースファイルは、loop.c と unroll.c であり、それに加えてヘッダファイル loop.h が情報交換用に使われる。

コマンド行オプション -dL を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.loop を付けたものである。

-frerun-cse-after-loop オプションが指定されていると、二回目の共通部分式の削除がループ最適化の後に行なわれる。指定されていれば、ジャンプ最適化ももう一度行なわれる。

コマンド行オプション -dt を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.cse2 を付けたものである。

最適化を行なわないコンパイルの場合は、ここで単純レジスタ割当が行なわれる。また、ちょっとしたデータ流解析も行なう。単純レジスタ割当が使われる場合は、次に実行されるパスはリロードパスである。この二つのパスの間にある他のパスは飛ばされる。

###データフロー解析
このパスではプログラムを基本ブロックに分解し(その処理中に到達不能なループを削除する)、どの疑似レジスタがプログラムの各点で生きているかを計算し、ある値を最初に使う命令がその値を計算した命令を指すようにする。

このパスでは、また、決して使われることのない結果を出す計算を削除し、メモリ参照を加算または減算命令と組み合わせて、自動インクリメントあるいは自動デクリメントのアドレッシングを作り出す。

コマンド行オプション -df を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.flow を付けたものである。単純な(stupid)レジスタ割当が使われているなら、このダンプファイルは、その割当に関する全ての結果も含める。

###命令組合せ
(combine.c)。このパスでは、データフローにより関係付けられた二、または三個の命令から成るグループを組み合わせて、一つの命令にすることを試みる。命令に対する RTL 式を置き換えることで組合せ、その結果を代数を使って簡素化し、最後にその結果をマシン記述と照合することを試みる。

コマンド行オプション -dc を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.combine を付けたものである。

###レジスタ移動
(regmove.c)。このパスは、照合制約により、強制的に命令が再ロードを必要とするようにし、その再ロードがレジスタからレジスタへの移動になるような場合を探す。次に、その命令が使用するレジスタを変更して、移動命令を回避することを試みる。

コマンド行オプション -dN を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.regmove を付けたものである。

###命令スケジューリング
(sched.c)。このパスでは、後続の命令が使用する時点でその出力が利用可能にならない命令を捜し出す。(RISC 機種では、メモリのロードと浮動小数点命令がこの動作をすることが多い)。基本ブロック内で命令の順序を変えて、定義とその使用を分離して、パイプラインのストールを避けるようにする。

命令スケジューリングは二回行なわれる。一回目は命令組合せの直後で、二回目はリロードの直後である。

コマンド行オプション -dS を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.sched を付けたものである。

###レジスタクラスの選択
RTL コードが操作され、各疑似レジスタに最適なレジスタクラスを見つける。関連ソースファイルは regclass.c である。

###居所レジスタ割り当て
(local-alloc.c)。このパスでは、基本ブロック内でのみ使用されている疑似レジスタにハードレジスタを割り当てる。基本ブロックは線形なので、高速で強力な技術を使って非常に良い仕事をすることが可能である。

オプション -dl を指定すると、このパスを終了した後のRTL コードのデバッグダンプを行なう。出力されるダンプファイル名は、入力ファイル名に .lreg を付けたものになる。

###大局的なレジスタ割当(global.c)。
このパスは、残る疑似レジスタ(ライフスパンが基本ブロックに収まらないもの)に対しハードレジスタを割り当てる。

###再ロード
このパスは、疑似レジスタの番号を、割り当てられたハードウェアレジスタ番号に付け替える。ハードレジスタが割り当てられなかった疑似レジスタはスタックスロットに置き換えられる。その後、値が最終的にレジスタに入らなかったり、正しくない種類のレジスタに入ったりしたために、不正になった命令を探す。こういう不正な命令を、問題となる値を一時的にレジスタに再ロードすることで修正を行なう。そのために必要になるコピーを行なう命令が追加で生成される。

再ロードパスでは、オプションで、フレームポインタの削除と、呼出しの前後で呼出し時破壊レジスタのセーブ／リストアを行なう命令の挿入も行なう。

関係するソースファイルは reload.c と reload1.c で、さらに、この両者の通信用にヘッダファイル reload.h が使われる。

-dg オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .greg を付けたものになる。

###2回目の命令スケジューリング
命令スケジューリングがここで繰り返され、溢れた疑似レジスタ用に生成されるメモリロードによるパイプラインのストールを回避することを試みる。

-dR オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .sched2 を付けたものになる。

###２回目のジャンプ最適化
ジャンプ最適化が繰り返される。今度は、交差ジャンプと、なんの効果もない移動命令の削除が含まれる。

-dJ オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .jump2 を付けたものになる。

###遅延分岐スケジューリング
これはオプションのパスであり、普通はジャンプやコール命令等の他の命令の遅延スロットに入りうる命令を探す。ソースファイル名は、reorg.c である。

-dd オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .dbr を付けたものになる。

###レジスタ変換
幾つかのハードレジスタの使用方法からレジスタ使用方法への変換がこの時点で行われる。現在、これは Intel 80387 コプロセッサの浮動小数点レジスタにたいしてだけサポートされている。ソースファイル名は reg-stack.c である。

-dk オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .stack を付けたものになる。

###最終パス
このパスでは、関数に対するアセンブラコードを出力する。このパスには、見せかけのテスト命令や比較命令を特定する責任もある。機種固有の覗き穴最適化も同時に行なわれる。関数の入り口点と終了点コードもこのパスで直接アセンブラコードで生成される。入り口点と終了点コードが、RTL として存在することはありえない。

関連ソースファイルは、final.c と insn-output.c である。後者は、マシン記述から genoutput プログラムにより自動的に生成される。ヘッダファイル conditions.h を使って、この二つのファイルの間で情報交換を行なう。

###デバッグ情報出力
これは最終パスの後に行なわれる。何故なら、ハードレジスタに割り当てられなかった疑似レジスタに対するスタックスロットのオフセットを出力しなければならないからである。

### その他
さらに幾つかのファイルが、全ての、あるいは多くのパスで使われる。

どのパスも、マシンモードを定義する、machmode.def と machmode.h を使用する。

多くのパスで real.h を使用する。このファイルは、浮動小数点定数のデフォルトの表現とそれらの操作方法を定義する。

RTL を使う全てのパスで、ヘッダファイル rtl.h と rtl.def、それに rtl.c 中のサブルーチンを使う。gen* のツール群もこれらのファイルを使って、マシン記述 RTL を読んで処理を行なう。

多くのパスで、ヘッダファイル insn-config.h を参照している。このファイルは、マシン記述 RTL から genconfig により自動的に生成されるパラメータ(C のマクロ定義)を数個含んでいる。

多くのパスが命令認識器を使用する。命令認識器は recog.c とrecog.h、それに、マシン記述から genrecog と genextract というツールにより生成されるファイル insn-recog.c とinsn-extract.c から成る。

多くのパスで、ヘッダファイル regs.h と basic-block.h を使っている。regs.h は、疑似レジスタの使用状況について記録される情報を定義している。basic-block.h は基本ブロックについて記録される情報を定義している。

hard-reg-set.h は、HARD_REG_SET 型とこれを取り扱うマクロをいくつかを定義している。HARD_REG_SET 型は、各ハードレジスタにつき 1 ビットのビットベクトルである。この型は、ハードレジスタ数が充分少なければ、単なる int になる。多い場合は、int の配列になり、マクロのうち幾つかはループに展開される。

多くのパスで命令属性を使っている。特定の機種用に定義される属性の定義は、ファイル insn-attr.h にある。このファイルは、マシン記述から genattr プログラムにより生成される。ファイル insn-attrtab.c には、insn の属性値を得るためのサブルーチンが含まれている。このファイルは、マシン記述からプログラム genattrtab により生成される。


##RTL表現
GCC の仕事の大半は、レジスタ転送言語(RTL)と呼ばれる中間表現に対してなされる。このレジスタ転送言語では、出力すべき命令を一つづつ、その命令が行う操作を代数的な形式で記述する。

RTL は、Lisp 言語のリストにヒントを得たものである。RTL は、他の構造体を指す構造体からなる内部形式と、マシン記述とデバッグ用ダンプ出力で用いられるテキスト形式の二種類の形式を持つ。テキスト形式では、内部形式でのポインタを示すのに多重の括弧を使う。

* RTL Objects: 式、ベクトル、文字列、整数
* RTL Classes: RTL 式オブジェクトのカテゴリとその構造
* Accessors: 式オペランドやベクトルの要素へのアクセスマクロ群
* Flags: RTL 式中のフラグ
* Machine Modes: データの大きさと形式の記述
* Constants: 定数値を持つ式
* Regs and Memory: レジスタの内容やメモリを表現する式
* Arithmetic: 算術演算を表す式
* Comparisons: 比較演算式を表す式
* Bit Fields: メモリまたはレジスタ中のビットフィールドを表す式
* Conversions: 拡張、打切、浮動小数点／固定小数点への変換
* RTL Declarations: RTL 宣言
* Side Effects: 副作用のある式
* Incdec: 自動インクリメントアドレッシングに含まれる副作用
* Assembler: オペランドを伴う asm の表現
* Insns: insn 全体の式タイプ
* Calls: 関数呼び出し insn の RTL 表現
* Sharing: 式の共有
* Reading RTL: ファイルからのRTLテキスト形式の読み込み 

##RTL オブジェクト型
RTL は5種類のオブジェクトを使う。式、整数、幅広整数、文字列、ベクトルである。式が最も重要である。ある RTL 式(省略形は"RTX") は、C 言語の構造体だが、普通はポインタで参照される。RTL 式の型は typedef 名rtx で与えられる。

整数は、単に int である。10進数を使って表記する。幅広整数は、整数型のオブジェクトのうちで、その型が HOST_WIDE_INT のものである(see Config)。やはり、10進数を使って表記する。

文字列は文字の連なりである。メモリ中では、通常の C 言語の形式である、char * で表現され、C 言語と同じ文法にしたがって表記する。ただし、RTL での文字列は決してヌルにはならない。マシン記述中で空文字列を書いた場合、メモリ中ではヌルポインタではなく、ヌル文字へのポインタとして表現される。文脈によっては、文字列の代わりにヌルポインタを使っても有効である。RTL のコード内では、文字列は symbol_ref 式の中で最も良く使われる。しかし、マシン記述を構成する RTL 式の他の文脈にも現れる。

ベクトルは、式を指す任意個数のポインタから成る。ベクトルの要素数はベクトルの中で明示的に表現される。ベクトルは、空白で区切られた要素を順番に並べたものを、鍵括弧([...])で囲んで表記する。長さ 0 のベクトルは作成されない。代わりにヌルポインタが使われる。

式は式コード(または RTX コードと呼ばれる) で分類される。式コードは rtl.def で定義される名前であり、大文字で記述したC の列挙型定数でもある。許される式コードとその意味は機種には依存しない。ある RTX のコードはマクロ GET_CODE (x) によって取り出すことができ、また、マクロ PUT_CODE (x, newcode) で変更することができる。

式コードは、式の中にオペランドが幾つあるか、およびオペランドがどんな種類のオブジェクトかを決定する。Lisp と違って RTL では、オペランドを見てもどんな種類のオブジェクトか知ることはできない。代わりに、文脈から知る必要がある。つまり、オペランドを含む式の式コードから知る必要がある。例えば、式コードが subreg である式の中では、最初のオペランドが式と見なされ、二番目のオペランドが整数とみなされる。式コード plus の式では、二つのオペランドがあり、どちらも式としてみなされる。式コード symbol_ref の式では、オペランドは一つであり、文字列としてみなされる。

式は、式のタイプ名と、そのフラグとあればマシンモード、式のオペランドを空白で区切り、括弧で囲んで表記する。

式コード名は、md ファイル中では小文字で書くが、C のコードとしては大文字となって現れる。このマニュアルでは、const_int のように書くことにする。

通常、式が要求される場合でも、ヌルポインタが有効なコンテキストが二、三存在する。その場合には、(nil) と表記する。

##RTL クラスとフォーマット
様々な式コードは幾つかのクラスに分類される。そのクラスは一文字で表現される。ある RTX コードのクラスは、マクロGET_RTX_CLASS (code) を使って知ることができる。現在、rtx.def では以下のクラスを定義している。

o 実際のオブジェクト、例えば、レジスタ(REG)やメモリ位置(MEM、SYMBOL_REF)等の実際のオブジェクトを表すRTX コードである。定数やオブジェクトに基本的な変換を施したもの(ADDRESSOF、HIGH、LO_SUM)も含まれる。SUBREG や STRICT_LOW_PART はこのクラスには含まれず、クラス x に含まれることに注意。 

< NE や LT 等の比較用の RTX コードである。 

1 NEG や NOT、ABS 等の単項算術演算用のRTX コードである。このカテゴリには、値の拡張(符号付きも符号無しも)や整数と浮動小数点の間の変換も含まれる。 

c PLUS や AND 等の交換可能な二項演算の RTX コードである。NE と EQ は比較なので、< クラスになる。 

2 MINUS や DIV、ASHIFTRT 等の交換可能でない二項演算の RTX コードである。 

b ビットフィールド演算の RTX コードである。現時点では、ZERO_EXTRACT と SIGN_EXTRACT だけである。これらは入力が三つあり、左辺値である(そのため、挿入にも同じように使える)。See Bit Fields。 

3 その他の3入力演算の RTX コードである。現時点では、IF_THEN_ELSE のみでる。 

i 命令全体を表す RTX コードである。INSN、JUMP_INSN、CALL_INSN がある。See Insns。 

m MATCH_DUP 等の、insn にマッチする何かを表す RTX コードである。マシン記述にのみ現れる。 

x その他の全ての RTX コードである。このカテゴリには、マシン記述でしか使われない(DEFINE_* 等)残りのコードが含まれる。副作用を記述する全てのコードと insn の連鎖に現れる、NOTE、BARRIER、CODE_LABEL 等の非 insn が含まれる。

rtl.def には、式のタイプ毎に、その式が含むオブジェクトの数とその種類が記述されている。オブジェクトの種類の書き方としては次の四つ(五つのtypo?)がある。式(実際には式へのポインタ)の場合は e、整数は i、幅広整数は w、文字列は s、式のベクトルはE と書く。式コードを表す文字の連なりを フォーマットと呼ぶ。例えば、subreg のフォーマットは ei となる。

その他に以下のフォーマット指定文字が使われる。


u u は、デバッグ用ダンプで異なった表示がなされる以外はe に同じである。insn へのポインタで使われる。 

n n は、デバッグ用ダンプで異なった表示がなされる以外は i に同じである。note insn で行番号やコード番号のために使われる。 

S S は省略可能な文字列を示す。メモリ中での RTL オブジェクトでは、S は s に同じであるが、md ファイルからオブジェクトを読み込む場合には、このオペランドの文字列値は省かれる。省かれた文字列はヌル文字列であるとして扱われる。 

V V は省略可能なベクトルを示す。メモリ中での RTL オブジェクトでは、V は E に同じであるが、md ファイルからオブジェクトを読み込む場合には、このオペランドのベクトル値は省かれる。省かれたベクトルは、実質的には要素が一つもないベクトルと同じである。 

0 0 は、通常のカテゴリには収まらないものを入れるためのスロットであることを意味する。0 のスロットは、どのダンプにも表示されず、gcc の極く一部で特別な使われ方をする。

以下は、オペランド数、式コードのフォーマットを得るためのマクロである。

GET_RTX_LENGTH (code)
コードが code である RTX のオペランド数。 

GET_RTX_FORMAT (code)
コードが code である RTX のフォーマットを C の文字列で表したもの。

RTX コードの幾つかのクラスは常に同じフォーマットである。例えば、全ての比較演算のフォーマットは ee であると想定しても安全である。


1 このクラスのコードのフォーマットは全て e である。 

< c 2 このクラスのコードのフォーマットは全て ee である。 

b 3 このクラスのコードのフォーマットは全て eee である。 

i このクラスのコードのフォーマットは全て iuueiee で始まる。ある insn の連鎖にリンクされた RTL オブジェクトのクラスが全てi ではないことに注意。 

o m x これらのコードのフォーマットについては何ら想定を置くことはできない。

##オペランドへのアクセス
式中のオペランドは、XEXP や XINT、XWINT、それにXSTR というマクロを使って参照することができる。これらのマクロはそれぞれ引数を二つ取る。RTL式のポインタ(RTX) とオペランドの番号である。オペランドの番号は 0 からはじまる。例えば、

```
XEXP (x, 2)
```
とあれば、式 x の二番目のオペランドを式として参照する。

```
XINT (x, 2)
```
こちらは、同じオペランドを整数として参照する。同様に、XSTR を使うと文字列として参照する。

どんなオペランドも整数として、あるいは式として、また文字列として参照できる。ユーザは、オペランドに実際貯えられている値の種類に応じて、正しい参照方法を選ばなければならない。これは、オペランドを含んでいる式の式コードを見て判断するのが良い。また、オペランド数を調べるのも式コードで調べることができる。

例えば、x が subreg 式なら、オペランドは二つあり、それぞれ XEXP (x, 0) と XINT (x, 0) として正しく参照できる。XINT (x, 0) とすると、オペランド 0 の式のアドレスを整数にキャストしたものが得られる。こういう参照の仕方が有効な場合は滅多にないと思うが、もし書くなら(int) XEXP (x, 0) としたほうがきれいである。また XEXP (x, 1) という書き方もエラー無しでコンパイルできて、二番目の整数オペランドを式のポインタにキャストした結果を返す。しかし、それを参照したときに恐らくプログラムが落ちてしまう。さらには、XEXP (x, 28) のように書くこともできるが、式の終りを越えたメモリをアクセスし、予期できない結果に終わるだろう。

オペランドがベクトルの場合の参照方法はもっと複雑である。マクロ XVEC を使うとベクトルへのポインタそのものが得られ、XVECEXP と XVECLEN を使うとそれぞれ、ベクトルの要素と長さを得ることができる。

```
XVEC (exp, idx)
```
式 exp の idx 番目のオペランドをベクトルへのポインタとして参照する。 

```
XVECLEN (exp, idx)
```
式 exp の idx 番目のオペランドであるベクトルの長さを返す。この値は int 型である。 

```
XVECEXP (exp, idx, eltnum)
```
式 exp の idx 番目のオペランドであるベクトルの eltnum 番目の要素を参照する。この値は RTX である。

eltnum が負でないことおよび XVECLEN (exp, idx) より小さいことを保証するのはユーザの責任である。

このセクションで定義したマクロは全て左辺値として展開されるので、単に参照するだけでなく、オペランドや長さやベクトルの要素を代入することができる。

##RTL 式中のフラグ

RTL 式は、ある種の型の式で使われる色々なフラグ(一ビットのビットフィールド)とその他の値を含んでいる。ほとんどの場合、フラグは以下のマクロで参照される。


MEM_VOLATILE_P (x)
mem 式において、揮発性のメモリ参照の場合に非 0 となる。volatil フィールドに格納され、/v と出力される。 

MEM_IN_STRUCT_P (x)
mem 式において、構造体や共用体、配列全体かそれらの成分を参照するときに非0となる。スカラ変数への、あるいはポインタを通してのスカラ変数への参照の場合は 0 となる。in_struct フィールドに格納され、/s と出力される。このフラグと MEM_SCALAR_P がどちらもクリアされていると、この MEM が構造体の中にあるのかどうかがわからない。両方のフラグが同時に設定されることがあってはならない。 

MEM_SCALAR_P (x)
mem 式において、構造体や共用体、配列のメンバでないことが知られているスカラに対する参照の場合はゼロでない値となる。構造体や共用体、配列のメンバに対する参照や、ポインタを経由しての間接参照に対しては、たとえそのポインタがスカラ型を指していてもゼロとなる。このフラグと MEM_STRUCT_P が両方ともクリアされていると、この MEM が構造体の中にあるのかどうか分からない。両方のフラグを同時にセットしてはならない。 

MEM_ALIAS_SET (x)
mem 式において、x が属する別名のセットを表す。これがゼロであれば、x どの別名のセットにも入っておらず、任意のものの別名になりうる。ゼロでない場合は、x は、同じ別名セットに入っているオブジェとの別名にしかならない。この値は、言語フロントエンドにより(言語固有の方法で)設定される。このフィールドはビットフィールドではない。整数であり、mem の第二引数に現れるものである。 

REG_LOOP_TEST_P
reg 式において、レジスタの生存期間がループの脱出条件のテストに含まれるなら、非0となる。in_struct フィールドに格納され、/s と出力される。 

REG_USERVAR_P (x)
reg 式において、ユーザのソースコード中に存在する変数に対応するなら非0となる。コンパイラ内部で一時的に生成されたものなら0となる。volatil フィールドに格納され、/v と出力される。 

REG_FUNCTION_VALUE_P (x)
reg 式において、このレジスタに現在の関数の戻り値が置かれるなら非 0 である。(これは物理レジスタの場合にのみ発生する。) integrated フィールドに格納され、/i と出力される。
同じ物理レジスタが現在の関数が呼び出した関数の戻り値を置くのに使われても良いが、そういう使い方の場合には REG_FUNCTION_VALUE_P は 0 である。 

SUBREG_PROMOTED_VAR_P
subreg 式において、それが、マシン記述マクロ PROMOTED_MODE (see Storage Layout)に従って、より幅の広いモードに拡張されたオブジェクトを参照した際に作られたものなら、非ゼロである。この場合、subreg のモードはそのオブジェクトの宣言されたモードであり、SUBREG_REG のモードはそのオブジェクトを保持するレジスタのモードである。拡張された変数は、それぞれの代入の際に、常に、より幅の広いモードへ符号拡張またゼロ拡張される。in_struct フィールドに格納され、/s として出力される。 

SUBREG_PROMOTED_UNSIGNED_P
SUBREG_PROMOTED_VAR_P が、参照されているオブジェクトがゼロ拡張され続ける場合はゼロでなく、符号拡張され続ける場合はゼロとなるような、subreg の中では、非ゼロである。unchanging フィールドに格納され、/u と出力される。 

RTX_UNCHANGING_P (x)
reg または mem では、その値が変化しないのであれば、非 0 である。(このフラグは、ポインタを経由しての定数へのメモリ参照では設定されない。そういうポインタは、現在の関数ではオブジェクトは明示的には変化しないということを保証するだけである。オブジェクトは、他の関数やエイリアシングにより変化し得るのである。) unchanging フィールドに格納され、/u と出力される。 

RTX_INTEGRATED_P (insn)
インライン関数呼び出しの結果生じる insn 中では非 0 である。integrated フィールドに格納され、/i と出力される。 
RTX_FRAME_RELATED_P (x)
一個の insn また式で、関数プロローグの一部であり、かつ、スタックポインタを設定しているか、フレームポインタを設定しているか、レジスタをセーブしているものの中であれば、ゼロでない値となる。このフラグは、RTL プロローグを持つターゲットで例外処理をサポートするのに必要となる。 

SYMBOL_REF_USED (x)
symbol_ref 中で、x が使われていることを指示する。通常は、x が external として一度だけ宣言されていることを保証するのに使われるだけである。used フィールドに格納される。 

SYMBOL_REF_FLAG (x)
symbol_ref 中で、機種に固有な目的のためのフラグとして使われる。volatil フィールドに格納され、/v として出力される。 

LABEL_OUTSIDE_LOOP_P
label_ref 式の中で、ラベルへの参照がある場合、そのラベルが、ラベルへの参照を含む最も内側のループの外側にあるなら、非ゼロとなる。in_struct フィールドに格納され、/s として出力される。 

INSN_DELETED_P (insn)
insn の中で、その insn が削除済であれば非 0 である。volatil フィールドに格納され、/v と出力される。 
INSN_ANNULLED_BRANCH_P (insn)
分岐 insn の遅延スロットにある insn の中で、無効化分岐を使うべきかどうかを指示する。以下の sequence の議論を参照のこと。unchanging フィールドに格納され、/u と出力される。 

INSN_FROM_TARGET_P (insn)
分岐命令の遅延スロット中の insn の中で、その insn が分岐命令のターゲットから来たものであることを示す。分岐 insn の INSN_ANNULLED_BRANCH_P ビットが立っていれば、この insn は、分岐が成立したときにのみ実行される。INSN_FROM_TARGET_Pビットが立っていない無効化された分岐命令の場合は、insn は、分岐が成立しなかったときにのみ実行される。INSN_ANNULLED_BRANCH_P が設定されていない場合は、この insn は常に実行される。in_struct フィールドに格納され、/s と出力される。 

CONSTANT_POOL_ADDRESS_P (x)
symbol_ref の中で、現在の関数の「定数プール」の一部を参照しているなら、非ゼロとなる。これらは、関数の先頭に近いアドレスであり、GNU CC は、直接的にアクセスが可能であると仮定する(恐らく、ベースレジスタの助けを借りて)。unchanging フィールドに格納され、/u と出力される。 

CONST_CALL_P (x)
call_insn の中で、insn が定数関数への呼び出しを表しているかどうかを示す。unchanging フィールドに格納され、/u と出力される。 

LABEL_PRESERVE_P (x)
code_label の中で、そのラベルが削除不可であることを示す。非局所的 goto によるラベルの参照でこのビットがセットされる。in_struct フィールドに格納され、/s と出力される。 

SCHED_GROUP_P (insn)
命令スケジューリング中、ある insn において、直前の insn はこの insn と同時にスケジューリングされなければならないことを示す。これを使って、ある命令のグループが命令スケジューリングのパスによって、分割されないことを保証する。例えば、call_insn の直前のuse insn は、call_insn から分離されることはない。in_struct フィールドに格納され、/s として出力される。

以下に、上述のマクロが参照するフィールドを挙げる。

used

通常は、このフラグは、関数の RTL 生成の最後で、ある式が insn の中に何回現れたかを数えるために、一時的に使われるだけである。二回以上現れた式は、共有構造の規則に従ってコピーされる(see Sharing)。

symbol_ref では、そのシンボルに対する外部宣言が既に書き込み済であることを意味する。

reg では、リーフレジスタの番号付け替えのコード部分で、各レジスタの番号付け替えが一回だけ行われることを保証するのに使われる。 

volatil

このフラグは、mem式、symbol_ref式、reg式およびinsn の中で使われる。RTL ダンプファイルでは、/v と表記される。

mem 式の中では、メモリ参照が揮発性(volatile)であれば 1 である。揮発性メモリ参照は、削除や並べかえや結合は出来ない。

symbol_ref 式の中では、機種固有の目的で使われる。

reg 式の中では、その値がユーザレベルの変数であれば、1 である。0 であれば、コンパイラが内部的に使う一時的なものであること示す。

insn の中では、1 であればその insn が既に削除された事を意味する。 

in_struct

mem式の中では、その式が参照するメモリデータが、構造体または配列の全体あるいは一部であれば、1 となる。スカラ変数であれば、0 になる。C 言語のポインタを通しての参照は 0 となる。ポインタはスカラ変数を指すからである。この情報により、GCC が、エイリアシングが起こる場合について何らかの決定を下すことができるようになる。

分岐命令の遅延スロットの insn の中では、1 であれば、この insn が分岐先から来たものであることを意味する。

命令のスケジューリングの間では、insn の中では、1 であれば、この insn は、直前の insn と共に構成するグループの一部としてスケジュールされなければならないことを意味する。

reg 式の中では、その式が示すレジスタの生存範囲が、あるループの条件式の中に完全に収まるのであれば、1 である。

subreg 式の中では、1 であれば、その subreg が、より広いモードから格上げされたモードを持っていたオブジェクトを参照していることを示す。

label_ref 式の中では、1 であれば、参照しているラベルが、その label_ref 式のある insn を含む最も内側のループの外にあることを示す。

code_label 式の中では、そのラベルが削除されることが決してありえないのなら、1 である。これは、非局所的な goto の目的先であるラベルで使われる。

RTL ダンプの中では、このフラグは /s と表記される。 

unchanging

reg 式と mem 式の中では、1 であれば、その式の値が決して変化しないことを意味する。

subreg 式の中では、その subreg 式が、より広いモードへ格上げされたモードを持つ符号無しのオブジェクトを参照しているのであれば、1 である。

insn の中では、1 であれば、無効化付きの分岐であることを意味する。

symbol_ref 式の中では、1 であれば、このシンボルが、関数毎の定数プール中の何かを参照していることを示す。

call_insn の中では、1 であれば、この命令が定数関数への呼び出しであることを意味する。

RTL ダンプ中では、このフラグは /u と表示される。 

integrated

insnを含む、ある種の式の中では、このフラグは、この RTL が手続き統合(procedure integration)により生成されたことを意味する。

reg 式の中では、このフラグは、このレジスタが、現在の関数により返されるはずの値を含んでいることを示す。引数をレジスタで渡す機種では、同じ番号のレジスタが引数としても使われるが、その様に使用される場合にはこのフラグはセットされない。


##マシンモード
マシンモードは、データオブジェクトの大きさ、その表現方法を記述する。C のコード中では、マシンモードは列挙型 enum machine_mode で表現される。この列挙型は、machmode.def で定義されている。各 RTL 式にはマシンモードを格納する場所があり、そのため、ある種のツリー式(正確には、宣言と型である)を格納する場所も持っている。

デバッグダンプとマシン記述のなかでは、RTL 式のマシンモードは、式コードの後ろにコロンで区切って書く。各マシンモード名に付くmodeは、省略される。例えば、(reg:SI 38) は、reg 式で、マシンモードはSImode である。モードが VOIDmode の場合は、モードとしては何も出力されない。

以下にマシンモードの表を示す。以下では、「バイト」とは、BITS_PER_UNIT ビットのオブジェクトを指す(see Storage Layout)。

QImode
「1/4 精度整数」(Quarter-Integer)モードは、整数として扱われる1バイトを表現する。 

HImode
「1/2 精度整数」(Half-Integer)モードは、2バイト整数を表す。 

PSImode
「部分単精度整数」(Partial Single Integer)モードは、4バイトを占有するが、実際に4バイト全てを使うことはないような整数を表す。マシンによっては、これがポインタ用の正しいモードになる。 

SImode
「単精度整数」(Single Integer)モードは、四バイト整数を表す。
 
PDImode
「部分倍精度整数」(Partial Double Integer)モードは、8バイトを占有するが、実際に8バイト全てを使うことはないような整数を表す。マシンによっては、これがある種のポインタ用の正しいモードになる。 

DImode
「倍精度整数」モードは八バイト整数を表す。 

TImode
「4倍精度整数」(Tetra Integer)モードは、16バイト整数を表す。 

SFmode
「単精度浮動小数点数」(Single Floating)モードは、単精度(四バイト)浮動小数点数を表す。 

DFmode
「倍精度浮動小数点数」(Double Floating)モードは、倍精度(八バイト)浮動小数点数を表す。 

XFmode
「拡張精度浮動小数点数」(Extended Floating)モードは、3倍精度(12バイト) 浮動小数点数を表す。このモードは、IEEE 拡張浮動小数点数に使う。システムによっては、12バイトの中には実際に使われないビットがある。 

TFmode
「4倍精度浮動小数点数」(Tetra Floating)モードは、4倍精度(16バイト) 浮動小数点数を表す。 

CCmode
「条件コード」(Condition Code)モードは、条件コードの値を表す。条件コードは、機種に固有のビットの一群で、比較演算の結果を表す。これ以外の機種固有のモードが条件コードに対して使われることもある。これらのモードは、cc0 を使う機種では使われない。(see Condition Code。) 

BLKmode
「ブロック」(Block)モードは、他のどのモードも適用できないような集合体の値を表す。RTL では、メモリへの参照のみがこのモードを取りうる。しかも、それが文字列移動またはベクトル命令中に現れたときだけに限られる。このような命令を持たない機種では、BLKmode が RTL に現れることはない。 

VOIDmode
「ボイド」(Void)モードは、モードがないこと、あるいはモードを指定しないことを意味する。例えば、コードが const_int である RTL 式はVOIDmode になる。何故なら、文脈が要求するどんなモードとしても取ることが出来るからである。RTL のデバッグダンプ中では、VOIDmode は、モードが一切無いことにより表現される。 

SCmode, DCmode, XCmode, TCmode
これらのモードは、浮動小数点数値の対として表現された複素数を表す。浮動小数点数値は、それぞれ、SFmode, DFmode, XFmode, TFmode になる。 

CQImode, CHImode, CSImode, CDImode, CTImode, COImode
これらのモードは、整数値の対として表現された複素数を表す。整数値は、それぞれ、QImode, HImode, SImode, DImode, TImode, OImode である。

マシン記述では、Pmode を C のマクロとして定義し、このマクロはアドレス向けのマシンモードに展開される。普通は、これは BITS_PER_WORD の大きさのモードであり、32ビットのマシンでは SImode になる。

マシン記述に必ず記述が必要なのは、QImode と、それぞれBITS_PER_WORD、FLOAT_TYPE_SIZE、DOUBLE_TYPE_SIZE に対応するモードである。GCC は、8バイトの構造体と共用体に対して DImode を使うことを試みるが、MAX_FIXED_MODE_SIZE の定義を書き換えることにより、抑止することができる。また、16バイトの構造体と共用体向けに TImode を使わせることも可能である。同様に、C の short int 型に、HImode を使うのを避けるように設定することも可能である。

現在では、GCC の中でマシンモードを明示的に参照しているコードはほとんどなく、あっても早々に削除してしまう予定である。その代わり、マシンモードをモードのクラスに分割している。マシンモードのクラスは、列挙型enum mode_class で表される。この列挙型は machmode.h で定義されている。取りうるモードクラスは以下の通りである。

MODE_INT
整数モード。デフォルトでは、QImode, HImode, 
SImode, DImode, TImode が該当する。 

MODE_PARTIAL_INT
「部分整数モード」を表す。PSImode と PDImode が該当する。 

MODE_FLOAT
浮動小数点モード。デフォルトでは、SFmode, DFmode, XFmode, TFmode である。 

MODE_COMPLEX_INT
整数複素数モード。(現時点では実装されていない。) 

MODE_COMPLEX_FLOAT
浮動小数点複素数モード。デフォルトでは、SCmode、DCmode, XCmode, and TCmode である。 

MODE_FUNCTION
静的チェーンを含む、Algol や Pascal の関数変数である。(現時点では実装されていない。) 

MODE_CC
条件コード値を表すモード。これには、CCmode と、EXTRA_CC_MODES マクロに示された全てのモードが含まれる。See Jump Patterns、Condition Code を参照のこと。 

MODE_RANDOM
これは、上記のどのクラスにも当てはまらないモードのための受皿モードである。現時点では、VOIDmode と BLKmode が MODE_RANDOM に該当する。

以下にマシンモード関連の C マクロを示す。

GET_MODE (x)
RTX x のマシンモードを返す。 

PUT_MODE (x, newmode)
RTX x のマシンモードを newmode にする。 

NUM_MACHINE_MODES
ターゲット機種で利用可能なマシンモードの数を表す。これは、マシンモード値のうち最大のものに 1 を足したものになる。 

GET_MODE_NAME (m)
モード m の名前を文字列で返す。 

GET_MODE_CLASS (m)
モード m のモードクラスを返す。 

GET_MODE_WIDER_MODE (m)
指定したモードの次に広い自然なモードを返す。例えば、GET_MODE_WIDER_MODE (QImode) という式は、HImode を返す。 

GET_MODE_SIZE (m)
モード m のデータの大きさをバイト数で返す。 

GET_MODE_BITSIZE (m)
モード m のデータの大きさをビット数で返す。 

GET_MODE_MASK (m)
一語中のビットのうち、モード m の範囲内に収まる全てのビットを表すビットマスクを返す。このマクロは、ビット数が HOST_BITS_PER_INT 以下であるモードに対してのみ使うことができる。 

GET_MODE_ALIGNMENT (m)
モード m のオブジェクトに必要なアラインメントをビット数で返す。 

GET_MODE_UNIT_SIZE (m)
モード m のデータの部分単位の大きさをバイト数で返す。これは、複素数のモードの場合以外は、GET_MODE_SIZE と同じである。複素数のモードの場合は、部分単位の大きさは、実数部また虚数部の大きさである。 

GET_MODE_NUNITS (m)
あるモードに含まれる単位の数を返す。すなわち、GET_MODE_SIZE を GET_MODE_UNIT_SIZE で割ったものを返す。 

GET_CLASS_NARROWEST_MODE (c)
モードクラス c の中で最も幅の狭いモードを返す。

グローバル変数 byte_mode と word_mode は、モードクラスが MODE_INT であり、ビット数がそれぞれ BITS_PER_UNIT と BITS_PER_WORD のモードを保持している。32ビットマシンでは、それぞれ QImode と SImode になる。

##定数式型
最も簡単な RTL 式は、定数値を表すものである。

(const_int i)

この型の式は、整数値 i を表す。i は、マクロ INTVAL を使って INTVAL (exp) のように参照するのが良く行われる。これは、XWINT (exp, 0) と書くのと同じである。

整数値 0 を表す式オブジェクトは唯一つしかなく、変数 const0_rtx の値だけである。同じく、整数値 1 に対する式は、const1_rtx だけであり、整数値 2 に対する式は、const2_rtx だけである。さらに、整数値 -1 に対する式は constm1_rtx だけである。コードが const_int で、値が 0, 1, 2, -1 のどれかの式を作ろうとすると、それぞれ、const0_rtx、const1_rtx、const2_rtx、constm1_rtx が返される。

同様に、値が STORE_FLAG_VALUE である整数に対するオブジェクトは唯一つだけで、const_true_rtx になる。STORE_FLAG_VALUE が1 であれば、const_true_rtx と const1_rtx は同じオブジェクトを指す。STORE_FLAG_VALUE が -1 なら、const_true_rtx とconstm1_rtx は同じオブジェクトを指すことになる。 

(const_double:m addr i0 i1 ...)

モード m の浮動小数点定数か、HOST_BITS_PER_WIDE_INT ビットには収まらないが HOST_BITS_PER_WIDE_INT の二倍のビット数になら収まるような整数定数を表す(GNU CC は、それ以上に大きい定数を表現する機能は提供していない)。後者の場合は、m は VOIDmode になる。

addr は、定数が置かれているメモリ上の位置に対応する mem 式を保持する。メモリ上の位置は確保されていないが、現在のコンパイル(表示されないフィールドを使い維持されている)の全ての const_double 式の連鎖上には存在するなら、addr は const0_rtx を含む。その連鎖に存在しなければ、addr は cc0_rtx を含む。addr は、マクロ CONST_DOUBLE_MEM とCONST_DOUBLE_CHAIN を経由した連鎖フィールドを使ってアクセスするようになっている。

m が VOIDmode なら、値を表すビット群は i0 と i1 に格納される。i0 はマクロ CONST_DOUBLE_LOW で、i1 はCONST_DOUBLE_HIGH で参照するのが通例となっている。

定数が浮動小数点数なら(精度に関わらず)、その値を格納するのに必要な整数の個数は、REAL_VALUE_TYPE に依存する(see Cross-compilation)。その整数群は浮動小数点数を表現するが、厳密にはターゲットマシンまたホストマシンの浮動小数点数形式ではない。ターゲットマシンで使われる正確なビットパターンに変換するには、マクロ REAL_VALUE_TO_TARGET_DOUBLE と関連マクロを使用すること(see Data Output)。

マクロ CONST0_RTX (mode) は、値が 0 でモードが mode の式を参照する。モード mode が、MODE_INT のクラスのモードであれば、const0_rtx を返す。そうでなければ、モード mode のCONST_DOUBLE 式を返す。同様に、マクロ CONST1_RTX (mode) は、値が 1 でモード mode の式を参照する。CONST2_RTX についても同様である。 

(const_string str)

値が str である文字列定数を表す。現時点では、この式は insn の属性(see Insn Attributes)についてのみ使われている。というのは、C 言語の文字列定数はメモリ中に置かれるからである。 

(symbol_ref:mode symbol)

アセンブラのデータに対するラベルの値を表現する。symbol は、アセンブララベル名を記述する文字列である。この文字列が * で始まるなら、ラベル名は、symbol から* を除いたものになる。それ以外の場合は、symbol そのものがラベル名となり、通常は _ というプレフィックスが付く。

symbol_ref にはモードがあり、普通は Pmode になる。普通は、このモードがシンボルに対して直接有効になる唯一のモードである。 

(label_ref label)

コードに対するアセンブラ・ラベルの値を表現する。オペランドは一つであり、それは式となる。この式は、ラベルの置かれるべき位置を特定するための命令列に現れる code_label でなければならない。

コードラベルの参照に異なる式のタイプを使用するのは、ジャンプ最適化で区別できるようにするためである。 

(const:m exp)

アセンブル時の代数計算の結果として生じる定数を表現する。オペランド exp は、定数(const_int、symbol_ref、label_ref 式)に plus と minus を組み合わせたもののみからなる式である。ただし、全ての組合せが有効とは限らない。アセンブラは、再配置可能なシンボルについては勝手な計算は出来ないからである。

m は Pmode でなければならない。 

(high:m exp)

exp、普通は symbol_ref の上位ビット群を表現する。ビット数は機種依存であり、通常はレジスタの上位ビットを初期化する命令で指定されるビット数になる。lo_sum と共に使って、RISC で良く使われる、グローバルなメモリ位置を参照する典型的な二命令の列を表現する。

m は Pmode でなければならない。

###レジスタとメモリ

以下に、レジスタとメモリへのアクセスを記述する、RTL 式のタイプを示す。

(reg:m n)

小さな整数 n (FIRST_PSEUDO_REGISTER より小さい)に対して、マシンのレジスタ番号 n、すなわちハードレジスタの参照であることを意味する。n が大きな値の場合は、一時的な値か 仮想レジスタを表す。GCC の戦略としては、まず、このような仮想レジスタが無限個あると仮定してコード生成を行ない、後で、ハードレジスタかメモリ参照への置き換えを行なう。

m は、この参照のマシンモードである。モードの指定が必要なのは、一般に複数のモードで各レジスタを参照することが可能だからである。例えば、レジスタを一つ取ってみると、そこには全語を入れることができるが、それを半語やバイトとして参照する命令や、色々な精度の浮動小数点数として参照する命令もありうるのである。

レジスタをアクセスするモードが一つしかないマシンの場合でも、モードは常に指定しなければならない。

FIRST_PSEUDO_REGISTER というシンボルはマシン記述により定義される。というのは、あるマシンのハードレジスタの数はそのマシンの不変の特徴だからである。ただ、マシンのレジスタが全て汎用レジスタである必要はない。データの格納に使える全てのマシンレジスタは、ハードレジスタ番号が与えられる。たとえ、それらのレジスタが特定の命令でしか使えなかったり、特定の型のデータしか保持できなくても。

ハードレジスタは一つの関数の中でも色々なモードでアクセスされる。しかし、疑似レジスタにはそれぞれ自然なモードが与えられており、そのモードでしかアクセスされない。疑似レジスタを自然なモード以外のモードでアクセスするのを記述する必要があるときは、subreg 式が使われる。

1ワードより多くのデータを指定するマシンモードを持つ reg 式は、実際には幾つかの連続するレジスタを表す事がある。そのレジスタ番号が、ある一個のハードウェアレジスタを指定するだけでなく、実際には、その指定されたレジスタから始まる、幾つかの連続したハードウェアレジスタ群を表している。

関数 RTL コードで使われている疑似レジスタ番号はそれぞれ、一意的な reg 式で表現される。

FIRST_VIRTUAL_REGISTER から LAST_VIRTUAL_REGISTER までの範囲の疑似レジスタ番号のうちいくつかは、RTL 生成過程にしか現れず、最適化過程の前に削除される。こういう疑似レジスタ番号は、それを含む関数についての RTL 生成が完了するまでは決定できないスタックフレーム中の位置を表す。以下の仮想レジスタ番号が定義されている。

VIRTUAL_INCOMING_ARGS_REGNUM

スタック渡しされた入力引数の先頭のワードを指し示す。通常、これらの引数は呼びだし側によって置かれるが、呼び出された側が、以前にレジスタで渡された引数の幾つかをプッシュすることもありうる。

RTL が完了した時点で、この仮想レジスタは、 ARG_POINTER_REGNUM で指定されるレジスタと FIRST_PARM_OFFSET の値の和に置き換えられる。 

VIRTUAL_STACK_VARS_REGNUM

FRAME_GROWS_DOWNWARD が定義されていれば、このマクロはスタック上の先頭の変数のすぐ上を指す。FRAME_GROWS_DOWNWARD が定義されていない場合は、スタック上の先頭の変数そのものを指す。
VIRTUAL_STACK_VARS_REGNUM は、FRAME_POINTER_REGNUM で指定されるレジスタと STARTING_FRAME_OFFSET の値の和で置き換えられる。 

VIRTUAL_STACK_DYNAMIC_REGNUM

これは、必要とするメモリ量の分だけスタックポインタの調整が行なわれた直後の、スタック上に動的に確保されたメモリの位置を指す。
この仮想レジスタは、STACK_POINTER_REGNUM で指定されるレジスタとSTACK_DYNAMIC_OFFSET の値の和に置き換えられる。 

VIRTUAL_OUTGOING_ARGS_REGNUM

スタックが前もってプッシュされたときに、出力引数が書き込まれるべきスタック上の位置を指す。(push insn を使ってプッシュされる引数は常に STACK_POINTER_REGNUM を使うべきである。)
この仮想レジスタは、STACK_POINTER_REGNUM で指定されるレジスタとSTACK_POINTER_OFFSET の値の和に置き換えられる。


(subreg:m reg wordnum)

subreg 式は、マシンに取って自然なモード以外のモードにあるレジスタ、あるいは実際には複数のレジスタを参照する複数ワードの reg のうちの一つのレジスタを参照するのに使われる。

疑似レジスタにはそれぞれ自然なモードがある。その自然なモードとは異なるモードでの操作が必要な場合、例えば、一個のバイトを保持している疑似レジスタに対してフルワードの移動命令を行なう場合は、その疑似レジスタは subreg の中に収まっていなければならない。この例の場合は、wordnum は 0 である。

m は普通は少なくとも reg のモードの幅しかなく、その場合、reg のビットのうち m に入っているものだけを考えれば良い。

場合によっては、m は reg のモードよりも広い。そういう subreg 式は、病的と呼ばれることがある。このような式は、より広いモードのオブジェクトを参照したいが、付加的なビットがどういう値を持っているかは気にしないという場合に使われる。再ロードパスは、病的な参照はハードレジスタに対してのみ作られることを保証する。

subreg の別の使い方は、複数のレジスタからなる値から個々のレジスタを取り出すことである。DImode や TImode の様なマシンモードは、一語より長い値、つまり通常二つ以上のレジスタを必要とする値である可能性がある。こういうレジスタの一つを参照するには、subreg をモードSImode で使い、wordnum でどのレジスタかを指定する。

病的でない subreg に格納すると、subreg と同じワードに属するビットに予期できない結果を生ずる。この手抜きにより、そういう命令に対して効率の良いコードを生成するのが用意になる。subreg の外側の全ビットを保存する命令を表現するには、subreg を strict_low_part で囲めば良い。

コンパイル時のパラメータである WORDS_BIG_ENDIAN が 1 に設定されていれば、ワード番号 0 が最上位部であることを指示する。1 でなければ、ワード番号 0 は最下位部を指示する。

ターゲットによっては、FLOAT_WORDS_BIG_ENDIAN とWORDS_BIG_ENDIAN が一致しないものが 2、3ある。だが、GCC のほとんどの部分は、浮動小数点値を、整数値と同じエンディアンであるとして取り扱っている。これがうまく働くのは、単に、それらを整数値の集まりとして扱っているからである。real.c と実行時ライブラリだけが、FLOAT_WORDS_BIG_ENDIAN に注意している。

結合パスと再ロードパスの間で、第一引数が reg ではなくmem になっている、病的な subreg が発生する可能性がある。また、再ロードパスの後では、mem を含む病的な subreg が発生する可能性があり、通常、mem が疑似レジスタを置き換えたスタックスロットである場合に起きる。

DFmode の値を subreg を使って SFmode で参照するのは正しくないことに注意。マシンによっては、DFmode の値の上位部分が単精度浮動小数点数値と同じフォーマットでない場合がある。

また、一個のハードレジスタにある複数ワードの値のうちの一ワードをアクセスすることは、その値が大きさから期待されるよりも少ないレジスタで保持できるときは、正しくない。例えば、32ビットマシンでは、浮動小数点レジスタは一個の DFmode の値全体を保持できる。レジスタ 10 がそのようなレジスタなら、(subreg:SI (reg:DF 10) 1) は正しくない。なぜなら、そのような参照を一個のマシンレジスタに変換する方法がないからである。再ロードパスは、subreg 式がこのような形式になるのを抑止する。

subreg 式の先頭のオペランドは SUBREG_REG マクロで、第二オペランドは SUBREG_WORD マクロで参照する。 

(scratch:m)

一個の命令の実行に必要とされ、それ以降は使われないスクラッチレジスタを表す。局所レジスタ確保か再ロードパスのどちらかにより、reg に変換される。

scratch は、普通は clobber 演算中に存在する(see Side Effects)。 


(cc0)

条件コードレジスタを参照する。オペランドは無く、マシンモードも持たない。使い方は以下の二通りがある。

条件コードフラグの完全なセットを表すために使う。ほとんどのマシンでは、それぞれの比較が一連のフラグ全体を設定するので、これが最善である。

このテクニックを使うと、(cc0) が正しく使える文脈は二つだけである。代入における代入先(テストおよび比較命令において)として、および 0 (値がゼロの const_int、すなわち const0_rtx である) との比較を行なう比較演算においてである。

一個の条件の結果である一個のフラグを表すために使う。これは、一個のフラグビットしか持たないマシン上で、そして比較命令がテストすべき条件を指定しなければならない場合に役にたつ。

この手法を使う場合、(cc0) が有効なのは次の二つの文脈だけである。ソースオペランドが比較演算子である(テストと比較命令では) 代入の目的オペランドとして、もう一つは(条件分岐の) if_then_else の最初のオペランドとしてである。

コード cc0 の式オブジェクトはただ一つだけ存在する。変数 cc0_rtx の値である。コード cc0 の式を作りだそうとすると必ず cc0_rtx が返ってくる。

命令が暗黙のうちに条件コードを設定する可能性がある。多くのマシンでは、ほぼ全ての命令が計算したり、格納した値に基づいて条件コードを設定する。こういう動作を RTL に明示的に記録する必要はない。というのは、マシン記述に、その命令が条件コードを設定することを認識するための指示が含まれているからである(マクロ NOTICE_UPDATE_CC を使う)。See Condition Code。条件コードを設定することだけを目的とする命令、そして条件コードを使用する命令だけが、(cc0) を書く必要がある。

マシンによっては、条件コードレジスタにレジスタ番号が与えられ、reg が (cc0) の代わりに使われる。条件コードを書き換える命令がほんの一部の命令に限られるなら、このアプローチが望ましい。また別のマシンでは、条件コードを汎用レジスタに格納する。その場合は疑似レジスタを使うべきである。

Sparc や RS/6000 のようなマシンでは、二種類の算術演算命令のセットがある。一つのセットは条件コードを設定し、もう一つは設定しない。このような場合を扱う最も良い方法は、通常は、条件コードを設定しない命令を生成し、算術演算の実行と条件コードレジスタ(この場合は(cc0) ではない)の設定の両方を行なうパターンを作ることである。例としては、sparc.md で addcc や andcc を探してみて欲しい。 

(pc)

プログラムカウンタを表す。オペランドは取らず、マシンモードも持たなくて良い。(pc) が使えるのは、分岐命令の特定の文脈においてだけである。

コードが pc である式オブジェクトはただ一つである。変数 pc_rtx の値である。コードが pc の式を作ろうとすると返ってくるのはpc_rtx になる。

分岐を行なわない命令は全て、プログラムカウンタをインクリメントすることにより暗黙のうちに変更する。しかし、このことを RTL に記述する必要はない。 

(mem:m addr)

この RTX は、式 addr で表されるアドレスの主記憶への参照を表す。m はメモリの、アクセスされる単位の大きさを表す。 
(addressof:m reg)

この RTX はレジスタ reg のアドレスを要求することを表す。モードは常に Pmode である。CSE のフェーズの後で関数内に addressof 式がどんなものであれ残っていれば、reg は強制的にスタックに置かれ、addressof 式は、そのスタックスロットのアドレスを表す plus 式で置き換えられる。

##算術演算用 RTL 式
指定されない限り、代数演算式の全てのオペランドはモード m に対して有効でなければならない。あるオペランドがモード m に対して有効なのは、オペランド自身のモードが m の場合か、オペランドが const_int または const_double で m が MODE_INT クラスのモードの時である。

交換可能な二項演算の場合には、定数は二番目のオペランドに置くべきである。

(plus:m x y)

マシンモード m で実行される、x と y で表される値の加算を表す。 

(lo_sum:m x y)

plus にほぼ同じだが、x と、y の下位ビットの和を表す点が異なる。下位ビット数は機種により異なるが、一般には、Pmode のビット数から、コード high によってセットされるビット数を引いたものになる(see Constants)。
m は、Pmode でなければならない。 

(minus:m x y)

減算を表す以外は plus と同じである。 

(compare:m x y)

比較目的の y から x を引く減算の結果を表す。無限の精度があるかのように、計算は桁溢れなしで行われる。
当然のことだが、実際に無限の精度で引き算を行える機械は存在しない。だが、引き算の結果の符号だけが使われる場合は、無限の精度で引き算ができるような振りをすることができる。その場合、引き算の結果は条件コードに格納される。そして、この種類の式が正しく使えるのはこういう場合、すなわち、条件コードに格納される値としてだけである。

モード m は、x や y のモードには関係なく、条件コードの値のモードになる。(cc0) が使われるのなら、VOIDmode になる。それ以外の場合は、MODE_CC クラスの中のあるモードになる。良く使われるのは CCmode である。See Condition Code.

普通は、x と y は同じモードでなければならない。それ以外で compare が有効なのは、x のモードが、MODE_INT のクラスに属し、かつ、y が VOIDmode モードの const_int か const_double の場合のみである。x のモードによって、比較が行われるモードが決まるので、x のモードは VOIDmode であってはならない。

オペランドの一方が定数であるなら、それは第二オペランドに置くべきであり、そうすることによって比較のためのコードが適切に調整される。

compare で、VOIDmode の定数を二つ指定するのは無効である。というのは、どのモードで比較を実行すべきか知りようがないからである。比較は、コンパイル中に畳み込まれるか、先頭のオペランドがそのモードがわかっているレジスタにロードされるかしなければならない。 

(neg:m x)

x で表現される値の符号を反転した(0 から引いた)値を表現する。m のモードで演算が行われる。 

(mult:m x y)

x と y で表される値の符号付きの積を表現する。積は、モード m で行われる。
機種によっては、オペランドよりも大きな積を生成する乗算をサポートしている。その場合には、次のようにパターンを書くこと。

(mult:m (sign_extend:m x) (sign_extend:m y))

ここで、m は、x と y のモードよりも大きいモードである。x と y のモードは同じでなくても良い。

符号無しの、大きな積を生じる乗算の場合には、zero_extend を使って同じように書けば良い。 

(div:m x y)

マシンモード m で x を y で割った、符号付きの商を表す。m が浮動小数点モードなら、厳密な商を表す。そうでなければ、整数化した商を表す。

マシンによっては、オペランドと商の幅が全部同じではない場合の除算命令を持っていることがある。そういう命令を表現するには、以下のように、truncate と sign_extend を使う。

(truncate:m1 (div:m2 x (sign_extend:m2 y)))

(udiv:m x y)

div とほぼ同じだが、符号無しの除算を表す。 

(mod:m x y)

(umod:m x y)

div や udiv と似ているが、商の代わりに剰余を表す。 

(smin:m x y)

(smax:m x y)

x と y の小さいほう(sminの場合)または大きいほう(smax の場合)を表す。この場合、モード m の符号付き整数として解釈が行なわれる。 

(umin:m x y)

(umax:m x y)

smin や smax とほぼ同じだが、符号無しの整数として解釈が行なわれる。 

(not:m x)

x で表される値のビット毎の補数を表現する。この演算はモード m で行なわれる。m は、固定小数点モードでなければならない。 

(and:m x y)

x と y で表される値のビット毎の論理積を表現する。ビット毎の論理積はモード m で実行される。このモードは、固定少数点数のモードでなければならない。 

(ior:m x y)

x と y で表される値のビット毎の論理和を表現する。ビット毎の論理和はモード m で実行される。このモードは、固定少数点数のモードでなければならない。 

(xor:m x y)
x と y で表される値のビット毎の排他的論理和を表現する。ビット毎の排他的論理和はモード m で実行される。このモードは、固定少数点数のモードでなければならない。 

(ashift:m x c)

x を左に c 回算術シフトした結果を表現する。x のモードは m であり、固定少数点数のモードである。c は、固定小数点数モードか、モードが VOIDmode の定数である。c のモードがどちらになるかは、マシン記述中の左シフト命令のエントリに対して呼び出されるモードにより決定される。例えば、Vax では、c のモードは、m に関わらず、QImode である。 

(lshiftrt:m x c)

(ashiftrt:m x c)

右シフトである点を除いて、ashift と同じである。左シフトの場合と違って、この二つの演算は異なる物である。 

(rotate:m x c)

(rotatert:m x c)

同様に、左右のローテーションを表す。c が定数なら、rotate の方を使うこと。 

(abs:m x)

モード m で計算した、xの絶対値を表現する。 

(sqrt:m x)

モード m で計算した、x の平方根を表現する。ほとんどの場合、m は浮動小数点モードになる。 

(ffs:m x)

x の、 1 であるビットのうちの最下位のビットの位置に 1 を足したものを、モード m の整数として表現する。(x がゼロであれば、この値は0 になる。) x のモードは m でなくても良い。ターゲットの機種により、色々なモードの組合せが有効である。

##比較演算

比較演算子は、二つのオペランドについてある関係が成り立つかどうかを調べ、その関係が成り立つなら 0 でない値、成り立たないなら 0 を表す。0 でない値の方は、機種依存であり、 STORE_FLAG_VALUE (see Misc)で記述されるが、この値に等しくなる必要はない。比較演算のモードは、比較対象のデータのモードには関係ない。比較演算が、条件判定に使われる(例えば、if_then_else の第一オペランドとして使われる)場合は、モードは VOIDmode でなければならない。あるいは、比較演算の結果、変数に格納すべきなんらかのデータを生じるなら、モードは MODE_INT のクラスに入っていなければならない。データを生成する全ての比較演算は同じモードを使わなければならない。どのモードになるかは機種依存である。

比較演算の使われ方には二通りある。比較演算子を使って、条件コード (cc0) をゼロと比較することができる。例えば、(eq (cc0) (const_int 0)) のようにである。こういう構文では、条件コードを設定する先行命令の結果を実際に参照している。条件コードを設定する命令は、条件コードを使用する命令の直前になければならない。これらの命令の間に置いて良いのは、note insn だけである。

あるいは、比較演算は二つのデータオブジェクトを直接比較しても良い。比較のモードはオペランドにより決定される。どちらのオペランドもある共通のマシンモードに対して有効でなければならない。両方のオペランドが定数である比較は、モードを決めることができないので無効である。しかし、そのような比較は、定数畳み込みにより、RTL 中には決して存在しないはずである。

上の例だと、(cc0) が直前で (compare x y) に設定されているなら、比較演算は (eq x y) に等価である。普通は、ある特定のマシンでは、どちらか一方の形式のだけの比較がサポートされている。しかし、組合せパスは演算をマージして、特定の insn が含まれている文脈に存在するなら、このような eq 式を生成することを試みる。

不等比較は、符号付きと符号なしの二種類がある。このため、符号付きと符号なしの「大なり」に対応して、gt と gtu の異なる式コードがある。これらは、同じ整数値の組合せに対して異なる結果を生じることもある。例えば、1 は符号付きでは -1 より「大なり」であるが、符号なしでは「大なり」ではない。-1 は符号なしとして扱われると、実際には 0xffffffff となり、 1 より大きいからである。

符号付き比較はまた浮動小数点値にも使われる。浮動小数点比較は、オペランドのマシンモードにより区別される。

(eq:m x y)

x と y で表現される値が等しければ 1 で、等しくなければ 0 である。 

(ne:m x y)

x と y で表現される値が等しくなければ 1 で、等しければ 0 である。 

(gt:m x y)

x が y より大きければ 1 である。両者とも固定小数点であれば、符号付きで比較が行なわれる。 

(gtu:m x y)

符号無しで比較が行なわれ、そのため固定小数点数についてのみ使われるという点を除いて、gt と同じである。 

(lt:m x y)

(ltu:m x y)

gt や gtu と同様だが、「より小さい」かどうかを判定する。 

(ge:m x y)

(geu:m x y)

gt や gtu と同様だが、「以上」かどうかを判定する。 

(le:m x y)

(leu:m x y)

gt や gtu と同様だが、「以下」かどうかを判定する。 
(if_then_else cond then else)
これは、比較演算ではないが、ここで挙げておく。というのは、必ず比較演算と関連して使われるからである。正確に言うと、cond は比較式である。if_then_else 式は、cond により、then で表される値とelse で表される値のどちらかの選択肢を表す。
ほとんどの機種では、if_then_else 式は条件ジャンプを表す場合にのみ有効である。 

(cond [test1 value1 test2 value2 ...] default)

if_then_else と同様だが、もっと一般的である。test1、test2、... がそれぞれ順番に実行される。cond 式の結果は、最初に非 0 となったテストに対応する value となる。あるいは、非 0 となったテストがなければ、default になる。

この式は、現時点では命令パターンに対しては使用できない。insn の属性にたいしてのみ使用できる。See Insn Attributes.

##ビットフィールド

特別な式コードがあり、ビットフィールド命令を表現することができる。この型の式は、RTL 中で左辺値となる。代入式の左辺に置くことが可能で、その式で指定されたビットフィールドにある値を代入することを指示する。

(sign_extract:m loc size pos)

これは、loc(メモリかレジスタの参照)に含まれるか、そこで始まっている符号拡張されたビットフィールドへの参照を表す。このビットフィールドは幅が size ビットで、ビット位置 pos から始まっている。コンパイル時の選択により、BITS_BIG_ENDIAN が、メモリ単位のどちらの端から pos を数えるかを指定する。

loc がメモリ中に置かれているなら、そのモードは一バイト整数のモードでなければならない。loc がレジスタに置かれているなら、使うべきモードは、パターン insv または extv (see Standard Names) のオペランドとして指定されたものになり、通常は全語の整数モードである。何も指定がないときのデフォルトは全語の整数モードになる。

pos のモードはマシン固有であり、パターン insv またはextv でも指定される。

モード m は、loc がレジスタなら、それに使われるモードと同じである。 

(zero_extract:m loc size pos)

sign_extract と同様だが、符号なし、あるいはゼロ拡張されたビットフィールドを参照する。同じビット列が抽出されるが、符号拡張ではなくゼロで埋め尽くされる。

##変換

マシンモード間の変換は全て、明示的な変換演算で表す必要がある。例えば、あるバイトとある全語の和を表す式を、(plus:SI (reg:QI 34) (reg:SI 80)) と書くことはできない。なぜなら、plus という演算では、二つのオペランドは同じマシンモードを持つ必要があるからである。このため、バイトの大きさのオペランドを変換演算で以下のように包む必要がある。

(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))

変換演算は単なるプレースホルダーではない。というのは、指定された変換前のモードから変換後のモードへ変換する方法はひとつだけではないからである。変換演算のコードで、変換方法を指定するのである。

以下のどの変換演算でも、x は VOIDmode であってはならない。変換を行なうべきがモードが判らないからである。変換は、コンパイル時に行なうか、x をレジスタに保持するかのどちらかでなければならない。

(sign_extend:m x)

値 x をマシンモード m へ符号拡張した結果を表現する。m は固定小数点モードでなければならず、x は、m より幅の狭いモードの固定小数点値でなければならない。 

(zero_extend:m x)

値 x をマシンモード m へゼロ拡張した結果を表現する。m は固定小数点モードでなければならず、x は、m より幅の狭いモードの固定小数点値でなければならない。 

(float_extend:m x)

値 x をマシンモード m に拡張した結果を表現する。m は浮動小数点モードでなければならず、x は、m より幅の狭いモードの浮動小数点数値でなければならない。 

(truncate:m x)

値 x をマシンモード m に打切った結果を表現する。m は固定小数点モードでなければならず、x はm より幅の広いモードの固定少数点値でなければならない。 

(float_truncate:m x)

値 x をマシンモード m に打切った結果を表現する。m は浮動小数点モードでなければならず、x はm より幅の広いモードの浮動少数点値でなければならない。 

(float:m x)

固定小数点値 x を符号付きとみなし、浮動小数点モード m に変換した結果を表す。 

(unsigned_float:m x)

固定小数点値 x を符号無しとみなし、浮動小数点モード m に変換した結果を表す。 

(fix:m x)

m が固定小数点モードの場合、浮動小数点値 x をモード m の符号付き整数に変換した結果を表現する。丸めをどのように行なうかは規定されないので、C プログラムをコンパイルするときにこの演算が正しく使えるのは、オペランドが整数値を持つ時だけである。 

(unsigned_fix:m x)

浮動小数点値 x をモード m の符号なし整数に変換した結果を表現する。丸めをどのように行なうかは規定されない。 

(fix:m x)

m が浮動小数点モードの場合、浮動小数点値 x(モードm で有効) を整数に変換した結果を表現する。この結果は浮動小数点モード m で表現される。丸めは 0 に向かって行なわれる。

##宣言

宣言式コードは、算術演算を表すのではなく、オペランドの状態に関する表明を表す。

(strict_low_part (subreg:m (reg:n r) 0))
この式コードはただ一つの文脈でのみ使われる。set 式の目的オペランドとしてだけ使われる。さらに、この式のオペランドは矛盾のない subreg 式でなければならない。
strict_low_part があると、モード n では意味があるが、モード m の一部ではないようなレジスタの一部が、変更すべきでないことを示す。通常、m の幅がワードより狭いときは、このようなサブレジスタに代入を行なうと、そのレジスタの他の部分に予期しない影響を与える。

##副作用式

ここまで説明してきた式コードは値を表すものであり、動作を表すものではなかった。しかし機械命令というものは決して値を生み出すものではない。機械命令は、マシンの状態に副作用を与えるという点でのみ意味を持つ。特別な式コードを使って、副作用を表現する。

命令の本体は、必ず以下の副作用を表すコードの一つである。これまで説明してきた、値を表現するコードは、これらのオペランドとしてのみ現れるのである。

(set lval x)

x の値を lval で表される場所に格納する動作を表現する。lval は、その中に格納可能であるような場所を表す式である。すなわち、reg(あるいは subreg、または strict_low_part)、mem、pc、cc0 のどれかである。
lval が、reg、subreg、mem のどれかなら、マシンモードを持つ必要がある。その場合、x は、そのモードで有効でなければならない。

lval が、マシンモードがそのレジスタの全幅より小さいようなreg であれば、そのマシンモードにより指定されたレジスタの部分には指定された値が与えられ、レジスタのその他の部分は未定義値となる。同様に、lval が、レジスタのモードより狭いモードの subreg なら、レジスタのその他の部分がどのように変更されるかは不定である。

lval が、subreg の strict_low_part なら、subreg のマシンモードで指定されたレジスタの部分は、値 x が与えられ、その他の部分は変更されない。

lval が (cc0) なら、マシンモードがないので、x は compare 式か、任意のモードを持つ値で良い。後者の場合は、"test" 命令を表現する。(set (cc0) (reg:m n)) という式は、(set (cc0) (compare (reg:m n) (const_int 0))) という式に等価である。前者の式を使ったほうが、コンパイル中のメモリを節約できる。

lval が (pc) なら、それはジャンプ命令であり、x の取りうる値は非常に限られてくる。x は、label_ref 式とすることができる(無条件ジャンプ)。if_then_else (条件ジャンプ)とすることもでき、その場合、第二オペランドか第三オペランドのどちらかが (pc) (ジャンプしない場合に使われる)でなければならず、またもう一方は label_ref (ジャンプする場合に使われる)でなければならない。また、x は mem または (plus:SI (pc) y) でも良い。ここで、y は reg か mem である。この最後のパターンは分岐テーブル経由のジャンプを表現するのに使われる。

lval が (cc0) でも (pc) でもなければ、lval のモードは VOIDmode としてはならず、x のモードはlval のモードとして有効でなければならない。

lval は SET_DEST マクロで、x は SET_SRC マクロでアクセスするようにするのが良い。 

(return)

パターン中に単独の式として書くことで、現在の関数から戻ることを表す。ただし、VAX のように一命令で戻ることができるマシンに限られる。関数から戻るためには、複数の命令からなる「エピローグ」を実行する必要があるマシンでは、関数からの復帰は、エピローグの直前に置かれるラベルへジャンプすることで行なわれるので、return 式コードが使われることはない。
if_then_else 式の中に置いた場合は、呼び出し元に戻るための pc に置かれる値を表す。

(return) というパターンは、論理的には (set (pc) (return)) と等価であるが、後者の形式が使われることはない。 

(call function nargs)

関数呼び出しを表現する。function は mem 式であり、この式のアドレスは、呼び出される関数のアドレスである。nargs は二つの目的で使われる式である。あるマシンでは、スタックに積まれた引数のバイト数を表現する。あるいは、引数レジスタの数を表現する。
どのマシンも function が持たなければならない標準的なマシンモードを持っている。マシン記述では、FUNCTION_MODE というマクロを、その不可欠のモード名に展開されるように定義している。このモードの目的は、どの種類のアドレッシングが許されるかがアドレスの対象となるマシンモードに依存するマシンにおいて、どの種類のアドレッシングが許されているかを指定することである。 

(clobber x)

予期できない値を x に格納すること、または格納する可能性があることを表す。x は、reg 式か、scratch 式か、mem 式のどれかでなければならない。
これが使われるのは一つは、標準的な値を特定のハードレジスタに格納する文字列命令においてである。格納される値を記述する手間をかける必要はないが、文字列命令を越えてその値を保持しようとしないように、コンパイラにレジスタの値が変更されることを知らせるのが本質的な事である。

もし x が (mem:BLK (const_int 0)) なら、全メモリ位置が上書きされると見なされなければならないことを意味する。

マシン記述では、ある種類のハードレジスタを「呼びだし時破壊」("call-clobbered") として分類していることに注意。全ての関数の呼びだし命令は、デフォルトでこれらのレジスタを破壊すると仮定されているので、この事実を示すために clobber 式を使う必要はない。また、各関数呼び出しは、その関数が const と宣言されていない限り、任意のメモリ位置を変更する可能性があると仮定されている。

parallel の最後の組の式が、それぞれ reg かmatch_scratch 式 (see RTL Template)を引数とするclobber 式なら、組合せフェーズは、そうすることでパターンがマッチするようになるなら、適切な clobber 式を、構築されたばかりのinsn に追加する。

この機能は、例えば、乗算命令と加算命令は MQ レジスタを使わないが、アキュムレータへの加算命令が MQ レジスタを上書きするようなマシンで使うことができる。一個の組み合わされた命令(? combined instruction)は一時レジスタを必要とするが、一方、それを構成する命令は一時レジスタを必要としない場合も同様である。

あるレジスタに対する clobber 式が、他に副作用のある parallel の中に現れた場合は、レジスタ確保部が、そのレジスタがその insn の前後どちらにおいても占有されることがないことを保証する。しかし、選ばれた選択肢に対して制約 & が指定されていない限り、再ロードパスが入力の一つとして使われたレジスタを確保する場合がある(see Modifiers)。特定のハードレジスタ、または疑似レジスタ、あるいは scratch 式のどれかを上書きすることができる。後の二つの場合には、GNU CC は、その時点で一時的に使用可能なハードレジスタを確保する。

一時レジスタを必要とする命令については、疑似レジスタの代わりにscratch を使うべきである。そうしておくと、組合せフェーズが必要なときに clobber を追加することを許すからである。このためには (clobber (match_scratch ...)) と書けば良い。疑似レジスタを上書きするなら、他のどこにも現れていないものを使うこと。つまり、そのたびに新しいものを生成して使うこと。そうしないと、CSE のフェーズが混乱する。

parallel 中で疑似レジスタを上書きすることのもう一つの使い道がある。insn の入力オペランドの一つがやりその insn により上書きされる場合である。この場合、insn 中の clobber の中と、別のところとに同じ疑似レジスタを使うと期待どおりの結果が得られる。 

(use x)

x の値が使われるということを表す。プログラムのこの時点での x の値が必要であることを示す。たとえ、なぜ必要であるかがはっきりしていなくてもである。このため、GCC は、x に値を格納するという効果しか持たない命令が直前にあっても、その命令を削除しない。x は、reg 式でなければならない。
再ロードフェーズの間、パターンとして use がある insn は、reg_equal ノートを保持することが可能である。このような use insn は、再ロードフェーズが終了する前に削除される。

遅延分岐スケジューリングのフェーズの間は、x は insn でも良い。これは、x が以前にコード中のこの場所にあって、そのデータ依存関係を考慮する必要があるということを意味する。このような use insn は、遅延分岐スケジューリングのフェーズの終了前に削除される。

並列に実行される様々な副作用を表す。大カッコはベクトルを表す。parallel のオペランドは式を要素とする一個のベクトルである。x0、x1 等は個々の副作用を表す式である。これらの式のコードは、setや call、return、clobber、use のどれかである。

「並列に」という意味は、最初に個々の副作用で使われる全ての値が計算され、次に全ての副作用が実行されることを表す。

(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])

例えば、上の式はハードレジスタ 1 の値と、ハードレジスタ 1 により指定されるメモリ位置の値を交換するということを曖昧さなしに表している。(reg:SI 1) がメモリアドレスとして現れているところでは、どちらも、insn を実行する前のレジスタ 1 の値を参照している。

このため、parallel を使ったときに、ある一つの set の結果が次の set で使えると考えるのは間違いということになる。例えば、人は良く、条件が 0 なら分岐する命令を以下のように表そうとする。

(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref ...)
                        (pc)))])

しかし、この書き方は間違いである。何故なら、これだと分岐条件はこの命令の前の条件コードの値に依存しており、この命令により設定される新しい値を使っていないからである。

のぞき穴最適化は、最終フェーズのアセンブリコード出力と一緒に行なわれる。この最適化により、一個の parallel からなるパターンの insn を生成することができる。この場合、parallel の各要素は、結果となるアセンブラコードを出力するのに必要なオペランド--多くの場合、reg あるいは mem、定数式である。これは、他のどのコンパイル過程でも適切な形式の RTL ではないが、その後には、もはや実行すべき最適化過程が残っていないので、問題ないのである。ただし、マクロ NOTICE_UPDATE_CC をもし定義するなら、その定義では、なんらかののぞき穴最適化を定義するなら上記のような insn を取り扱わなければならない。 

(sequence [insns ...])

ある insn の列を表す。ベクトル中に現れる insns のそれぞれは、insn の連鎖に現れるのに適したものであるために、insn、jump_insn、call_insn、code_labe、barrier、note のどれかでなければならない。
sequence RTX は、RTL 生成の間は実際の insn には決して置かれることがない。この RTX は define_expand から生ずる insn の列を表しており、それは、insn が emit_insn に渡され、insn の連鎖に挿入されるまえに行なわれる。実際に挿入された時点で、個々のサブ insn が分離し、sequence が捨てられる。

遅延スロットスケジューリングが完了した後、ある insn とその遅延スロットに置かれている全ての insn は一まとめにされて、一個の sequence に収められる。遅延スロットを必要とする insn は、ベクトル中の先頭のinsn である。その後ろに続く insn は遅延スロットに置かれる。

遅延スロット中の insn には INSN_ANNULLED_BRANCH_P が設定され、遅延スロット中の insn の効果を条件により無効化するような分岐 insn を使うべきであることを指示する。

以下の式コードは副作用の代わりに、insn の本体として現れる。だが、厳密に言えばいつでも副作用を表すわけではない。

(asm_input s)

文字列 s で表されるアセンブラコードそのものを表す。 

(unspec [operands ...] index)

(unspec_volatile [operands ...] index)

operands についてのマシン固有の演算を表す。index で、複数のマシン固有演算の一つを選び出す。unspec_volatile を使って、揮発性の演算とトラップを起こす可能性のある演算を表す。その他の演算には unspec が使われる。
これらのコードは insn の pattern の内側、parallel の内側、式の内側に現れる可能性がある。 

(addr_vec:m [lr0 lr1 ...])

ジャンプ先アドレスのテーブルを表す。ベクトルの要素 lr0... 等は label_ref 式である。モード m で各アドレスにどれだけのメモリを与えるかを指定する。普通は m は Pmode になる。 

(addr_diff_vec:m base [lr0 lr1 ...] min max flags)

ジャンプ先アドレスを base からのオフセットで表したテーブルを表す。ベクトルの要素 lr0... 等は、label_ref 式であり、base も label_ref 式である。モード m で各アドレスの差分にどれだけのメモリを与えるかを指定する。min と max は分岐の近距離化により設定され、それぞれ最小と最大のアドレスを持つラベルを保持する。flags は、それを保持する insn に対する base、min、max と、base に対する min、max の相対的な位置を表す。詳細については rtl.def を参照のこと。

##アドレスの埋め込み副作用

メモリアドレスとして現れる、特別な副作用式コードが 6 つある。

(pre_dec:m x)

x を標準量だけデクリメントする副作用を表す。また、x がデクリンメントされた後の値も表す。x は reg か mem でなければならず、ほとんどのマシンでは reg しか許していない。m はそのマシンのポインタ用のマシンモードでなければならない。x のデクリメントされる量は、アドレスとして振る舞う式のメモリ参照を含むマシンモードの長さをバイト数で表したものである。以下に使い方の例を示す。
(mem:DF (pre_dec:SI (reg:SI 39)))
これは、疑似レジスタ 39 を DFmode の値の長さだけデクリメントし、その結果を DFmode の値のアドレスとして使う事を示している。 

(pre_inc:m x)

同様だが、デクリンメントではなく x のインクリメントを指定する。 

(post_dec:m x)

pre_dec と同じ副作用を表すが、異なる値になる。これにより表される値は、デクリメントされる前の x の値である。 

(post_inc:m x)

同様だが、デクリンメントではなく x のインクリメントを指定する。 
(post_modify:m x y)
x を y に設定する副作用を表現し、かつ x が修正を受ける前のx を表現する。x は reg か mem でなければならない。だが、多くの機種では reg しか許していない。m は使われている機種でのポインタのマシンモードでなければならない。x がデクリメントされる量は、この式がアドレスの役割をするメモリ参照のマシンモードの長さをバイトで表したものである。これは、現在実装されていないことに注意。
式 y は次の三つの形式のうちの一つでなければならない。

(plus:m x z) (minus:m x z) (plus:m x i)

ここで z はインデックス・レジスタで、i は定数である。
使い方の例を示す。

(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42) (reg:SI 48))))

これは、疑似レジスタ 42 を、疑似レジスタ 48 の内容をそれに加算する形で変更することを示している。ただし、42 が指し示していた内容が使われた後で行われる。 

(pre_modify:m x expr)

同様に、x の内容を使う前に副作用が発生する。

これらの組み込み副作用式は注意して使わなければならない。命令パターンでは使わない。コンパイラの flow パスに至るまでは、スタックへのプッシュを表現するのに使われるだけである。flow パスは、レジスタが一個の命令でインクリメントまたはデクリメントされ、かつ、その直前または直後でアドレスとして使われている場合を探す。そのような場合は、プリ／ポスト・インクリメント／デクリメントを使うように変換する。

これらの式のオペランドとして使われているレジスタが、ある insn の別のアドレス中で使われていると、そのレジスタの元の値が使われる。レジスタをアドレス以外に使うことは、同一 insn 内で埋め込み副作用式として使うのは許されない。なぜなら、そういう式は、異なる機種では異なる振る舞いをし、そのため、取扱いが曖昧になるので許されない。

組み込み副作用式で表現可能な命令は、また、アドレスレジスタがどのように変更されるかを記述する追加の set を含む parallel を使って表現することもできる。だが、これは行なわれない。何故ならこのような操作をともかく許す機種では、典型的には、メモリアドレスが要求される場所ならどこでもそういう操作を許すからである。これらの操作を付加的な並列格納として記述すると、マシン記述のエントリ数が二倍必要になる。

##式としてのアセンブラ命令

RTX コード asm_operands は、ユーザが指定したアセンブラ命令により生成される値を表現する。引数付きの asm 文を表現するのに使われる。出力オペランドが一つの asm 文は以下のようになる。

asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));

この asm 文は、値が outputvar に格納されることを表現する、一個の asm_operands RTX を使って以下のように表現される。

(set rtx-for-outputvar
     (asm_operands "foo %1,%2,%0" "a" 0
                   [rtx-for-addition-result rtx-for-*z]
                   [(asm_input:m1 "g")
                    (asm_input:m2 "di")]))
                    
ここで、asm_operands RTX のオペランドは、アセンブラテンプレート文字列、出力オペランドについての制限子、指定されたオペランドの中での出力オペランドの番号、入力オペランド RTX のベクトル、それに、入力オペランドのモードと制約のベクトルからなる。モード m1 は、和 x+y のモードであり、m2 は、*z のモードである。

asm 文に複数の出力値がある場合は、その insn は parallel の内側に幾つかの set RTX を持つ。setはそれぞれ asm_operands を含んでいる。これらの set は全て、同じアセンブラテンプレートとベクトルを共有しているが、それぞれ出力オペランドに応じた制約を保持している。

#Insns

関数のコードの RTL 表現は、insn と呼ばれるオブジェクトの二重線形リストである。insn は他に用途のない特別なコードを持つ式である。insn の一部は実際の命令である。switch 文のための分岐テーブルを表現するものもある。その他、分岐先ラベルや様々な宣言的な情報を表現するものもある。

各 insn は、それ自身固有のデータを持つほか、現在の関数内の他の insn と区別するための一意的な識別番号(遅延分岐スケジューリングの後で、同じ識別番号を持つ insn のコピーが一つの関数内で複数存在することがあるが、これらのコピーは全く同じであり、sequence の中にしか現れない)、それに直前と直後の insn を指すポインタを持っている。この三つのフィールドはどの insn においても、insn の式コードによらずに、同じ位置にある。この三つのフィールドは XEXP と XINT を使ってアクセスしても良いが、以下のような特別なマクロが三つあり、いつでも使うことができる。

INSN_UID (i)

insn i に一意的な識別番号をアクセスする。 

PREV_INSN (i)

i の直前の insn へのポインタをアクセスする。i が先頭の insn なら、ヌルポインタになる。 

NEXT_INSN (i)

i の直後の insn へのポインタをアクセスする。i が末尾の insn なら、ヌルポインタになる。

insn のリストの先頭の insn は、get_insns で得ることができる。末尾の insn は、get_last_insn を使って得ることができる。先頭の insn から末尾の insn の範囲内では、NEXT_INSN とPREV_INSN のポインタは常に対応している必要がある。つまり、insn が先頭の insn でなければ、

NEXT_INSN (PREV_INSN (insn)) == insn

上の式は常に真であり、また、insn が末尾の insn でなければ、

PREV_INSN (NEXT_INSN (insn)) == insn
は常に真である。

遅延分岐スケジューリング後、リスト中の insn の幾つかはsequence 式である可能性がある。sequence は、insn のベクトルを含んでいる。このベクトルの中の insn の NEXT_INSN の値は、最後の insn を除いて、ベクトルの中での次の insn を指す。ベクトルの最後の insn の NEXT_INSN の値は、その insn を含むsequence に対する NEXT_INSN の値と同じである。PREV_INSN についても同様である。

つまり、先に述べた恒等式は、sequence の中の insn については必ずしも真ではないのである。特に、insn が sequence の先頭の insn なら、NEXT_INSN (PREV_INSN (insn)) は、sequence 式を含む insn になり、同様に、PREV_INSN (NEXT_INSN (insn)) は、sequence 式の最後の insn になる。これらの式を使って sequence 式を含む insn を取り出すことができる。

どの insn も以下のような6個の式コードの一つを持っている。

insn

式コード insn は、ジャンプも関数呼び出しも行わない命令に対して使う。sequence 式は、その中の insn の一つがジャンプや関数呼び出しを行なっても、常にコード が insn である insn に含まれる。
コードが insn である insn は、上記の三つの必須フィールドの他に、四つのフィールドを持つ。この四つのフィールドについては後出の表で説明する。 

jump_insn

式コード jump_insn はジャンプを行なう可能性のある命令(あるいは、もっと一般的に言うと、label_ref 式を含む命令)で使われる。現在の関数から復帰する命令があるなら、やはり jump_insn になる。
jump_insn の insn には、コード insn の insn と同じ追加のフィールドがあり、同じようにしてアクセスされ、さらにジャンプ最適化が完了したときに一度だけ定義される JUMP_LABLE というフィールドも保持している。

単純な、条件ジャンプと無条件ジャンプの場合は、このフィールドはcode_label を保持しており、ここに insn が(条件分岐の場合もある) 分岐していく。もっと複雑なジャンプでは、JUMP_LABEL が insn が参照しているラベルの一つを記録している。その他のラベルを探すには insn の本体全体を走査するしかない。

関数から復帰する insn はジャンプ insn として数えるが、何もラベルを参照していないので、JUMP_LABLE フィールドは 0 になる。 

call_insn

式コード call_insn は、関数呼びだしを行なう可能性のある命令に対して使われる。これらの命令を区別するのは重要である。なぜなら、特定のレジスタやメモリ位置の値を、予測できない形で変えてしまう可能性があるからである。
call_insn insn は insn insn と同じ追加のフィールドを持ち、同じ方法で参照する。さらに付け加えて、CALL_INSN_FUNCTION_USAGE というフィールドを持っており、このフィールドは一つのリスト(expr_list 式の連鎖である)を保持している。このリストは、被呼びだし関数により使われたか、あるいは上書きされたハードレジスタを示す use 式とclobber 式を含んでいる。このリストの clobber に指定されたレジスタは、call_insn の実行の後、変更される。一方、call_insn の本体の clobber で指定されたレジスタは、insn の実行が完了する前に上書きされる。このリストの clobber 式は CALL_USED_REGISTERS で指定されたレジスタを増やす。(see Register Basics)。 

code_label

code_labe insn は、分岐命令の分岐先となりうるラベルを表す。標準の三つのフィールドに加えて二つの特別なフィールドがある。CODE_LABEL_NUMBER を使って ラベル番号、すなわち、コンパイル単位(現在の関数の中だけではない)の全てのラベルの中から、このラベルを一意的に特定する番号を保持する。最終的には、このラベルはアセンブラ出力ではアセンブララベルとして表現される。これは、通常は Ln という形式になる。ここで n はラベル番号である。
code_label が RTL 式に現れるときは、普通はそのラベルのアドレスを表す label_ref の中に、番号として現れる。

フィールド LABEL_NUSES は、ジャンプ最適化フェーズが完了した時に一度だけ定義され、現在の関数の中でこのラベルが参照された回数を保持する。 

barrier

バリアは、命令ストリームの、制御の流れが越えることのできない地点に置かれる。無条件ジャンプ命令の後ろに置かれ、ジャンプが無条件であることを知らせる。また、volatile 関数呼び出しの後ろにも置かれる。これらの関数が戻る事はない(例えば exit である)。これらは、三つの標準フィールド以外の情報は持っていない。 

note

note insn は、付加的な、デバッグ情報および宣言に関する情報を表すのに使われる。この insn には、非標準のフィールドが二つある。一つは整数で、マクロ NOTE_LINE_NUMBER で参照され、もう一つは文字列で、マクロ NOTE_SOURCE_FILE で参照される。

NOTE_LINE_NUMBER が正なら、そのノートはソース行の位置を表し、NOTE_SOURCE_FILE は、その行が含まれるソースファイル名を表す。このノートは、アセンブラ出力に行番号データを生成するの使われる。

NOTE_LINE_NUMBER が正でないなら、実際の行番号ではなくては、以下の値の一つを持つコードである。この場合、NOTE_SOURCE_FILE はヌルポインタでなければならない。

NOTE_INSN_DELETED

このノートは完全に無視できる。幾つかのフェーズでは、insn を削除するのを、それらの insn をこの種類のノートに変えてしまうことで行なっている。 

NOTE_INSN_BLOCK_BEG

NOTE_INSN_BLOCK_END

この型のノートは、変数名のスコープレベルの開始位置と終了位置を表す。デバッグ情報の出力を制御する。 

NOTE_INSN_EH_REGION_BEG

NOTE_INSN_EH_REGION_END

この型のノートは、例外処理のスコープレベルの開始位置と終了位置を表す。NOTE_BLOCK_NUBMER で、どの CODE_LABEL が指定された領域に付属するかを特定する。 

NOTE_INSN_LOOP_BEG

NOTE_INSN_LOOP_END

この型のノートは、while または for ループの開始位置と終了位置を表す。これらにより、ループ最適化部が素早くループを見つけられるようになる。 

NOTE_INSN_LOOP_CONT

ループの中の、continue 文の飛び先位置に現れる。 

NOTE_INSN_LOOP_VTOP

このノートは、終了テストが複製されるようなループにおいて、終了テストが始まる位置を示す。この位置は、ループ不変量を考えるときのもう一つの仮想的なループの開始位置となる。 
NOTE_INSN_FUNCTION_END
関数本体の終り近く、(一個の命令では関数から戻れないマシンでは) return 文の飛び先ラベルの直前に現れるノートである。 

NOTE_INSN_SETJMP

setjmp や関係する関数の呼び出し毎に、その直後に現れる。
これらのコードは、デバッギングダンプにはシンボルで表示される。

insn のマシンモードは普通は VOIDmode だが、フェーズによってはモードを色々な目的で使用する。

共通部分式削除パスでは、処理済みのブロックの先頭の insn の場合、その insn のモードを QImode に設定する。

二回目の Haifa スケジューリングパスでは、複数命令の同時発行が可能なターゲットに対しては、insn が同時に発行される命令のグループの始まりの命令であると思われる場合は、その insn のモードを TImode に設定する。つまり、その命令は直前の命令と同時に発行できないものである。以降のパス、特に機種依存の命令並べ替えではこれはに頼っている。

以下は、insn、jump_insn、call_insn insn の追加フィールドの表である。

PATTERN (i)

この insn により発生する副作用を表す式。これは次のコードのどれか一つでなければならない。set、 call、 use、clobber、 return、 asm_input、 asm_output、addr_vec、 addr_diff_vec、 trap_if、 unspec、unspec_volatile、 parallel、sequence。もし parallel なら、parallel の各要素もこれらのコードでなければならない。ただし、parallel 式はネストできないこと、addr_vec と addr_diff_vec は parallel 式の内側では許されないという例外がある。 

INSN_CODE (i)

マシン記述中のどのパターンがこの insn にマッチするかを特定する整数である。照合がまだ行なわれていないなら -1 を返す。
use、clobber、asm_input、addr_vec、addr_diff_vec のどれか一個を使った式からなるパターンを持つ insn については、照合は行なわれず、このフィールドは -1 のまま変わらない。

asm 文から生じる insn の場合も照合は行なわれない。これらの insn は少なくとも一個の asm_operands 式を含む。このような insn に対して、関数 asm_noperands は非負の値を返す。

デバッグ出力では、このフィールドは数字の後に記号名表現が出力される。この記号名表現は、md ファイル中のパターンの位置を、名前付きパターンからの小さな正または負のオフセットとして示す。 

LOG_LINKS (i)

基本ブロック内の命令間の依存関係についての情報を与えるリスト(insn_list 式の連鎖)。ジャンプやラベルは、関係のある insn の間には入らない。 

REG_NOTES (i)

insn について種々雑多な情報を与えるリスト(expr_list 式とinsn_list 式の連鎖)。その insn で使われているレジスタに関係する情報であることが多い。
insn の LOG_LINKS フィールドは、insn_list 式の連鎖である。それぞれの insn_list 式はオペランドを二つ取る。一番目はある insn であり、二番目は別の insn_list 式(連鎖の次のもの) である。連鎖の最後の insn_list では、二番目のオペランドはヌルポインタとなる。連鎖について重要なことは、どの insn が(insn_list 式の一番目のオペランドとして)その中に現れるかということである。順序は重要ではない。

このリストは最初、フロー解析パスにより設定される。それまではヌルポインタになっている。フロー解析パスは、命令組合せで使用可能なデータ依存関係についてのリンクを追加するだけである。フロー解析パスは、insn 毎に、この insn で始めて使われる値をレジスタに格納する insn へのリンクを追加する。命令スケジューリングパスは、余分のリンクを追加して、あらゆる依存関係が表現されるようにする。リンクは、データ依存関係、逆依存関係、出力依存関係を表す。リンクのマシンモードがこの三つの型を区別する。逆依存関係のモードは REG_DEP_ANTI であり、出力依存関係のモードは REG_DEP_OUTPUT であり、データ依存関係のモードは VOIDmode である。

insn の REG_NOTES フィールドは、LOG_LINKS と同様の一個の連鎖であるが、insn_list 式に加えて expr_list 式も含んでいる。色々な種類のレジスタノートがあり、それらはマシンモードにより区別され、あるレジスタノート中では、実際に enum reg_note であると理解される。このノートの第一オペランド op は、ノートの種類によって意味の異なるデータである。

マクロ REG_NOTE_KIND (x) は、レジスタノートの種類を返す。これと対をなすマクロ PUT_REG_NOTE_KIND(x, newkind) は、x のレジスタノートのタイプを newkind に設定する。

レジスタノートには三つのクラスがある。何か insn への入力に関するもの、何か insn の出力に関するもの、それに、二つの insn の間のリンケージを作るものである。また、LOG_LINKS でしか使われない値が一セットある。

以下のレジスタノートは、insn への入力についての注釈である。

REG_DEAD

op の中の値がこの insn で死ぬ。つまり、この insn の直後でこの値を書き換えても、プログラムの以後の動作には影響を与えない。
これは、必ずしも、レジスタ op がこの insn 以後意味のある値を持たないということを意味しない。この insn の出力にもなることがあるからである。しかし、その場合、REG_DEAD ノートは冗長であり、普通は再ロードパス迄は存在しない。だが、このことを前提としているコードはない。 

REG_INC

レジスタ op は、この insn 内に埋め込まれた副作用によりインクリメント(あるいは、デクリメント。このレベルでは違いはない) される。すなわち、これは post_inc 式、または pre_inc式、post_dec 式、pre_dec 式に現れる。 

REG_NONNEG

この insn に到達したとき、レジスタ op は非負の値を持つことが知られている。これを使って、例えば m68k の dbra のような、デクリメントして 0 でない間は分岐する(decrement and branch until zero) 命令がマッチすることが可能になる。
REG_NONNEG ノートが insn に付加されるのは、マシン記述に decrement_and_branch_until_zero というパターンがある場合のみである。 

REG_NO_CONFLICT

この insn は、たとえ衝突を引き起こすように見えても、op とこの insn により設定されるアイテムとの間の衝突を引き起こさない。言い換えると、そうなっていないと代入先レジスタと op が同じレジスタに割り当てられる場合でも、この insn はその割当を妨げない。

このノートがある insn は、通常、あるブロックの一部である。このブロックは複数ワードの疑似レジスタを指定する一個の clobber insn で始まり、それぞれが一ワードの値を設定し、REG_NO_CONFLICT が付随している insn のグループが一つ、最後に、計算される式を与えるREG_EQUAL ノートをつけて、出力をそれ自身にコピーする insn が来る。このブロックは、先頭と末尾の insn について、それぞれ REG_LIBCALL ノートと REG_RETVAL ノートで包み込まれている。 

REG_LABEL

この insn は op、code_label を使うが、jump_insn ではない。このノートにより、op が実際に使われることをジャンプ最適化に対して知らせる。
以下のノートは、insn の出力の属性を記述する。

REG_EQUIV

REG_EQUAL

このノートは、一個のレジスタだけを設定する insn についてのみ有効であり、そのレジスタが実行時には op に等しいことを示す。これが等しくなる範囲は、二つのノートのタイプで異なる。この insn が明示的にそのレジスタにコピーする値は op とは違って見えるかもしれないが、実行時には等しくなる。一個の set の出力が strict_low_part 式なら、このノートは subreg 式の SUBREG_REG に含まれているレジスタを参照している。

REG_EQUIV の場合は、レジスタは関数全体を通して op に等価であり、全て op で正当に置き換えることができる。(ここで「正当に」はプログラムのデータ流を指す。単純な置き換えは幾つかの insn を不正にする。) 例えば、ある定数が、他の値が決して代入されることのない、あるレジスタにロードされるとき、この種類のノートが使われる。

ある仮引数が関数の入り口点で疑似レジスタにコピーされるとき、この種類のノートが仮引数が渡されたスタックスロットに等価なレジスタを記録する。この場合、レジスタは他の insn により設定されることもあるが、その関数内でそのレジスタをスタックスロットに置き換えることはなお有効である。

REG_EQUIV は、仮引数を格納可能なスタックスロットがある場合、ある関数の入り口でレジスタ仮引数を疑似レジスタにコピーする命令で使われる。他の insn がその疑似レジスタを設定する可能性もあるが、コンパイラにとっては、関数全体で疑似レジスタをそのスタックスロットに置き換えるのは正当である。ただし、コンパイラは、そのスタックスロットが、最初のコピー命令での同じように置き換えを行なうことで適切に初期化されていることを保証されている場合である。これは、呼び出し規約でレジスタ仮引数についてスタックスペースを割り当てるようになっている機種で使われる。Stack Arguments の REG_PARM_STACK_SPACE を参照のこと。

REG_EQUAL の場合は、この insn により設定されるレジスタは、この insn の最後では実行時に op に等価になるが、関数内の他の場所では必ずしも等価ではない。この場合、op は算術式であることが多い。例えば、ライブラリ呼び出しのような insn 列が、ある算術演算を実行するのに使われるとき、この種類のノートが最終的な値を生成したりコピーする insn に付随する。

これらの二つのノートは、コンパイラのパス群により異なる方法で使われる。REG_EQUAL は、レジスタ割当に先立つパス(例えば、共通部分式削除とループ最適化)により使われ、その値をどう考えれば良いかをそのパスに知らせる。REG_EQUIV ノートは、レジスタ割当により使われ、利用可能なレジスタが足りなければ、レジスタの代わりに使われる代入式(定数か、スタック上の仮引数の位置を表す mem 式) が利用可能であることを示す。

仮引数のスタックのホームとそのライフタイムを通じてメモリ位置に等かな疑似レジスタを除いて、全ての等価なものは、付随する REG_EQUAL ノートにより最初に示される。ここで、仮引数のスタックホームは、REG_EQUIV ノートにより指示され、最適化の最初の方のパスでは役に立たない。また、メモリ位置に等価な疑似レジスタは、コンパイルの後の段階になるまで検出されない。op が定数であり、その insn がその代入先レジスタの組を一つしか表現しないのであれば、レジスタ割当の初期の段階で、REG_EQUAL ノートは REG_EQUIV ノートに変えられる。

こうして、レジスタ割当より前のコンパイラのパスでは、REG_EQUAL ノートだけを検査する必要があり、レジスタ割当の後のパスではREG_EQUIV ノートだけを検査すれば良い。 

REG_UNUSED

この insn により設定されるレジスタ op は、次の insn では使われない。REG_DEAD ノートとの違いは、REG_DEAD の方は、入力中の値が後で使われることがないことを示す点にある。この二つのノートは独立であり、同じレジスタに対して両方とも存在してもかまわない。 

REG_WAS_0

この insn の一個の出力は、この insn の前にゼロを含んでいた。op が、ゼロに設定した insn である。このノートが存在し、かつ op が削除されていたり、note に変換されたりしていなければ、このノートを信頼することができる。このノートが存在しない場合は、何も意味しない。
以下のノートは、insn 間のリンケージを記述する。これらは、対で現れる。一個の insn には、ノートの対があり、それらは二番目の insn を指す。二番目の insn には、最初のinsn を指す逆のノートがある。

REG_RETVAL

この insn は、複数の insn から成る列(例えば、ライブラリ呼び出し)の値をコピーする。op は、列の先頭の insn である(ライブラリ呼び出しの場合は、ライブラリ呼び出しの引数を設定するように生成された先頭の insn である)。
ループ最適化はこのノートを使って、コードの移動の目的のために、このような列を一個の演算として取り扱う。また、フロー解析ではこのノートを使って、このような列で結果が死んでいるものを削除する。

通常、REG_EQUAL ノートもこの insn に付属し、この列により計算される式を提供する。

これらのノートは再ロード後に削除される。もはや不正確だったり役に立たなかったりするからである。 

REG_LIBCALL

これは、REG_RETVAL の逆である。これは複数 insn の列の先頭の insn に置かれ、最後の insn を指す。
これらのノートは再ロード後に削除される。もはや不正確だったり役に立たなかったりするからである。 

REG_CC_SETTER

REG_CC_USER

cc0 を使う機種では、cc0 を設定したり使ったりするinsn はお互いに近くにある。だが、遅延分岐スロットを埋める処理が行なわれると、もはや近くにあるとは言えなくなる可能性がある。その場合、REG_CC_USER ノートが、cc0 を設定する insn に置かれて、cc0 を使う insn を指し、REG_CC_SETTER ノートがcc0 を使う insn に置かれて、cc0 を設定する insn を指すようになる。

以下の値は、LOG_LINKS フィールドでのみ使われ、各リンクが表現する依存関係の型を指し示す。データ依存関係(書き込み後の読み込み依存関係, read after write dependence) を指し示すリンクはどのコードも使わず、単にモードが VOIDmode であり、何の説明文もなく出力される。

REG_DEP_ANTI

これは逆依存関係(WAR、読み込み後の書き込み依存) を示す。 

REG_DEP_OUTPUT

これは出力依存関係(WAW、書き込み後の書き込み依存)を示す。
これらのノートは gcov によるプロファイルデータから収集した情報を記述する。insn の REG_NOTES フィールドに expr_list として格納される。

REG_EXEC_COUNT

プロファイルデータに基づく、基本ブロックの実行回数を示す。このノートは、基本ブロックの先頭の insn に付加される。 

REG_BR_PROB

プロファイルデータに基づく、ある分岐 insn の、分岐が行なわれた回数と行なわれなかった回数の比を示す。0 と REG_BR_PROB_BASE の間の値として格納される。値が大きくなると、分岐が成立する確率がより高くなることを示す。 

REG_BR_PRED

このノートは、遅延分岐スケジューリングが起きた後のジャンプ insn に現れる。これらは、ジャンプの方向と可能性を示す。フォーマットは、ATTR_FLAG_* 値のビットマスクである。 

REG_FRAME_RELATED_EXPR

これは、RTX_FRAME_RELATED_P insn で使われる。この insn では、付属した式が、実際の insn パターンの代わりに使われる。これは、パターンが複雑か間違っている場合に行われる。
便宜上、insn_list や expr_list 中のマシンモードは、デバッグダンプでは、これらのシンボリックコードで出力される。

式コード insn_list と expr_list の唯一の相違点は、insn_list の先頭のオペランドは insn であると仮定され、デバッグダンプ中では insn の一意的な ID として出力されること、expr_list の先頭のオペランドは式として通常の方法で出力される点にある。

##関数呼び出し insn の RTL 表現
サブルーチンを呼び出す insn は、RTL 式コードが call_insn になる。サブルーチン呼び出し insn は特別な規則に従う必要があり、本体部分で特別な RTL 式コード call を使わなければならない。

call 式は、以下のようにオペランドを二つ取る。

(call (mem:fm addr) nbytes)
ここで、nbytes は、サブルーチンに渡される引数データのバイト数を表すオペランドである。fm はマシンモードであり、addr はサブルーチンのアドレスを表す。fm は、マシン記述の FUNCTION_MODE マクロの定義と同じでなければならない。

値を返さないサブルーチンについては、上に示した call 式そのものがinsn の全体になる。ただし、use 式か clobber 式をその他に含んでいる必要がある。

戻り値があり、そのモードが BLKmode でないサブルーチンについては、戻り値はハードレジスタに置かれる。このレジスタの番号が r なら、call insn の本体は以下のようになる。

(set (reg:m r)
     (call (mem:fm addr) nbytes))

この RTL 式は、この insn で、適切なレジスタに有効な値が置かれることを(最適化パスに対して)はっきりさせる。

サブルーチンが BLKmode の値を返すなら、その値を格納すべき位置のアドレスをサブルーチンに渡すという処理が行なわれる。このため、call insn 自身はどんな値も返さないので、値を返さない呼び出しと同じ形式の RTL になる。

マシンによっては、call 命令自身が幾つかのレジスタを、例えば戻り先アドレスを保持するために、破壊する。そういうマシンでの call_insn insn の本体は、call 式と clobber 式の両方を持つ、一個の parallel とすべきである。この clobber 式は、どのレジスタが破壊されるかを示す。同様に、call 命令が、スタックポインタ以外に、RTL で明示的に指定されていないレジスタを必要とするときは、use 副式がそのレジスタについて言及すべきである。

呼び出される関数は、コンフィギュレーションマクロ CALL_USED_REGISTERS (see Register Basics)に列挙されている全てのレジスタを修正し、const 関数とライブラリ呼びだしを例外として、全メモリを修正すると仮定される。

単に use 式を含む insn は、どのレジスタが関数への入力を保持しているかを示す call_insn の直前に位置する。同様に、CALL_USED_REGISTERS で指定されている以外のレジスタが呼び出された関数により上書きされるなら、単独の clobber を含む insn は、それがどのレジスタかを示すために、その呼び出しの直後に置かれる。

###構造の共有の前提
GNU CC は、ある種類の RTL 式は一意的であることを仮定している。すなわち、同じ値を表す二つの異なるオブジェクトは存在しないと仮定しているのである。一方、それとは逆の、ある種類の RTL 式オブジェクトは、それを含む構造の中では 2 回以上現れることはないという仮定をしている場合もある。

これらの仮定は一個の関数に関するものである。グローバル変数や外部関数を記述する RTL オブジェクト、それに小さな整数定数のような2,3の基本的なオブジェクトを除いて、二つの関数に共通の RTL オブジェクトは存在しない。

* 各疑似レジスタは、それを表現する reg オブジェクトは一個しか持たず、そのため、マシンモードも一個しかない。
* 記号名ラベルはどれも、それを参照する symbol_ref オブジェクトは一個しかない。
* 値が 0、1、-1 の const_int 式はそれぞれ一個だけである。それ以外の幾つかの整数値も一意的に格納される。
* pc 式は一個しかない。
* cc0 式は一個しかない。
* それぞれの浮動小数点モードで、値 0 の const_double 式はそれぞれ一個しかない。値が 1 と 2 についても同様である。
* label_ref や scratch は、RTL 構造体の中で二箇所以上は現れない。言い換えると、関数の中の全 insn をツリーウォークしたときに、label_ref や scratch が見つかるたびに、すでに見た他の全てとは違ったものであると仮定しても良い。
* 各静的変数やスタックスロットについては、普通はただ一個の mem オブジェクトが作られる。このため、これらのオブジェクトはそれが現れる全ての場所で共用されることが多い。しかし、これらの変数に対して、等価であるが別の独立したオブジェクトが作られることがたまにある。
* 一個の asm 文に複数の出力オペランドがあると、出力オペランド毎に別々の asm_operands 式が作られる。しかし、これらの式は全て、入力オペランドの列を含むベクトルを共有する。この共有は後で、二つの asm_operands 式が同じ文に由来するものかどうかを調べるのに使われる。このため、全ての最適化で、ベクトルを全部コピーした場合には注意深く共有を維持しなくてはならない。
* 上で説明したものを除いて、RTL 構造体に RTL オブジェクトが二箇所以上に現れることはない。コンパイラのパスの多くが、このことに依存しており、他の insn に不要な副作用を与えることなく RTL オブジェクトを直接修正可能であるということを仮定している。
* 最初の RTL 生成の間は、共有される構造体が自由に導入される。ある関数についての 全 RTL 生成が完了した後で、全ての共有される構造体が emit-rtl.c の unshare_all_rtl 関数によりコピーされる。その後で上記のルールが成り立つことが保証される。
* 組合せパスの間、ある insn 中の共有構造体が一時的に存在できる。しかし、共有構造体は、組合せパスがその insn についての処理を終了する前に、コピーされる。これは copy_rtx_if_shared を呼び出すことにより行なわれる。この関数は unshare_all_rtl のサブルーチンである。

##RTL の読み込み

ファイルから RTL オブジェクトを読み込むには、read_rtx 関数を使う。引数は、標準入力ストリーム一つであり、一個の RTL オブジェクトを返す。

ファイルから RTL を読む処理は非常に遅い。現時点ではこれは問題ではない。RTL の読み込みは、コンパイラを構築するときにのみ行われるからである。

RTL をテキストとしてファイルにセーブして、GNU CC の言語フロントエンドとその他の部分とのインターフェースとして使おうと考える人が良くいるが、これは実現不可能である。

GNU CC は、RTL を内部表現として使うようにしか設計されていない。ある与えられたプログラムに対する正しい RTL は、特定のターゲットマシンに著しく依存する。しかも、RTL は、そのプログラムについての情報を全部は含んでいないのである。

GNU CC と新しい言語フロントエンドのインターフェースを取る正しい方法は、「tree」データ構造を使う事である。このデータ構造について書いたマニュアルはないが、tree.h と tree.def で説明されている。

#機械記述
マシン記述は二つの部分からなる。機械命令のパターンを記述するファイル(.md ファイル) と C のマクロ定義を記述するヘッダファイルである。

あるターゲットマシン向けの .md ファイルは、そのマシンがサポートしている各機械命令(あるいは、少なくとも、GCC が知っていたほうが良い機械命令) のパターンを記述する。このファイルにはコメントを書くことができる。コメントはセミコロンから始まり行末までとなる。ただし、セミコロンが引用符つき文字列中にある場合を除く。

C のヘッダファイルについては、次章を見ていただきたい。

* Patterns: 命令パターンの書き方
* Example: define_insn の例
* RTL Template: RTL テンプレート
* Output Template: アセンブラコードの出力方法を指定する出力テンプレート
* Output Statement: アセンブラコードの出力を行なう C のコード
* Constraints: オペランド制約
* Standard Names: コード生成で使われるパターン名
* Pattern Ordering: パターンの順序が意味を持つ時
* Dependent Patterns: 一つのパターンが別のパターンを必要とするとき
* Jump Patterns: ジャンプ命令のパターンに関する特別な注意
* Insn Canonicalizations: 命令の正規化
* Peephole Definitions: 機種固有のピープホール最適化の定義方法
* Expander Definitions: 標準の演算向けの各種 RTL  insn 列の生成
* Insn Splitting: 複数命令への分割
* Insn Attributes: 生成された insn の属性値を指定する

##命令パターンの全て

各命令パターンには、後で埋められる部分を持つ不完全な RTL 式と、各部分がどのように埋められるかを限定するオペランド制約、それに、出力パターンまたはアセンブラ出力を生成する C コードが含まれており、全て define_insn 式中に記述される。

define_insn は一つの RTL 式で、四つか五つのオペランドを持つ。それぞれのオペランドは以下の通りである。

1

名前。無くても良い。名前があると、その命令パターンが、GCC の RTL生成パスにおいてある決まった仕事を成しうるということを意味する。RTL生成パスは一定のパターン名を知っていて、マシン記述に定義されている名前であれば、その名前の命令パターンを使おうとする。

名前を書くべき位置に空文字列を書くと名前がないということになる。名無しの命令パターンは RTL コードの生成に使われることはありえない。しかし、名無しの命令パターンを使うと、様々なより単純な insn を後で結合させることが出来る。

つまり、RTL生成時に知られていない、あるいは使われもしない名前は何の効果ももたらさない。名無しと全く同じである。

2

RTL テンプレート (see RTL Template) は、不完全な RTL 式を要素とするベクトルであり、命令がどのように見えるかを示す。不完全というのは、その命令のオペランドの代理である、match_operand や match_operator、match_dup 等の式を含むからである。

RTL テンプレート・ベクトルに要素が一つしかなければ、その要素は命令パターンのテンプレートである。ベクトルに要素が複数あれば、その命令パターンは列挙された要素を含む parallel 式である。

3

条件。これは文字列であり、insn 本体がパターンにマッチするかどうかを最終的に決定するための条件を C 言語の式で表したものである。

名前を持つパターンについては、条件は(もしあれば)、マッチする insn 中のデータには依存せず、ターゲット機種の型のフラグにのみ依存する。GCC は、初期化時にこの条件を調べて、どういう名前の命令が一回毎の実行時に利用できるのかを厳密に調べる必要がある。

名無しのパターンについては、条件は個々の insn とのマッチングを行なう時と、insn が、そのパターンの評価テンプレートにマッチした後にのみ適用される。insn のオペランドは、ベクトル operands に入っている。

4

出力テンプレート。 マッチした insn をどのようにアセンブラコードとして出力するかを指示する文字列である。文字列中の % は、オペランドの値をどこに代入するかを指示する。See Output Template.

単なる置き換えでは充分でないときは、C コードの断片を指定して、計算を行なったうえで出力させることも出来る。See Output Statement.

5

このパターンにマッチする insn の属性値を含むベクトル。省略可能である。 See Insn Attributes.

##define_insn の例

以下は、命令パターンの実例である。68000/68020 向けである。

```
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
  "*
{ if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return \"tstl %0\";
  return \"cmpl #0,%0\"; }")
```

これは、汎用レジスタの値に基づいて条件コードをセットする命令である。条件の指定がないので、RTL 記述が指定された形を持つ任意の命令が、このパターンに従って扱われる。tstsi という名前は、"test a SImode value"(SImode の値をテストする)という意味で、RTL 生成パスに対して、SImode の値をテストする必要があるときは、それを行う命令はこのパターンを使って構成せよということを指示する。

出力制御文字列は、C コードの断片であり、どの出力テンプレートを返すかを、オペランドの種類とコードを生成しようとしている CPU の特定の型に基づいて選択する。

"rm" は、オペランド制約(constraint)である。この意味は以下で説明する。

##RTL テンプレート

RTL テンプレートを使い、どの insn が特定のパターンにマッチするのか、および、そのオペランドの見つけ方を定義する。名前付きパターンの場合は、RTL テンプレートは、指定されたオペランドからどのように insn を構築するかについても指示する。

構築するということには、指定されたオペランドをテンプレートのコピーに代入することも含まれる。照合することには、一致しようとしている insn のオペランドの役割を果たす値を決定することも含まれる。どちらの動作も、照合とオペランドの代入を指示する特別な式の型により制御される。

(match_operand:m n predicate constraint)

この式は、insn の n 番目のオペランドのプレースホルダーである。insn の構築時に、n番目のオペランドがここに挿入される。insn の照合時には、insn のこの位置に現れるものは何であれ、n 番目のオペランドとして扱われる。ただし、その場合 predicate を満たしている必要があり、さもなければこの命令パターンは全くマッチしない。

オペランド番号は、各命令パターンにおいて 0 から始まる数字にならなければならない。各オペランド番号について、パターンにはmatch_operand 式が一個だけ存在し得る。普通は、オペランドは match_operand 式群に現れた順に番号が付く。define_expand の場合には、match_dup 式でのみ使用されるオペランド番号はどれも、他のどのオペランド番号よりも大きな値になる。

predicate は、ある C の関数名を表す文字列でり、その関数は二つの引数、すなわち一個の式と一個のマシンモードを受け付ける。照合が行なわれる間に、式として仮想的なオペランド、モード引数として m を使ってその関数が呼び出される。(m が指定されない場合は、VOIDmode が使われ、predicate は任意のモードを受け付けることになる。) この関数が 0 を返した場合は、この命令パターンの照合に失敗することになる。predicate は空の文字列であっても良い。その場合、オペランドについては何のテストも行なわれず、この位置に現れるものは何でも有効になる。

ほとんどの場合、predicate は m 以外のモードを受け付けない。ただし、いつでも受け付けないわけではない。例えば、述語(predicate) address_operand は、m を、そのアドレスが有効なメモリ参照のモードとして使う。多くの述語は、それらのモードが VOIDmode であっても const_int ノードを受け付ける。

constraint は再ロードとある値に最適なレジスタクラスの選択を制御する。これについては後で説明する (see Constraints)。

制約と述語の違いが良く判らないという人が多い。述語は、ある与えられた insn がパターンにマッチするかどうかを判断する手助けをする。一方、制約は、この判断には関与しない。代わりに、insn がパターンにマッチした場合の色々な判断を制御するのである。

CISC では、最も良く出てくる述語は、"general_operand" である。これは、仮想オペランドが、定数であるのか、レジスタなのか、メモリ参照なのかを調べ、それがモード m で有効なのものかどうかを確かめる。

レジスタでなければならないオペランドの場合は、述語としては"register_operand" を使うべきである。再ロード過程で"general_operand" を使っても、任意の非レジスタオペランドをレジスタにコピーするという処理を行うので大丈夫だが、そうすると GCC に余計な仕事をさせることになるし、ループからの不変オペランド(例えば定数)の除去や最適なレジスタ割り付けの妨げにもなる。RISC の場合には、述語としては、制約が許す範囲のオブジェクトのみを受け付けるようにするのが一般には最も効率が良い。

定数であるはずのオペランドの場合には、述語として "immediate_operand" を使うか、命令パターンの付加条件が定数を要求するようにするか、あるいは両方を行うようにする必要がある。制約を使えば同じことが出来るだろうと考えてはいけない。制約の方が定数のみを許すようになっていても、述語がそれ以外のものを許しているなら、実際にそのケースが発生したときにGCC は落ちてしまうのである。 

(match_scratch:m n constraint)

この式もオペランド番号 n のプレースホルダであり、オペランドはscratch 式か reg 式でなければならないことを指定する。

パターン照合の際には、これは、以下の式と等価である。

(match_operand:m n "scratch_operand" pred)

しかし、RTL 生成フェーズでは、これは (scratch:m) という式を生成する。

parallel の中の最後の幾つかの式が clobber 式であり、その clobber 式のオペランドがハードレジスタか match_scratch なら、結合器(combiner) は必要なときにそういうオペランドを追加したり、削除したりすることができる。 

(match_dup n)

この式もオペランド番号 n のプレースホルダーである。オペランドが insn の二箇所以上に現れる必要があるときに使われる。

構築の際には、match_dup はちょうど match_operand と同様に動作する。オペランドは、構築されつつある insn に代入される。しかし、マッチングでは、match_dup の動作は異なる。オペランド番号 n は認識テンプレートに先に現れる match_operand により既に決まっており、見た目が同一の式にしかマッチしないということを想定している。 

(match_operator:m n predicate [operands...])

このパターンは、可変な RTL 式コードの一種のプレースホルダーである。

insn 構築の際には、ある RTL 式を表す。この RTL 式の式コードは、オペランド n から取られ、オペランドはパターンの operands から構築される。

式と照合する際は、関数 predicate がその式についてゼロでない値を返し、かつ パターンの operands がその式のオペランドにマッチしたときに、その式にマッチする。

関数 commutative_operator が以下のように定義されているとする。演算子が RTL の交換可能な算術演算子の一つで、モードが mode である任意の式にマッチするように定義されている。

```
int
commutative_operator (x, mode)
     rtx x;
     enum machine_mode mode;
{
  enum rtx_code code = GET_CODE (x);
  if (GET_MODE (x) != mode)
    return 0;
  return (GET_RTX_CLASS (code) == 'c'
          || code == EQ || code == NE);
}
```

そうすると、以下のパターンは、二つの一般オペランドに適用される交換可能な演算子を含む任意の RTL 式にマッチする。

```
(match_operator:SI 3 "commutative_operator"
  [(match_operand:SI 1 "general_operand" "g")
   (match_operand:SI 2 "general_operand" "g")])
```

ここでベクトル [operands...] は、二つのパターンを含んでいる。なぜなら、マッチすべき式は全て二つのオペランドを含んでいるからである。

このパターンがマッチしたとき、交換可能な演算子の二つのオペランドは、この insn のオペランド 1 とオペランド 2 として記録される。(これは、二つの match_operand により行なわれる。) この insn のオペランド 3 は、交換可能な式全体である。

match_operator のマシンモード m は、match_operand のものと同様に振る舞う。述語関数の二番目の引数として渡され、その関数だけが、マッチすべき式がそのモードを「持っているか」どうかを決定する責任がある。

insn を構築する際には、生成関数の第三引数が、作成されるべき式の演算(すなわち式コード)を指定する。この引数は一個の RTL 式であるべきで、その式コードが、生成関数の引数 1 と 2 をオペランドとする新しい式にコピーされる。引数 3 のサブ式は使われない。式コードだけが問題になる。

match_operator が、insn と照合されるパターンで使われているとき、その match_operator のオペランド番号が、その insn の実際のオペランド番号よりも大きいのが通常は最善である。これによりレジスタ割当が改良される。レジスタ割当では、insn のオペランド 1 と 2 を見て、レジスタの結び付けが可能かどうかを見るからである。

match_operator に制約を指定する方法はない。match_operator に対応する insn のオペランドはどんな制約も持つことはない。全体として再ロードされることがないからである。だが、その operands の一部が match_operand パターンにより照合が行なわれると、その一部はそれ自身の制約があって良い。 

(match_op_dup:m n[operands...])

match_dup に似ているが、オペランドではなく演算子に適用される。insn を構築するときは、オペランド番号 n がここに代入される。しかし、マッチングの際には match_op_dup の動作は異なる。オペランド番号 n は認識テンプレートに先に現れる match_operator により既に決まっており、見た目が同一の式にしかマッチしないということを想定している。 

(match_parallel n predicate [subpat...])

このパターンは、可変数要素の parallel 式一個からなる insn のプレースホルダーである。この式は、insn パターンの最上位レベルにのみ現れるべきである。

insn を構築する際には、オペランド番号 n がこの点で置き換えられる。insn との照合の際には、insn 本体が parallel 式であり、このparallel 式が、少なくとも match_parallel 中の subpat 式の insn ベクトルの要素数と同じ要素数を持つのであれば、各 subpat が parallel の対応する要素に一致し、かつ、関数 predicate が insn の本体である parallel に対してゼロでない値を返すなら、一致が起きる。match_parallel に列挙されたもの以外の parallel の要素を確認するのは述語の役割である。

match_parallel の代表的な使い方は、ロードマルチプル式とストアマルチプル式にマッチさせることである。例えば、

```
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
```

この例は、a29k.md から取ったものである。関数 load_multiple_operations は、a29k.c で定義されており、parallel 中の後続の要素が、このパターンの中のset と同じであるかどうかを検査している。その要素が、後続のレジスタとメモリ位置を参照している場合を除く。

このパターンにマッチする insn は以下のような形式である。

```
(parallel
 [(set (reg:SI 20) (mem:SI (reg:SI 100)))
  (use (reg:SI 179))
  (clobber (reg:SI 179))
  (set (reg:SI 21)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 4))))
  (set (reg:SI 22)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 8))))])
```

(match_par_dup n [subpat...])

match_op_dup と同様だが、match_operator ではなくmatch_parallel 用である。 

(match_insn predicate)

完全な insn にマッチする。他の match_* 認識器とは異なり、match_insn はオペランド番号を取らない。

match_insn のマシンモード m は、match_operand と同様の働きをする。述語関数の第二引数として渡され、マッチした式のモードがそのモードになっているかどうかを決定する責任はその関数にだけある。 

(match_insn2 n predicate)

完全な insn にマッチする。

match_insn2 のマシンモード m は、match_operand と同様の働きをする。述語関数の第二引数として渡され、マッチした式のモードがそのモードになっているかどうかを決定する責任はその関数にだけある。 

(address (match_operand:m n "address_operand" ""))

この複雑な式は、「ロードアドレス」命令中のオペランド番号 n のプレースホルダーである。このオペランドは普通はメモリ位置を指定するが、実際のオペランド値として使われるのはその位置のアドレスであり、その位置の内容ではない。

address 式は RTL コードには決して現れず、マシン記述でのみ使われる。そして、オペランド制約の機能を使わないマシン記述でしか使われることがない。オペランド制約が使われる場合は、制約の文字 p がこの目的を果たす。

m は、アドレスとなるメモリ位置のマシンモードであり、アドレス自身のマシンモードではない。このモードは、ある与えられたターゲットマシン上では常に同じなので(Pmode で、これは普通は SImode である)、それをわざわざ明記する意味はない。つまり、address 式にはマシンモードは書かないのである。いつの日か、異なる種類のオブジェクトのアドレスが異なって見えたり、(PDP-10 のように)使い方が異なっていたりするマシンがサポートされたら、異なる形式はおそらく異なるマシンモードを必要とし、そのモードをaddress 式に書くことになるだろう。

##出力テンプレートとオペランド置換

出力テンプレートは文字列であり、ある命令パターンに対するアセンブラコードをどのように出力するかを指定する。テンプレートのほとんどの部分は、固定文字列であり、そのまま出力される。文字 % を使って、オペランドが代入される位置を指定する。また、アセンブラに変種があるために異なる構文を必要とする場所を特定するのにも使われる。

一番単純な場合では、% の数字 n が続いた場合は、文字列のその部分にオペランド n を出力することを示す。

% の直後に英字1文字と数字1文字が続くと、オペランドの出力形式を別のものに変えることを意味する。英字としては四つの文字が標準で組み込み済の意味を持っており、以下で解説する。マシン記述マクロ PRINT_OPERAND を使って、標準ではない意味を持つ文字を追加定義することができる。

%cdigit を使うと、通常は即値オペランドである事を示す構文を使わなくても、定数値であるオペランドを置き換えることができる。

%ndigit は、表示前に定数値が否定を取られることを除けば %cdigit に同じである。

%adigit を使ってそれがあたかもメモリ参照であるかのように、あるオペランドをアドレスとして扱われる実際のオペランドと置き換えることができる。これは、「ロードアドレス」命令を出力する際に役に立つ。そういう命令のアセンブラ構文では、オペランドをあたかもメモリ参照であるかのように書くことを要求することが多いからである。

%ldigit は、ジャンプ命令に label_ref を代入するのに使われる。

%= は、各命令に対し、コンパイルの全過程で一意的な番号を出力する。これは、複数のアセンブラ命令を生成する一個のテンプレート中で二回以上参照されるローカルラベルを作るときに便利である。

% の後ろに区切り文字が続くと、オペランドを使わない置き換えであることを指定する。標準的な使い方は一個だけである。%% とするとアセンブラコードに % を出力する。その他の非標準的な場合は、マクロ PRINT_OPERAND で定義することができる。また、どの区切り文字が有効かをマクロ PRINT_OPERAND_PUNCT_VALID_P で定義しなければならない。

テンプレートは複数のアセンブラ命令を生成して良い。その場合には、各命令を \; で区切って書く。

RTL にオペランドが二つあり、制約によりその二つが互いに一致することが要求されている場合には、出力テンプレートでは、数字の小さい方のオペランドしか参照してはならない。一致したオペランドはいつも同じではなく、コンパイラの残りの部分で、数字の小さい方のオペランドに出力する適切な RTL 式を置くように調整する。

% の後ろに標準でない英文字や区切り文字を置く使い方の一つに、同一のマシンに対する異なるアセンブラ言語を区別することがある。例えば、68000 には Motorola 形式と MIT 形式がある。Motorola 形式では、ほとんどのオペコード名にピリオドを使うのに対し、MIT 形式では使わない。例えば、MIT 形式で movel と書くオペコードは、Motorola 形式では move.l となる。両方の出力形式に対して同じパターンファイルを使用するが、Motorola 形式でピリオドが必要な場所には文字シーケンス %. を使うようにする。マクロ PRINT_OPERAND は、Motorola 形式では、ピリオドを出力するシーケンスを定義し、MIT 形式向けには何もしないマクロとして定義する。

特別な場合として、テンプレートが一個の文字 # から成っているとコンパイラに対し、最初に insn を分割し、次にその結果の命令を別々に出力することを指示する。これは、出力テンプレートの冗長性を消去するのに役立つ。複数のアセンブラ命令を出力する必要がある define_insn があり、マッチする define_split が既に定義されているなら、出力テンプレートとして単に # を使うことができ、複数のアセンブラ命令を出力する出力テンプレートを書く必要はない。

マクロ ASSEMBLER_DIALECT が定義されていれば、テンプレートで {option0|option1|option2}という形式の構文を使うことができる。アセンブラ言語の文法の複数の方言を記述する。See Instruction Output.

##アセンブラ出力用の C 言語の文

一個の固定テンプレート文字列だけでは、一つの命令パターンで認識される全てのケースに対して、正確で効率の良いアセンブラコードを生成するのが難しいということが良くある。例えば、オペコードはオペランドの種類に依存することがある。あるいは、オペランドの組合せが悪いと余分の機械命令が必要なこともある。

そういうときは、出力制御文字列を @ で開始すると、一行に一個ずつ置いたテンプレートの列とすることが出来る。(空行や行頭の空白、タブは無視される。) このテンプレート群は、命令パターン中の制約の選択肢に対応する(see Multi-Alternative)。例えば、ターゲットの機種が、アドレスを二つ取る加算命令として、レジスタに加算する命令 addr とレジスタの値をメモリ中に加算する命令addm の二つの命令を持っている場合、以下のようにパターンを書くことができる。

```
(define_insn "addsi3"
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (plus:SI (match_operand:SI 1 "general_operand" "0,0")
                 (match_operand:SI 2 "general_operand" "g,r")))]
  ""
  "@
   addr %2,%0
   addm %2,%0")
```

出力制御文字列が * で始まっている場合は、出力テンプレートそのものではなくて、テンプレートを生成する C のコード断片であることを示す。この C コード断片は、return 文を使って、テンプレート文字列を返す必要がある。このテンプレートは C の文字列リテラルを使う場合が多い。文字列リテラルの場合は区切り記号として二重引用符が必要である。テンプレート文字列に二重引用符を含めるには、\ でエスケープする必要がある。

オペランドは、operands という、rtx [] 型の配列に収められている。

即値オペランドが、ある一定の範囲内におさまるかどうかによって、異なるアセンブラコードの生成方法を選択するのは非常に良く行なわれる。しかし、その場合には注意が必要である。とうのは、INTVAL の結果はホストマシンでの整数になるからである。ホストマシンの int のビット数が、ターゲットマシンの定数で使われるモードのビット数より大きければ、INTVAL から得られるビットのいくつかは余計なものである。正しい結果を得るためには、この余分なビットによる値を注意深く取り除かなければならない。

サブルーチン output_asm_insn を使って、あるアセンブラ命令を出力し、その後出力を続けたり、さらに計算を行なうことが可能である。この関数は引数を二つ取る。テンプレート文字列とオペランドのベクトルである。ベクトルは operands であっても良いし、あるいは読者がローカルに宣言し、自分で初期化した、別の rtx の配列でも良い。

ある insn のパターンで、制約に複数の選択肢がある場合は、アセンブラコードの見かけはどの選択肢にマッチしたかでほとんど決まることが多い。その場合、C のコードでは、変数 which_alternative をテストすることができる。この変数は、実際に条件にあった選択肢の順番を表す数(先頭の選択肢は 0で、二番目は 1、等々)である。

例えば、ゼロを格納する命令には、二つのオペコードがあるとしよう。レジスタの場合にはclrreg、メモリ位置の場合は clrmem である。以下に、あるパターンでどのように which_alternative を使って、オペコードを選択するかを示す。

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  "*
  return (which_alternative == 0
          ? \"clrreg %0\" : \"clrmem %0\");
  ")
```

この例は、生成すべきアセンブラコードが選択肢だけで決まるなら、出力制御文字を @ で始めるようにすれば、以下のように指定することもできる。

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  "@
   clrreg %0
   clrmem %0")
```

##オペランド制約

ある命令パターンにおいて、match_operand のそれぞれに、許されるオペランドの型についての制約を指定することができる。制約により、次のような指定が可能である。あるオペランドがレジスタに置かれているかどうか、置かれているならどの種類のレジスタか。オペランドとしてメモリ参照が可能かどうか、可能ならどの種類のアドレスか。オペランドとして即値が可能かどうか、可能ならどういう値が可能か。制約は二つのオペランドが一致することを要求することもできる。

* Simple Constraints: 基本的な制約の使い方
* Multi-Alternative: insn に制約の形が二つある場合
* Class Preferences: レジスタクラスの選択
* Modifiers: 制約の修飾子
* Machine Constraints: 機種毎の制約
* No Constraints: 制約なしの機種

##単純制約

最も単純な種類の制約は全部が英文字からなる文字列である。その一つ一つの文字が、許されるオペランドの一つの種類を記述する。以下に許される英文字を示す。

m

メモリオペランドを指定する。その機種が一般にサポートしているアドレスならどれでも良い。
 
o

メモリオペランドを指定する。ただし、許されるアドレスは「オフセット指定可能な」アドレスだけである。つまり、そのアドレスに小さな整数(実際には、マシンモードにより決まる、バイト数で表したオペランドの幅に収まる数)を加算した結果もまた有効なメモリアドレスとなる。

例えば、アドレスが定数であれば、それはオフセット指定可能である。一個のレジスタと一個の定数(ちょっと大きめの定数もその機種でサポートされている範囲のアドレスのオフセットになっている限り) の和もオフセット指定可能である。しかし、自動インクリメント、自動デクリメントのアドレスはオフセット指定可能でない。もっと複雑な間接／インデックス修飾アドレスがオフセット指定可能かどうかは、その機種がサポートする他のアドレッシングモードに依存する。

別のオペランドにマッチ可能な出力オペランドにおいては、制約文字 oは、<(ターゲット機種に事前デクリメントアドレッシングがあれば)と>(ターゲット機種に事前インクリメントアドレッシングがあれば)の両方を伴う場合にのみ有効である。 

V

オフセット指定可能でないメモリオペランドを指定する。言い換えると、制約 m には収まるが、o には収まらないものは何でもここに入る。 

<

自動デクリメントのアドレスのメモリオペランドを指定する。プリデクリメントでもポストデクリメントのどちらでも良い。 

\>

自動インクリメントのアドレスのメモリオペランドを指定する。プリインクリメントでもポストインクリメントのどちらでも良い。 

r

レジスタオペランドが許される。ただし、レジスタは汎用レジスタである。 

d, a, f, ...

他の文字は、機種依存の方法で、特定のレジスタクラスを表すように定義することができる。68000/68020 では、d、a、f が定義されており、それぞれ、データレジスタ、アドレスレジスタ、浮動小数点レジスタを表す。 

i

整数の即値オペランド(定数値のもの)が許される。これには、値がアセンブル時にならないとわからないシンボリックな定数も含まれる。 

n

既知の数値を持つ整数即値のオペランドが許される。多くのシステムでは、語長よりも小さいオペランドにはアセンブル時の定数は使えない。そのようなオペランドの制約には i ではなく n を使うべきである。 

I, J, K, ... P

他の、I と P の間にある文字は、機種依存の方法で、指定された範囲の明示された整数値を持つ整数の即値オペランドを許すように定義することができる。例えば、68000 では、I は、1 ～ 8 の範囲の値を表すと定義されている。これは、シフト命令で許されているシフト幅の範囲である。 

E

浮動小数点の即値オペランド(式コードは const_double)が許される。ただし、ターゲットの浮動小数点形式がホストマシン(コンパイラが動作するマシン)のものと同じ場合に限られる。 

F

浮動小数点の即値オペランド(式コードは const_double)が許される。 

G, H

G と H は、機種依存の方法で、特定の範囲の値の浮動小数点即値オペランドを許すように定義することができる。 

s

値が明示的な整数ではない、整数即値オペランドが許される。

これは奇異に聞こえるかもしれない。もし、ある insn がコンパイル時には決まっていない値をもつ定数オペランドを許すなら、当然、どんな既知の値でも許さなければならないはずだ。どうして、i の代わりに s を使うのか? その方が、良いコードが生成されることがあるからなのだ。

例えば、68000 の全ワードの命令では即値オペランドを使うことができる。しかし、即値の範囲が -128 と 127 の間にあるなら、その値をレジスタにロードして、そのレジスタを使った方が良いコードになるのである。これは、レジスタへのロードが moveq 命令で行なえるからである。我々はこれが起きるように、文字 K が「-128 と 127 の範囲の外側の整数」という意味を持つように定義し、オペランドの制約にKs と指定している。 

g

任意のレジスタ、メモリ、整数の即値のオペランドが許される。ただし、汎用レジスタでないレジスタは除く。 

X

どんなオペランドでも、たとえ general_operand を満たさないものであっても許される。これは、通常、特定の選択肢が実際にはスクラッチレジスタを必要としないときに、match_scratch の制約で使われる。 

0, 1, 2, ... 9

指定したオペランド番号にマッチするオペランドが許される。数字を同じ選択肢の中で英文字と組み合わせて使うなら、数字は最後に書くこと。

これは、照合制約と呼ばれており、それが実際に意味することは、アセンブラには二つの役割を果たす一個のオペランドしかないということである。この二つの役割は RTL insn で別のものと考えられている。例えば、add insn は RTL には、二つの入力オペランドと一つのオペランドを持っているが、多くの CISC マシンでは、add 命令にはオペランドが二つしかなく、その一つは入力と出力兼用オペランドである。

addl #35,r12

照合制約は以下の状況で使われる。もっと正確に言えば、マッチする二つのオペランドのうち、一つは入力専用で、もう一つは出力専用でなければならない。さらに、数字は制約で使われているオペランド数より小さな数でなければならない。

ある特定の場合にマッチするオペランドは普通それらが見かけが同じであるRTL 式になっているということを意味する。しかし、2,3の特別な場合には特定の種類の違いは許される。例えば、入力オペランドとしての *x は出力オペランドとしての *x++ にマッチする。このような場合に正しい結果を得るには、出力テンプレートではオペランドを出力するさいに常に出力オペランドの番号を使う必要がある。 

p

有効なメモリアドレスであるオペランドが許される。これは、「ロード・アドレス」命令と「プッシュ・アドレス」命令向けである。

制約の中の p には、match_operand の述語のように、address_operand が付随しなければならない。この述語は、match_operand で指定されたモードを、アドレスが有効であるメモリ参照のモードとして解釈する。 

Q, R, S, ... U

Q から U の範囲の文字は、機種依存の形式で定義して、任意のオペランド型を表すのに使える。マシン記述マクロ EXTRA_CONSTRAINT には、一番目の引数としてそのオペランドが、二番目の引数として制約文字が渡される。

これの典型的な使い方は、他の insn のオペランドに影響するメモリ参照の一定の型を区別することである。

これらの制約文字は、レジスタ選択(reg)を受け付けるようには定義しないこと。再ロードパスが想定していないことであり、正しく扱えないだろう。

アセンブラコードを正しいものにするために、各オペランドはその制約を満たさなければならない。しかし、制約を満たさなくても、そのパターンがある insn に適用されるのを妨げるものではない。代わりに、コンパイラがコードを修正して、制約が満足されるようにする。通常これはオペランドをレジスタにコピーすることにより行なわれる。

このため、以下の二つの命令パターンを比べてみよう。

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "general_operand" "r")))]
  ""
  "...")
```

これにはオペランドが二つあり、そのうちの一つは二箇所に現れなければならない。そして、

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_operand:SI 1 "general_operand" "0")
                 (match_operand:SI 2 "general_operand" "r")))]
  ""
  "...")
```

こちらは、オペランドが三つあり、そのうちの二つは制約により等しいことが要求される。以下の形の insn を考えてみると、

```
(insn n prev next
  (set (reg:SI 3)
       (plus:SI (reg:SI 6) (reg:SI 109)))
  ...)
```

最初のパターンは全く適合しない。この insn には、正しい場所に二つの同じ部分式がないからである。最初のパターンは、「加算命令には見えないので、他のパターンを試してね。」と言うだろう。一方、二番目のパターンは、「うん、これは加算命令だ。だけどちょっと間違ってるな。」と言うだろう。コンパイラの再ロードパスに対して insn を追加で生成させ、制約が満たされるようにすることを指示する。その結果は以下のようになるだろう。

```
(insn n2 prev n
  (set (reg:SI 3) (reg:SI 6))
  ...)

(insn n n2 next
  (set (reg:SI 3)
       (plus:SI (reg:SI 3) (reg:SI 109)))
  ...)
```

各パターンの各オペランドが、それぞれのオペランド向けに存在しうる、どんな RTL 式も扱えるような制約を持つことを保証するのは読者の責任である。(複数の選択肢が使われている場合は、各パターンは、オペランド式の可能な組合せ毎に、その組合せを扱うことが出来る選択肢を少なくとも一つ持たなければならない。) その制約は可能なオペランドをなんでも許す必要はない。なんでも許すのであればそれは制約ではない。だが、その制約は少なくとも、それに適するような何らかの可能なオペランドを再ロードする方法を指し示す必要がある。

* もし制約が、述語が許すオペランドなら何でも受け付けるなら何の問題もない。このオペランドは再ロードを全く必要としない。

* 例えば、レジスタ以外のあらゆるものを許す制約を持つオペランドは、その述語がレジスタを拒絶するなら安全である。

* 定数値だけを受け付ける述語を持つオペランドは、その制約に文字 i が入っていれば安全である。任意の可能な定数値を受け付けたなら、i がするであろう以上のことはなにもしない。もし述語がもっと選択的なら、制約もまたもっと選択的にして良い。

* 任意のオペランド式は、レジスタにコピーすることにより再ロード可能である。そのため、オペランドの制約がどの種類かのレジスタを許していれば、間違いなく安全である。全てのクラスのレジスタを許す必要はない。コンパイラは、命令を正しいものにするために、あるレジスタを別の適切なクラスのレジスタにコピーする方法を知っている。

* オフセット可能でないメモリ参照は、そのアドレスをレジスタにコピーすることで再ロード可能である。そのため、制約が文字 o を使っていれば、全てのメモリ参照の面倒を見てくれる。

* 定数オペランドは、それを事前に初期化されたデータとして保持するために、メモリスペースを獲得することで、再ロード可能である。そうすると、定数の代わりにメモリ参照が使える。そのため、制約が文字 o や m を使っていれば、定数オペランドは問題ではない。

* 制約が一個の定数とある insn で使われている一個の疑似レジスタを許しているものとする。このとき、その疑似レジスタがハードレジスタに割り当てられておらず、定数に等価であるなら、そのレジスタは定数に置き換えられる。述語が一個の定数と何らかの理由により再認識される insn を認めていなければ、GNU CC が異常終了する。すなわち、述語は、制約により許されるオブジェクトはどんなものであれ常に認識しなければならない。

オペランドの述語はレジスタを認識できるが、制約の方はレジスタを許さない場合はコンパイラが落ちる可能性がある。このオペランドがレジスタになったとき、再ロードパスがうまくいかなくなる。レジスタを一時的にメモリにコピーする方法が分からないためである。

述語が単項演算子を受け付けるなら、制約はそのオペランドに適用される。例えば、ISA レベル 3 の MIPS プロセッサは、SImode の二つのレジスタを加算して、DImode の結果を生成する命令をサポートしているが、これはレジスタが正しく符号拡張される場合だけである。入力オペランドに対するこの述語は、ある SImode のレジスタのsign_extend を受け付ける。sign_extend のオペランドとして必要なレジスタのタイプを示すように制約を書くこと。

##複数の制約の選択肢
一個の命令が可能なオペランドの複数の選択肢の組を持つことが時々ある。例えば、68000 では論理和命令はレジスタか即値をメモリと組み合わせることができる。あるいは、任意の種類のオペランドをレジスタと組み合わせることができる。だが、一つのメモリ位置をもう一つのメモリ位置と組み合わせることはできない。

このような制約は複数の選択肢として表現される。ある選択肢は、各オペランド毎に、文字の連なりで記述される。あるオペランドに対する制約は全体としては、最初の選択肢に現れるこのオペランド用の文字、カンマ、第二の選択肢に現れるこのオペランド用の文字、カンマ、... が最後の選択肢まで続く。これが、68000 の全ワードの論理和命令ではどのようになされているかを以下に示す。

```
(define_insn "iorsi3"
  [(set (match_operand:SI 0 "general_operand" "=m,d")
        (ior:SI (match_operand:SI 1 "general_operand" "%0,0")
                (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
  ...)
```
最初の選択肢は、オペランド0には m(メモリ)、オペランド 1 には0(これはオペランド 0 に一致しなければならないことを意味する)、オペランド 2 には dKs となる。第二の選択肢は、オペランド0には d(データ・レジスタ)、オペランド 1 には 0、オペランド 2 には dmKs となる。制約中の = と % は全選択肢に適用される。それらの意味は次の節 (see Class Preferences)で説明する。

全てのオペランドがどれか一つの選択肢に収まれば、その命令は有効である。収まらない場合には、選択肢毎に、コンパイラが、選択肢を適用可能にするためには、オペランドをコピーするための命令を幾つ追加しなければならないかを数え上げる。最もコピーが少なくて済む選択肢が選ばれる。もし二つの選択肢のコピー数が同じなら、先に現れるものが選ばれる。この選択方法は文字 ? と1 を使って変えることが出来る。

?

どの選択肢も厳密には適用できないときの選択として、? が現れる選択肢をちょっとだけ低く評価する。GNU CC は、この選択肢を、そこに現れる ? 毎に、一単位分コストが余計にかかるとみなす。 

!

!が現れる選択肢を大幅に低く評価する。この選択肢は再ロードなしで収まる場合には依然として使うことができるが、再ロードが必要な場合は、何か他の選択肢が使われる。

insn のパターンが、その制約に複数の選択肢を持つ場合は、アセンブラコードの見た目は、どの選択肢が一致したかによりほとんどの場合決まる。その場合は、アセンブラコードを書き出す C のコードで、変数 which_alternative を使うことが出来る。which_alternative は、何番目の選択肢が実際に満たされるかを示す番号である。第一の選択肢は 0、第二の選択肢は 1 といった具合である。See Output Statement。

##レジスタクラス選択
オペランド制約にはもう一つの機能がある。コンパイラが、疑似レジスタを割り当てるのにどの種類のハードウェアレジスタが最適かを決定することを可能にする。コンパイラは疑似レジスタを使っている insn に適用される制約を調べ、レジスタクラスを指定する d や a のような機種依存文字を探す。疑似レジスタは、最も「得票」の多いクラスに置かれる。制約文字 g と r も投票する。汎用レジスタの好みについて投票するのである。マシン記述がどのレジスタが汎用と考えられるかを指定する。

当然、機種によっては全てのレジスタが等価であり、レジスタクラスが定義されない場合もある。その場合には、上記のような複雑さは関係なくなる。

##制約修飾子文字

以下に制約の修飾子となる文字を示す。

\=

オペランドが書き込み専用であることを意味する。このオペランドに以前保持されていた値は捨てられ、出力データで置き換えられる。 

+

オペランドが読み込みと書き込みの両方に使われることを意味する。

コンパイラが、オペランドを制約を満たすように修正する際に、どのオペランドが命令に対する入力で、どのオペランドが出力かを知っている必要がある。= は、出力であることを示す。+ は、オペランドが入力と出力の両方に使われることを示す。それ以外のオペランドは入力専用と仮定される。 

&

(ある特定の選択肢において)このオペランドが早期破壊 オペランドであることを意味する。早期破壊オペランドとは、命令が入力オペランドを使い終わる前に変更されるオペランドである。このため、このオペランドは、入力オペランドや任意のメモリアドレスの一部として使われるレジスタには置かれない。

& は、記述されている選択肢に対してしか適用されない。複数の選択肢のある制約では、一つの選択肢は & を必要とするが他の選択肢は必要としないということが時々ある。そういう例については、68000 の movdf insn を参照のこと。

入力オペランドは、それが入力として使われるのが以前の結果が書き込まれる前なら、早期破壊オペランドに結び付けることができる。この形式の選択肢を追加すると、入力の一部しか早期破壊により影響を受けない場合は、GCC の生成するコードが良くなることが多い。例えば、ARM の mulsi3 insn を参照のこと。

& があっても、= を書く必要はなくならない。 

%

このオペランドと次のオペランドが交換可能であることを指示する。これは、コンパイラにとって、二つのオペランドを交換するのが全ての制約を満たすようにするには最もコストの低い方法であれば、その方法を取ることを可能にする。この制約は、オペランドを二つしか取らない加算命令向けのパターンで良く使われる。以下に、68000 の半語の加算命令の定義例を示す。

```
(define_insn "addhi3"
  [(set (match_operand:HI 0 "general_operand" "=m,r")
     (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
              (match_operand:HI 2 "general_operand" "di,g")))]
  ...)
```

\#

次に続く文字からコンマまでの全ての文字を制約としては使わないことを示す。それらの文字は、レジスタ選択でのみ意味を持つ。 

\*

次に続く文字がレジスタ選択の際には無視されることを示す。* は、制約としての制限の意味と再ロードには影響を与えない。

次に例を示す。68000 は、データ・レジスタ中の半語を符号拡張する命令を持っており、また、アドレス・レジスタにコピーすることで符号拡張を行なうことも出来る。どちらの種類のレジスタも受け入れ可能な場合、アドレスレジスタをコピー先とした場合の制約がより限定が緩いので、レジスタ割当がアドレスレジスタを最終目標とするのが最適である。このため、* を使って、制約文字 d (データレジスタ用)が好ましいレジスタを選択するときには無視されるようにする。

```
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=*d,a")
        (sign_extend:SI
         (match_operand:HI 1 "general_operand" "0,g")))]
  ...)
```


##特定の機種用の制約

asm の引数には、可能な限り、汎用の制約文字を使ったほうが良い。その方が読む人に意味が伝わりやすくなるからだ。汎用の制約文字では駄目な場合は、色々なアーキテクチャで同じような意味を持つ制約文字を使うようにする。最も共通して良く使われるのは、m と r である。それぞれ、メモリと汎用レジスタを表す。see Simple Constraints それに、I が、最も一般的な即値定数の形式を表す文字として使われる。

マシンアーキテクチャ毎に、config/machine.h というファイルで、固有の制約を追加定義している。これらの制約は、asm 文だけでなく、コンパイラ自身の命令の生成に使われる。このため、制約のうちいくつかは、asm 文に使うにはあまり意味のないものがある。制約は以下のマクロ群によって定義される。

REG_CLASS_FROM_LETTER
レジスタクラスの制約(普通は小文字だけである)。 

CONST_OK_FOR_LETTER_P
即値定数の制約。ワード長、あるいはそれより短い精度の、非浮動小数点定数向けである。通常、大文字である。 

CONST_DOUBLE_OK_FOR_LETTER_P
即値定数の制約。全ての浮動小数点定数とワード長を越える精度の定数向けである。通常、大文字である。 

EXTRA_CONSTRAINT
レジスタまたはメモリの特別な場合。このマクロは必須ではなく、少数のマシンでのみ定義されている。
本コンパイラのソースの、読者のマシン向けのマクロ定義を調べるのが、正しい制約を使っているかどうかを確認するのに一番良い方法である。とはいうものの、以下に幾つかの特定の機種で使える機種依存の制約を要約しておく。

ARM family--arm.h

f
浮動小数点レジスタ 

F
浮動小数点定数 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 10.0 のどれか一つ 

G
符号反転したときに制約 F を満たす浮動小数点定数 

z
FPR-GPR 間移動用の FPMEM スタックメモリ 

I
データ処理命令の即値オペランドとして有効な整数。すなわち、0 から 255 の間の整数を 2 の倍数分回転したものである。 

J
-4095 ～ 4095 の範囲の整数 

K
ビット反転(1の補数)したときに制約 I を満たす整数 

L
符号反転(2の補数)したときに制約 I を満たす整数 

M
0 ～ 32 の範囲の整数 

Q
正確なアドレスが一個のレジスタにある場合のメモリ参照(asm 文の場合には、m の方が良い)。 

R
定数領域に置かれるデータ 

S
現在ファイルのテキストセグメント中のシンボル

AMD 29000 family--a29k.h

l
ローカルレジスタ 0 

b
バイトポインタ(BP)レジスタ 

q
Q レジスタ 

h
特殊目的のレジスタ 

A
第一アキュムレータレジスタ 

a
他のアキュムレータレジスタ 

f
浮動小数点レジスタ 

I
0 より大きく、0x100 より小さい定数 

J
0 より大きく、0x1000 より小さい定数 

K
上位 24 ビットがオン(1)の定数 

L
上位 8 ビットがオン(1) の 16 ビット定数 

M
上位 16 ビットがオン(1) の 32 ビット定数 

N
8ビットに収まる 32ビットの負の定数。 

O
定数 0x80000000か、あるいは、29050 の場合は、下位16ビットが 0 である任意の32ビット定数。 

P
8ビットに収まる 16ビットの負の定数。 

G
H
浮動小数点定数(asm 文では、代わりに機種独立の E か F を使うこと。)


IBM RS6000--rs6000.h

b
アドレスベースレジスタ 

f
浮動小数点レジスタ 

h
MQ, CTR, LINK レジスタ 

q
MQ レジスタ 

c
CTR レジスタ 

l
LINK レジスタ 

x
CR レジスタ(条件レジスタ)の 0 番 

y
CR レジスタ(条件レジスタ) 

z
FPR-GPR 間転送用の FPMEM スタックメモリ 

I
符号付きの 16 ビット定数 

J
下位16ビットが 0 の定数 

K
上位の 16 ビットが 0 の定数 

L
マスク用オペランドとして適切な定数 

M
31 より大きい定数 

N
2 の正確な冪乗 

O
ゼロ 

P
符号反転したものが符号付き 16 ビット定数になる定数 

G
一ワードにつき一回の命令でレジスタにロード可能な浮動小数点定数。 

Q
あるレジスタからのオフセットであるメモリオペランド(asm 文の場合は、m の方が良い)。 

R
AIX の TOC エントリ 

S
64ビットのマスク・オペランドとして適した定数。 

U
System V Release 4 の小データ領域の参照

Intel 386--i386.h

q
a、b、c、d レジスタ 

A
a、d レジスタ(64ビット int 向け) 

f
浮動小数点レジスタ 

t
第一(スタックの一番上の)浮動小数点レジスタ 

u
第二浮動小数点レジスタ 

a
a レジスタ 

b
b レジスタ 

c
c レジスタ 

d
d レジスタ 

D
di レジスタ 

S
si レジスタ 

I
0～31 の定数(32ビットのシフト用) 

J
0～63 の定数(64ビットのシフト用) 

K
0xff 

L
0xffff 

M
0、1、2、3(lea 命令のシフト数である) 

N
0 から 255 の範囲の定数(out 命令用) 

G
80387 標準の浮動小数点定数

Intel 960--i960.h

f
浮動小数点レジスタ(fp0 から fp3) 

l
ローカルレジスタ(r0 から r15) 

b
グローバルレジスタ(g0 から g15) 

d
任意のローカルまたはグローバルレジスタ 

I
0 から 31 の整数 

J
0 

K
-31 から 0 の整数 

G
浮動小数点の 0 

H
浮動小数点の 1

MIPS--mips.h

d
汎用整数レジスタ 

f
浮動小数点レジスタ(もしあれば) 

h
Hi レジスタ 

l
Lo レジスタ 

x
Hi または Lo レジスタ 

y
汎用整数レジスタ 

z
浮動小数点ステータスレジスタ 

I
符号付き 16 ビット定数(算術演算命令向け) 

J
ゼロ 

K
ゼロ拡張された 16 ビット定数(論理命令向け) 

L
下位16ビットがゼロの定数(lui でロード可能) 

M
32ビット定数のうち、ロードするのに 2 命令必要なもの(I でもK でも L でもない定数) 

N
負の16ビット定数 

O
二の冪乗 

P
正の 16 ビット定数 

G
浮動小数点のゼロ 

Q
一個以上の命令でロード可能なメモリ参照(asm 文の場合は、m の方が良い)。 

R
一個の命令でロード可能なメモリ参照(asm 文の場合は、m の方が良い)。 

S
外部 OSF/rose PIC 形式でのメモリ参照(asm 文の場合は、m の方が良い)。

Motorola 680x0--m68k.h

a
アドレスレジスタ 

d
データレジスタ 

f
利用可能なら、68881 の浮動小数点レジスタ 

x
利用可能なら、Sun の FPA の浮動小数点レジスタ。 

y
利用可能なら、Sun の FPA の浮動小数点レジスタの最初の 16 個。 

I
1 ～ 8 までの整数 

J
16 ビットの符号付きの数 

K
絶対値が 0x80 より大きい符号付き整数。 

L
-8 ～ -1 の整数 

M
絶対値が 0x100 より大きい符号付き整数。 

G
68881 の定数ではない浮動小数点定数。 

H
Sun の FPA で使用可能な浮動小数点定数。

SPARC--sparc.h

f
32 ビットまたは 64 ビットの値を保持できる浮動小数点レジスタ。 

e
64 ビットまたは 128 ビットの値を保持できる浮動小数点レジスタ。 

I
13ビットの符号付き定数 

J
ゼロ 

K
下位12ビットが 0 の 32ビット定数(sethi 命令でロード可能な定数) 

G
浮動小数点数のゼロ。 

H
13 ビットの符号付き定数で、32 ビットまたは 64 ビットに符号拡張される。 

Q
1命令でロード可能なメモリ参照(m の方が、asm 文にはもっと適している。) 

S
定数、またはメモリアドレス 

T
8バイト境界に整合されたメモリアドレス 

U
偶数レジスタ

##制約を使わないということ

マシンによっては、アーキテクチャがきれいなのでオペランドの制約を必要としないものもある。例えば、Vax では、オペランドがある文脈で有効なら、その他のどの文脈でも有効である。そういうマシンでは、各オペランド制約はg になるだろう。例外は、"load address" 命令のオペランドだけである。"load adress" 命令は、指定されたメモリ位置の内容を参照するかのような書き方をするが、実際はアドレスを参照するだけである。この場合には制約は p になる。

このようなマシンでは全部の制約について g や p と書く代わりに、制約を空にすることもできる。その場合には、各 match_operand の制約を "" とすれば良い。アドレスオペランドは、address 式で match_operand 囲むように書くことによって認識されるのであり、制約によって認識されるのではない。

マシン記述の制約が単に空なら、コンパイル過程の特定の部分が省略され、コンパイルが速くなる。だが、制約を必要としない機種は実際にはほとんど存在しない。現在存在するマシン記述は全て制約を使っている。

##RTL生成用標準パターン名

以下に、RTL 生成パスで意味を持つ命令パターン名の一覧を示す。ある命令パターンに以下の名前の一つを与えると、RTL 生成パスは、ある一定の仕事を達成するためにそのパターンを使って良いということがわかる。

movm

ここで m は、二文字からなるマシンモード名を小文字で表したものである。この命令パターンは、指定されたマシンモードのデータをオペランド 1 からオペランド 0 に移動する。例えば、movsi は全ワードのデータを移動する。

オペランド 0 が、モードが m より広いレジスタの、モード m のsubreg であるなら、この命令の効果はモード m に対応するレジスタの一部に指定された値を格納することである。レジスタの他の部分に対する効果は未定義である。

このクラスのパターンは色々な点で特殊である。まず第一に、これらの名前はそれぞれ定義されなくてはならない。なぜなら、データをある場所から他の場所にコピーする方法が他にはないからである。

第二に、これらのパターンは RTL 生成パスだけで使われるのではない。再ロードパスにおいても、値をスタックスロットから一時レジスタにコピーするmove insn を生成する可能性がある。その時、オペランドの一つはハードレジスタであり、他の一つは、レジスタに再ロードされる必要となる可能性があるオペランドである。

このため、このようなオペランドの対が与えられたとき、このパターンは再ロードを必要とせず、一時レジスタ-オペランド以外のレジスタを必要としない RTL を生成しなければならない。例えば、define_expand でそのパターンをサポートするなら、その場合、define_expand は force_reg や新しい疑似レジスタを生成するような他の関数は呼び出してはならない

RISCマシンのサブワードモードについても、その機種でメモリからサブワードモードを取り出すのに複数の命令と一時レジスタが必要なら、この要求は存在する。この要求を満たすにはどうすれば良いかは spur.md を参照のこと。

再ロードの最中、無効なアドレスのメモリ参照がオペランドとして渡される可能性がある。そういうアドレスは、再ロードパスの後の方で有効なアドレスに置き換えられる。この場合、そのままでは、そのアドレスに対してはそれを使うという以外には何も行なわれない。もしそれがコピーされたとすると、有効なアドレスには置き換えられない。そういうアドレスを有効なアドレスに変えようとする試みは全く行なわれず、(change_address のような)そういう処理をする関数も呼ばれない。general_operand をそのようなアドレスに適用すると失敗することに注意。

グローバル変数 reload_in_progress(これは必要なら明示的に宣言しなければならない)を使って、そのような特別な取扱いが必要かどうかを決定することができる。

再ロードされるオペランドの種類は、マシン記述のその他の部分に依存するが、RISC 機種では普通はハードレジスタを割り当てることの出来なかった疑似レジスタに限られる。一方、それ以外の機種では明示的なメモリ参照は再ロードされる可能性がある。

あるオブジェクトをメモリへ、あるいはメモリから移動するのに、スクラッチレジスタが必要な場合は、生死解析に先だって gen_reg_rtx を使って割り当てることができる。

再ロード後にスクラッチレジスタが必要になる場合があるなら、SECONDARY_INPUT_RELOAD_CLASS を定義しなければならない。また、それらを検出するためにおそらく SECONDARY_OUTPUT_RELOAD_CLASS も定義しなければならない。それから、それらに対する取扱いのために、reload_inm パターンか reload_outm パターンを定義しなければならない。See Register Classes。

グローバル変数 no_new_pseudos を使って、新しい疑似レジスタを作るのが危険かどうかを決定することができる。この変数がゼロでないときは、gen_reg_rtx を使って新しい疑似レジスタを割り当てるのは危険である。

movem についての制約は、任意のハードレジスタから別の任意のハードレジスタへの移動を許さなければならない。ただし、HARD_REGNO_MODE_OK がどちらのレジスタもモード m であることを許し、これらのレジスタのクラスに REGISTER_MOVE_COST を適用した場合に 2 という値が返ってくるという前提がある。

固定小数点値を保持できる任意のレジスタについて、値を出し入れできる浮動小数点 movm 命令をサポートするのは必須である。なぜなら共用体や構造体(モードは SImode か DImode)はそのようなレジスタに入れることができ、浮動小数点メンバが存在する可能性があるからである。

また、浮動小数点レジスタから値を出し入れする固定小数点 movm 命令も必要である。ただ、残念なことに著者はどうしてそうしたのだったかを忘れてしまっており、現在でもその通りであるかどうかがわからない。HARD_REGNO_MODE_OK が浮動小数点レジスタに固定小数点値を入れるのを拒絶するなら、固定小数点 movm 命令の制約は浮動小数点レジスタに再ロードするのを避けるように定義しなければならない。 

reload_inm

reload_outm

movm と同様だが、オペランド 0 とオペランド 1 の間で移動を行なうのにスクラッチレジスタが必要な場合に使われる。オペランド 2 がそのスクラッチレジスタを記述する。see Register Classes のマクロ SECONDARY_RELOAD_CLASS の議論を参照のこと。 

movstrictm

movm と同様だが、オペランド 0 が、その自然なモードがもっと広いようなレジスタのモード m の subreg であるなら、movstrictm 命令は、モード m に属する部分を除いて、そのレジスタをなんら変更しないことが保証される。 

load_multiple

幾つかの連続したメモリ位置から幾つかの連続したレジスタにロードする。オペランド 0 は連続するレジスタの先頭のレジスタであり、オペランド 1 は、メモリ位置の先頭であり、オペランド 2 は、連続するレジスタ数を指定する定数である。

これを定義するのは、ターゲットマシンが実際にこのような命令を持っている場合に限る。メモリから連続するレジスタへロードするのに最も効率が良い方法が、一個一個ロードすることであれば、このマクロは定義してはいけない。

マシンによっては、どの連続するレジスタがメモリに格納可能であるかについて制限がある。例えば、先頭や末尾のレジスタ番号が特定のものでなくてはいけないとか、有効なレジスタ数の範囲内でのみ可能である、などである。このような制限がある場合は、define_expand(see Expander Definitions) を使って、制限が満たされない場合はそのパターンが失敗するようにする。

生成される insn は一個の parallel として書き、その要素は一個のレジスタを適切なメモリ位置に設定する set とする(また、use あるいは clobber の要素も必要である)。match_parallel (see RTL Template)を使って、その insn を認識する。この insn パターンの使い方の例としては、a29k.md と rs6000.md を参照のこと。 

store_multiple

load_multiple と同様だが、複数の連続したレジスタを連続したメモリ位置に格納する。オペランド 0 が連続したメモリ位置の先頭で、オペランド 1 が先頭のレジスタ、オペランド 2 がある定数で、連続するレジスタの数を表す。 

addm3

オペランド 2 と 1 を加算し、結果をオペランド 0 に格納する。オペランドは全てモードが m でなければならない。2オペランドのマシンでも使用可能である。その場合は、オペランド 1 とオペランド 0 が同じ位置にあるという制約を課せば良い。 

subm3, mulm3

divm3, udivm3, modm3, umodm3

sminm3, smaxm3, uminm3, umaxm3

andm3, iorm3, xorm3

他の算術演算についても同様である。 

mulhisi3

オペランド 1 と 2 を乗算する。どちらもモードは HImode である。SImode の乗算の結果をオペランド 0 に格納する。 

mulqihi3, mulsidi3

他の幅の、乗算の結果がオペランドの幅よりも大きくなる命令についても同様である。 

umulqihi3, umulhisi3, umulsidi3

符号なしの乗算を行なう、乗算の結果がオペランドの幅よりも大きくなる命令についても同様である。 

mulm3_highpart

オペランド 1 と 2 の符号付き乗算を行なう。モードは m である。積の上位半分をオペランド 0 に格納する。積の下位半分は捨てられる。 

umulm3_highpart

mulm3_highpart と、乗算が符号なしで行なわれる点を除いて、同じである。 

divmodm4

商と剰余の両方を生成する符号付き除算である。オペランド1 をオペランド 2 で割り、商がオペランド 0 に、剰余がオペランド 3 に格納される。
商と剰余の両方を生成する命令がある機種では、divmodm4 のパターンを定義し、divm3 と modm3 のパターンは定義しないようにすること。これにより、商と剰余の両方を計算するという比較的良くある場合に最適化が可能になる。

単に商か剰余のどちらかを生成する命令が存在し、両方を生成する命令よりも効率が良い場合は、divmodm4 の出力ルーチンを、find_reg_note を呼び出して、商か剰余についての REG_UNUSED ノートを見つけ、適切な命令を生成するように書く。 

udivmodm4

divmodm4 と、除算が符号なしで行なわれる点を除いて、同じである。 

ashlm3

オペランド 1 を、オペランド 2 で指定されたビット数だけ左に算術シフトし、結果をオペランド 0 に格納する。ここで、mは、オペランド 0 とオペランド 1 のモードである。オペランド 2 のモードは、命令パターンにより指定され、コンパイラは命令を生成する前にオペランドをそのモードに変換する。 

ashrm3, lshrm3, rotlm3, rotrm3

その他のシフトとローテート命令群。ashlm3 と同様である。 

negm2

オペランド 1 の符号を反転し、その結果をオペランド 0 に格納する。 

absm2

オペランド 1 の絶対値をオペランド 0 に格納する。 

sqrtm2

オペランド 1 の平方根をオペランド 0 に格納する。
C の組み込み関数 sqrt は、常に C 言語のデータ型 double に対応するモードを使用する。 

ffsm2

オペランド 0 に、1 と、オペランド 1 のビットが 1 のうち最下位のもののインデックスを足したものを格納する。オペランド 1 がゼロなら、ゼロを格納する。m はオペランド 0 のモードである。オペランド 1 のモードは命令パターンにより指定され、コンパイラが命令を生成する前にオペランド 1 をそのモードに変換する。
C の組み込み関数 ffs は、C のデータ型 int に対応するモードを常に使う。 

one_cmplm2

オペランド 1 のビット毎の補数をオペランド 0 に格納する。 

cmpm

オペランド 0 とオペランド 1 を比較し、条件コードを設定する。RTL パターンは以下のようにする必要がある。
(set (cc0) (compare (match_operand:m 0 ...)
                    (match_operand:m 1 ...)))

tstm

オペランド 0 とゼロを比較し、条件コードを設定する。RTL パターンは以下のようにする必要がある。
(set (cc0) (match_operand:m 0 ...))
(cc0) を使わない機種では、tstm パターンを定義すべきでない。定義すると、どの set 演算が比較なのかはっきりしなくなってしまうために最適化パスが混乱する。代わりに、cmpm パターンを使うべきである。 

movstrm

ブロック移動命令である。移動先と移動元の文字列のアドレスが最初の二つのオペランドであり、どちらも Pmode モードである。

移動すべきバイト数を三番目のオペランドで、モード m で指定する。普通は、m として word_mode を指定する。しかし、有効な長さの範囲が全ワードで表せる範囲より狭いことが分かっているなら、より良いコードを生成することができるという場合には、効率良く扱える値の範囲に対応するモード(例えば、0-127の範囲の値の場合なら QImode とする。負の数に見えるものは避けることに注意)のパターンとword_mode のパターンの両方を提供すべきである。

四番目のオペランドは、移動元と移動先で共通の既知のアライメントをconst_int rtx の形で表したものである。つまり、コンパイラが移動元も移動先もワード境界にアライメントされていることを知っているなら、このオペランドには 4 という値が与えられる。

複数の movstrm パターンを記述するのは、より小さなモードに対するそれらのパターンについて、第一、第二、第四オペランドについての制限がより少ない場合にのみ、有益である。movstrm のモード m は、ブロック中の個々の移動されたデータ単位のモードには、なんら制限を与えないことに注意。

このパターンは、移動元と移動先の文字列が重なっている可能性は、特に考えなくて良い。 

clrstrm

ブロックのクリア命令である。対象文字列のアドレスが第一オペランドであり、モード Pmode である。クリアすべきバイト数が第二オペランドであり、モード m である。モードの選択についての議論は、movstrm を参照のこと。
三番目のオペランドは、目的先の既知のアラインメントを const_int RTX の形で表したものである。つまり、コンパイラが目的先がワード整合されていることを知っているなら、このオペランドの値を 4 とする。

複数の clrstrm の使い方は、movstrm と同じである。 

cmpstrm

ブロック同士の比較命令で、オペランドは5つある。オペランド 0 には出力が置かれ、モードは m である。その他の4つのオペランドは、movstrm のオペランドと同様である。指定された二つのメモリブロックがバイト毎に辞書順で比較される。この命令の結果、オペランド 0 に格納された値の符号が、比較結果になる。 

strlenm

文字列の長さを計算する。オペランドは三つある。オペランド 0 は結果(モードは m)を格納する。オペランド 1 は、文字列の先頭の文字を参照する mem である。オペランド 2 は、検索すべき文字(通常はゼロ)である。オペランド 3 は、文字列の開始位置の既知のアラインメントを記述する定数である。 

floatmn2

符号付き整数オペランド 1(固定小数点モード m として有効) を浮動小数点モード n に変換し、オペランド 0 (モード n)に格納する。 

floatunsmn2

符号なし整数オペランド 1(固定小数点モード m として有効) を浮動小数点モード n に変換し、オペランド 0 (モード n)に格納する。 

fixmn2

オペランド 1(浮動小数点モード m として有効)を符号付き数として固定小数点モード n に変換し、オペランド 0(モード n) に格納する。この命令の結果は、オペランド 1 の値が整数の場合にのみ定義される。 

fixunsmn2

オペランド 1(浮動小数点モード m として有効)を符号なし数として固定小数点モード n に変換し、オペランド 0(モード n) に格納する。この命令の結果は、オペランド 1 の値が整数の場合にのみ定義される。 

ftruncm2

オペランド 1(浮動小数点モード m として有効) を整数値に変換する。ただし、依然として浮動小数点モード m で表現される。結果は、オペランド 0(浮動小数点モード m として有効)に格納される。 

fix_truncmn2

fixmn2 と同様だが、モードが m の任意の浮動小数点値について、その値を整数に変換することにより、動作する。 

fixuns_truncmn2

fixunsmn2 と同様だが、モードが m の任意の浮動小数点値について、その値を整数に変換することにより、動作する。 

truncmn2

(モード m で有効な)オペランド1をモード n に切り詰め、結果を(モードが nの)オペランド 0 に格納する。両方のモードが固定小数点モードか、両方のモードが浮動小数点モードでなければならない。 

extendmn2

(モード m で有効な)オペランド1をモード n に符号拡張し、結果を(モードが nの)オペランド 0 に格納する。両方のモードが固定小数点モードか、両方のモードが浮動小数点モードでなければならない。 

zero_extendmn2

(モード m で有効な)オペランド1をモード n にゼロ拡張し、結果を(モードが nの)オペランド 0 に格納する。どちらのモードも固定小数点モードでなければならない。 

extv

オペランド 1(レジスタかメモリオペランド)からビットフィールドを抽出する。オペランド2 でビット幅を指定し、オペランド3で開始ビットを指定する。結果をオペランド 0 に格納する。オペランド 0 は、word_mode モードでなければならない。オペランド 1 は、byte_mode か word_mode である。word_mode はレジスタにしか許されないことが多い。オペランド 2 と 3 は、word_mode として有効でなくてはならない。
RTL 生成パスは、オペランド 2 とオペランド 3 が定数の場合しかこの命令を生成しない。

ビットフィールドの値は、オペランド 0 に格納される前に全語の整数に符号拡張される。 

extzv

extv との違いは、ビットフィールドの値がゼロ拡張される点である。 

insv

オペランド 3(word_mode として有効でなくてはならない)をオペランド 0 のビットフィールドに格納する。オペランド 1 でビット幅を指定し、オペランド 2 で開始ビットを指定する。オペランド 0 は、byte_mode か word_mode である。word_mode はレジスタにしか許されないことが多い。オペランド 1 と 2 は、word_mode として有効でなくてはならない。
RTL 生成パスは、オペランド 1 とオペランド 2 が定数の場合しかこの命令を生成しない。 

movmodecc

条件付きで、オペランド 2 またはオペランド 3 を、オペランド 1 に入っている比較にしたがって、オペランド 0 に移動する。比較が真ならオペランド 2 がオペランド 0 に移動され、偽ならオペランド 3 が移動される。
比較されるオペランドのモードは、移動されるオペランドのモードと同じである必要はない。例えば sparc64 のような機種には、浮動小数点の条件コードに基づいて整数を条件付きで移動したり、その逆を行なう命令がある。

条件付き移動命令を持たない機種では、このパターンは定義しないこと。 

scond

条件コードにしたがって、ゼロか非ゼロをオペランドに格納する。条件 cond が真なら格納される値は非ゼロである。cond は、比較演算式コードの名前で、例えば、eq、lt、leu 等がある。

match_operand 式を書くときにオペランドが持たなければならないモードを指定する。コンパイラはどのモードを使ったかを見て、自動的にそのモードのオペランドを提供する。

条件が真の場合に格納される値は、下位ビットが 1 か、あるいは負でなければならない。そうなっていないと、その命令は適切でないので、マシン記述から取り除くべきである。マクロ STORE_FLAG_VALUE (see Misc) を定義することで正確にはどの値がストアされるかということを GCC に対して指示する必要がある。全ての scond パターンに対して使用可能な指示が見つからない場合は、これらの演算をマシン記述から取り除くべきである。

これらの演算は失敗する可能性があるが、失敗して良いのは比較的珍しいケースだけである。整数の比較を含む良くあるケースで失敗することがあるなら、そういうパターンは取り除くのが良い。

そういう演算が取り除かれると、GNU CC は、定数 1 をターゲットにコピーし、そのターゲットにゼロを代入している付近に分岐する。このコードが、scond パターンで使われる潜在的な命令に、結果を SImode の 1 か ゼロに変換するのに必要な命令が続けたものより、効率が良いのなら、マシン記述から scond という演算を取り除くべきである。 

bcond

条件分岐命令。オペランド 0 は、ジャンプ先のラベルを参照するlabel_ref である。条件コードが条件 cond に一致した場合にジャンプする。

機種によっては、個々で想定した、比較命令の後には条件分岐命令が続くというモデルに従わないものもある。その場合、cmpm (と tstm) パターンでは、オペランドを単に格納しておき、条件分岐演算を表す define_expand (see Expander Definitions) で必要とされる全ての insn を生成すべきである。bcond パターンを展開する全ての呼び出しの直前には、cmpm パターンかtstm パターンを展開する呼び出しが置かれる。

条件コード値を表すのに疑似レジスタを使っていたり、比較に使われるモードがテストされる条件に依存する機種でも、やはり上記の方法を使うべきである。 See Jump Patterns.

上の議論は、movmodecc と scond のパターンにも当てはまる。 

call

値を返さないサブルーチン命令呼びだしである。オペランド 0 は呼び出すべき関数であり、オペランド 1 はconst_int としてスタックに積まれた引数のバイト数である。オペランド 2 はオペランドとして使われるレジスタの数である。

ほとんどのマシンでは、オペランド 2 は実際には RTL パターンには格納されない。この情報をアセンブラコードに置く必要のある、いくつかの RISC 機種のために提供されている。オペランド 1 の代わりに RTL に置くことができる。

オペランド 0 は、アドレスがその関数のアドレスである mem RTX であるべきである。だが、このアドレスは、ターゲット機種上での正当なメモリアドレスになっていなくても、symbol_ref になりうることに注意して欲しい。また、call 命令の正しい引数でない場合も、この演算用のパターンは、アドレスをレジスタに置き、そのレジスタをcall 命令で使うような define_expand (see Expander Definitions) になっている必要がある。 

call_value

値を返すサブルーチン呼び出し命令である。オペランド 0 は、値が返されるハードレジスタである。さらにオペランドが三つあり、それらは call 命令の三つのオペランドと同じである(オペランド番号は一ずつ増えている)。
BLKmode のオブジェクトを返すサブルーチンは call insn を使う。 

call_pop, call_value_pop

call や call_value と同様だが、定義されていて、かつ、RETURN_POPS_ARGS がゼロでない場合に使われる点が異なる。これらのパターンは、関数呼び出しとフレームポインタに対してなされた調整を表す set の両方を含む parallel を生成すべきである。

RETURN_POPS_ARGS がゼロでない値になりうる機種では、これらのパターンを使うと、望まれている場合には、フレームポインタを消去可能な関数の数が増えることになる。 

untyped_call

任意の型の値を返すサブルーチン呼びだし命令である。オペランド 0 が呼び出すべき関数、オペランド 1 が関数を呼び出した結果を格納すべきメモリ位置、オペランド 2 が parallel 式である。この parallel 式の各要素は、関数の戻り値を結果のブロックへセーブすることを示す set 式である。

この命令パターンは、任意個数の引数のサブルーチンを呼び出したり、戻り値をセーブするのに特別な命令を必要とするマシンで、__builtin_apply を動作させるために定義する必要がある。この命令パターンは、戻り値を保持できるレジスタが複数ある(すなわち、FUNCTION_VALUE_REGNO_P が二個以上のレジスタに対して真である)マシンで必要とされる。 

return

サブルーチンから戻る命令である。この命令パターン名は、一個の命令だけで、関数から戻る処理の全てを行なえる場合にのみ定義するべきである。

movm パターンと同様、このパターンも RTL 生成以後のフェーズでも使われる。その場合、関数から戻るのに通常複数の命令が必要だが、関数のクラスによっては、戻るのに命令を一個しか必要としないものもあるような機種を支援するためである。通常、利用可能な関数は、なんらレジスタをセーブしたり、スタック空間を割り当てたりする必要がないような関数になる。

このような機種については、このパターンで指定された条件は、reload_completed がゼロでなく、関数のエピローグがただ一つの命令になる場合にのみ真とならなければならない。レジスタウィンドウのある機種については、leaf_function_p ルーチンを使って、レジスタウィンドウのプッシュが必要かどうかを決定することができる。

条件付きリターン命令のある機種では以下のようにパターンを定義すべきである。

```
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator
                         0 "comparison_operator"
                         [(cc0) (const_int 0)])
                      (return)
                      (pc)))]
  "condition"
  "...")
```

ここで、condition は普通は、名前付き return パターンで指定されるのと同じ条件である。 

untyped_return

型指定なしのサブルーチンからの復帰命令。この命令パターンは、任意の型の値を返すのに特別な命令を必要とする機種では、__builtin_return をサポートするために定義すべきである。

オペランド 0 は、__builtin_apply により関数を呼び出した結果が格納されるメモリ位置である。オペランド 1 は、parallel 式であり、この式の各要素はその結果のブロックから関数の戻り値をリストアすることを指示する set 式である。 

nop

ノップ命令。この命令パターン名は常に定義する必要があり、アセンブラコードでノップを出力しなければならない。(const_int 0) は RTL パターンとしての役割を果たす。 

indirect_jump

オペランド 0 のアドレスにジャンプする命令。このパターンは全機種で必須である。 

casesi

ディスパッチテーブルを通してのジャンプ命令であり、範囲チェックを含む。この命令は次の5つのオペランドを取る。
ディスパッチ先のインデックス。モードは SImode である。

テーブルのインデックスの下限であり、整数定数である。
テーブルのインデックスの全範囲。最大のインデックスから最小のインデックスを引いたものである。最大、最小とも範囲に含まれるテーブル自身に先行するラベル。

インデックスの値が範囲外にあるときにジャンプすべきラベル。マシン記述マクロ CASE_DROPS_THROUGH が定義されていると、範囲外のインデックスの場合は、このラベルにジャンプする代わりに、ジャンプテーブルに続くコードにそのまま落ちて行く。その場合、このラベルは casesi 命令では実際には使われない。

このテーブルは、jump_insn の中の addr_vec かaddr_diff_vec である。このテーブルの要素数は、上限値と下限値の差に 1 を加えたものである。 

tablejump

可変アドレスにジャンプする命令。これは低レベルの機能であり、casesi パターンがない場合に分岐テーブルを実装するのに使うことが出来る。

このパターンにはオペランドが二つ必要である。アドレスまたはオフセット、それとジャンプ表の直前に置くべきラベルである。マクロCASE_VECTOR_PC_RELATIVE を評価した結果ゼロでない値になれば、最初のオペランドはその表のアドレスからのオフセットである。定義されていない場合は、ジャンプ先の絶対アドレスである。どちらの場合も、最初のオペランドのモードは Pmode である。

tablejump insn は、常に、それを使うジャンプ表の前にある最後のinsn になる。このアセンブラコードは普通は第二のオペランドを使う必要がないが、それを RTL パターンに取り込むことで 、ジャンプ最適化フェーズがその表を到達不能コードとして削除しないようにしなければならない。 

canonicalize_funcptr_for_compare

オペランド 1 にある関数ポインタを正規化し、その結果をオペランド 0 に格納する。
オペランド 0 は常に reg であり、モードは Pmode である。オペランド 1 は、reg、mem、symbol_ref、const_int 等であり、モードは Pmode である。

関数ポインタの正規化には、間接呼び出しの文脈で関数ポインタが使われた場合呼び出される関数のアドレスを計算することが通常含まれる。

ターゲット機種の関数ポインタが、間接の呼び出しに使われた場合、値は異なりうるが、呼び出す関数は同じという場合にだけ、このパターンを定義すること。 

save_stack_block

save_stack_function

save_stack_nonlocal

restore_stack_block

restore_stack_function

restore_stack_nonlocal

多くの機種には、モード Pmode のオブジェクトへコピーしたり、あるいはそのオブジェクトからコピーすることで、スタックポインタをセーブしたり、リストアする。そういう機種ではこれらのパターンを定義しないこと。

機種によっては、スタックポインタのセーブとリストアには特別な取扱いが必要なものもある。そういう機種では、非標準のケースに対応するパターンを、必要とされる insn を生成する define_expand (see Expander Definitions) を使って、定義する。セーブとリストアには以下の三つのタイプがある。

save_stack_block は可変長オブジェクトを割当要るブロックの開始点でのスタックポインタをセーブする。restore_stack_block はそのブロックを抜けた時点でスタックポインタをリストアする。

save_stack_function と restore_stack_function は、関数の最も外側のブロックに対して同様の処理を行ない、その関数が可変長オブジェクトを確保したり、alloca を呼び出したときに使われる。リストアされたスタックポインタを使うのはエピローグだけなので、機種によってはセーブやリストアの命令列が簡単になる。

save_stack_nonlocal は、ネストした関数から分岐してくるラベルを含む関数の中で使われる。これは、内側の関数がresotre_stack_nonlocal を使ってスタックポインタをリストアできるような方法で、スタックポインタをセーブする。GCC はフレームポインタと引数ポインタのレジスタをリストアするコードを生成するが、機種によっては、その他に、例えば、レジスタウィンドウ情報やスタックのバックチェーンのようなデータをセーブ、リストアする必要があるものがある。これらのパターンに insn を置いて、そういう必要なデータをセーブ、リストアする。

スタックポインタをセーブするときは、オペランド 0 がセーブ領域であり、オペランド 1 がスタックポインタである。セーブ領域を確保するのに使うモードはデフォルトでは VOIDmode になるが、マクロSTACK_SAVEAREA_MODE (see Storage Layout) を定義することで上書きできる。整数モードか、あるいは、特定のタイプのセーブの場合はセーブ領域がひつようでない場合はVOIDmode を指定しなければならない。リストアの場合は、オペランド 0 がスタックポインタで、オペランド 1 がセーブ領域である。save_stack_block が定義されているなら、オペランド 0 は VOIDmode であってはならない。こういうセーブは好きなだけ重ねられるからである。

セーブ領域は、スタックポインタが非局所 goto で使うためにセーブされるときは、ある mem であり、virtual_stack_vars_rtx から一定のオフセットにある。他の二つの場合は、reg である。 

allocate_stack

オペランド 1 をスタックポインタから減算(STACK_GROWS_DOWNWARD が定義されていれば加算)することで、動的に確保するデータ用のスペースを作る。
このスペースを指す、減算(あるいは加算)後のポインタをオペランド 0 に格納する。主スタックからスペースを割り当てているなら、これはvirtual_stack_dynamic_rtx をオペランド 0 にコピーする移動命令を生成することで行なうこと。その他の場所からスペースを割り当てている場合は、スペースのその位置をオペランド 0 にコピーするコードを生成すること。後者の場合、主スタック上の対応するスペースが解放された時に、このスペースが解放されることを保証しなければならない。

やらなければならないことがこの減算だけであるならこのパターンは定義しないこと。機種によっては、その他の、スタック探針やバックチェーンの維持等の操作を必要とするものがある。その場合には、このパターンで、スタックポインタの更新に加えてそれらの操作を生成するように定義する。 

probe

機種によっては、スタックからスペースを割り当てた後に実行すべき命令を必要とする場合がある。例えば、スタックの基底への参照を生成するためである。

スタックの調整が完了するまえに命令群を出す必要があるなら、その命令群を allocate_stack パターンに入れるようにする。その必要がなければ、probe パターンが必要な命令を出すように定義する。

オペランドはない。 

check_stack

スタック検査を行なうのに、ロード命令あるいはストア命令を使ってスタックを探査する方法(see Stack Checking)が使えないシステムでは、このパターンを定義して、必要な検査を行ない、スタックがオーバーフローしたなら、エラーを発するようにする。オペランドは一つで、検査する必要のある現在のスタックポインタから最も遠いスタック上の位置である。このパターンが必要な機種では、普通、スタックの限界は、グローバルまたスレッド固有である、変数またはレジスタから得ることになる。 

nonlocal_goto

非局所 goto すなわち、ある関数から外側の関数中のラベルへのジャンプを生成するコードを出す。このパターンには引数が四つあり、それぞれがジャンプで使われる値を表す。先頭の引数は、フレームポインタにロードされる、二番目の引数は、分岐先アドレス(実際のラベルへディスパッチするコード)である。三番目は、スタックがセーブされる位置のアドレスであり、最後の引数は、ラベルのアドレスであり、入力静的連鎖の位置に置かれるものである。

ほとんどの機種ではこのパターンを定義する必要がない。GNU CC が既に正しいコードを生成しているからである。この正しいコードでは、フレームポインタと静的連鎖をロードし、スタックをリストアし(定義されていれば restore_stack_nonlocal パターンを使って)、ディスパッチ部へ間接的にジャンプする。このコードでは正しく動作しない機種の場合だけ、このパターンを自分で定義する必要がある。 

nonlocal_goto_receiver

このパターンは、定義されていれば、非局所 goto の飛び先に GNU CC が生成済みのコードの後で必要なコードが入っている。普通はこのパターンを定義する必要はない。このパターンが必要な理由の典型的なものは、ある値、例えばグローバルな表へのポインタのようなものが、フレームポインタがリストアされたときにリストアされなくてはならない場合である。非局所 goto は翻訳単位内でしか起こらないので、指定されたモジュールの全ての関数により共有されるグローバル・テーブル・ポインタをリストアする必要はない。引数はない。 

exception_receiver

このパターンは、定義されていれば、非局所 goto の位置には必要ないが、例外ハンドラの位置では必要とされるコードが入っている。普通はこのパターンを定義する必要はない。このパターンが必要な理由の典型的なものは、ある値、例えばグローバルな表へのポインタのようなものが、制御の流れが例外ハンドラに分岐した後でリストアされなくてはならない場合である。引数はない。 

builtin_setjmp_setup

このパターンは、定義されていれば、jmp_buf を初期化するのに必要な追加のコードを保持している。普通は、このパターンを定義する必要はない。このパターンが必要になる代表的な理由としては、何かの値、例えばグローバル変数テーブルへのポインタのような値がリストアする必要がある場合である。そのようなポインタ値は可能な限り(例えばラベルのアドレスが与えられているような場合)再計算するのが望ましいのではあるが。引数は一つであり、jmp_buf へのポインタである。このバッファは 5語長であり、最初の 3語分は普通は汎用的な機構が使うことに注意。 

builtin_setjmp_receiver

このパターンは、定義されていれば、非局所 goto の位置には必要ないが、組み込みの setjmp の位置では必要とされるコードが入っている。普通はこのパターンを定義する必要はない。このパターンが必要な理由の典型的なものは、ある値、例えばグローバルな表へのポインタのようなものが、リストアされなくてはならない場合である。これは引数を一つ取る。それは制御を渡してきた builtin_longjmp に付くラベルである。このパターンはそのラベルから小さなオフセット分だけ後に生成される。 

builtin_longjmp

このパターンは、定義されていれば、longjmp の全動作を実行する。builtin_setjmp_setup も定義しているのでない限り、普通はこのパターンを定義する必要はない。引数は一個で、jmp_buf へのポインタである。 

eh_epilogue

このパターンは、__builtin_eh_return、それに伴って __throw の構築方法に影響を与える。例外処理機構とそのターゲット向けの通常のエピローグコードとの間の通信を可能にすることを意図している。

このパターンには引数が三つある。一番目は、例外今テキストポインタである。これは、ポインタに適した関数戻りレジスタに既にコピーされているであろう。普通はこれを無視出来る。二番目の引数は、スタックポインタに加算すべきオフセットである。これはある勝手な呼出し時破壊ハードレジスタにコピーされるので、再ロード後、通常のエピローグが生成される間での間生き残る。三番目の引数は、この関数が戻るべき例外ハンドラのアドレスである。これは通常、このパターンによりある特別なレジスタにコピーされる必要がある。

このパターンは、もし RETURN_ADDR_RTX が、何か信頼性があり永久的な修正が可能であるもの、例えば固定ハードレジスタやスタックメモリ参照のようなものを生み出さない場合は、定義しなければならない。 


prologue

このパターンが定義されていると、関数の入り口点に対する RTL を生成する。関数の入り口点には、スタックフレームの設定、フレームポインタレジスタの初期化、被呼出し側セーブレジスタのセーブ等の役割がある。
prologue パターンの方が、FUNCTION_PROLOGUE を定義するよりも、プロローグ用アセンブリ・コードを生成する方法として一般に望ましい。

prologue パターンは、命令スケジューリングを行うターゲットには特に有効である。 

epilogue

このパターンが定義されていると、関数の出口点に対する RTL を生成する。関数の出口点には、スタックフレームの解放、被呼出し側セーブレジスタのリストア、リターン命令の生成等の役割がある。
epilogue パターンの方が、FUNCTION_EPILOGUE を定義するよりも、エピローグ用アセンブリ・コードを生成する方法として一般に望ましい。

prologue パターンは、命令スケジューリングを行ったり、リターン命令に遅延スロットが伴うターゲットには特に有効である。 

sibcall_epilogue

このパターンが定義されていると、最終的に呼出し元関数へ分岐して戻らない関数の出口点に対する RTL を生成する。このパターンは、任意の同族呼出し(別名末尾呼出し)位置の前に生成される。

sibcall_epilogue パターンは、パラメータの受渡しに使われる引数や現在の関数に渡された引数用のスタックスロットはどれも破壊してはならない。

##パターンの順序が問題になる時

ある insn が複数の命令パターンにマッチ可能なことが時々ある。その時は、マシン記述に最初に現れるパターンが使われる。このため、より限定されるパターン(マッチするものがより少ないパターン)やより高速のパターン(マッチしたときにより良いコードを生成するパターン)を通常はマシン記述で先に置くべきである。

場合によっては、パターンの順番の効果を使って、有効でないパターンを隠すこともできる。例えば、68000 は、フルワードを浮動小数点に変換する命令ともう一つ別のバイトを浮動小数点に変換する命令を持っている。整数を浮動小数点に変換する命令はどちらにもマッチし得る。我々は、フルワードを変換するパターンを先において、バイトを変換するパターンではなくてフルワードを変換する方が使われることを保証している。(そうしないと、大きな整数が一バイトの即値量として生成されてしまい、動作しなくなる。) このパターンの順序を使う代わりに、バイトを変換するパターンを任意の定数値を適切に扱えるように賢いものにすることも可能である。

##パターン間の依存関係

どのマシン記述でも、条件分岐名 bcond のそれぞれについて名前付きパターンがなければならない。この場合、許されるテンプレートは常に以下の形でなければならない。

```
(set (pc)
     (if_then_else (cond (cc0) (const_int 0))
                   (label_ref (match_operand 0 "" ""))
                   (pc)))
```

さらに、どのマシン記述でも、条件を逆にした分岐毎に名無しのパターンがなければならない。テンプレートは以下の形となる。

```
(set (pc)
     (if_then_else (cond (cc0) (const_int 0))
                   (pc)
                   (label_ref (match_operand 0 "" ""))))
```

これらが必要なのは、ジャンプ最適化で順条件分岐が逆条件分岐に変換されることがあるためである。

match_operator を使って、分岐に対し指定しなければならないパターンの数を押さえるということを良く行なう。例えば、以下のようにする。

```
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator 0 "comparison_operator"
                                      [(cc0) (const_int 0)])
                      (pc)
                      (label_ref (match_operand 1 "" ""))))]
  "condition"
  "...")
```

場合によっては、一個以上のオペランドのマシンモードを除けば同じになる命令をサポートしている機種がある。例えば、"sign-extend halfword" と "sign-extend byte" という命令があり、そのパターンは以下のようになる。

```
(set (match_operand:SI 0 ...)
     (extend:SI (match_operand:HI 1 ...)))

(set (match_operand:SI 0 ...)
     (extend:SI (match_operand:QI 1 ...)))
```

整数定数はマシンモードを指定しないので、定数値を拡張する命令はどちらのパターンにもマッチし得る。実際にマッチするパターンは、ファイルで先に現れたものになる。正しい結果を得るためには、先に置くのは最も幅の広いモード(ここではHImode) のものでなければならない。パターンが QImode の命令にマッチした場合、定数値がこのモードに実際に収まらない場合は正しくない結果になる。

定数を拡張するような命令は最適化の際になくなるので、滅多に生成されることはないが、最適化をしないコンパイルでは時々出てくる。

あるパターンのある制約が定数を許すなら、再ロードパスが、いくつかのケースの制約で許されているなら、レジスタを定数で置き換える可能性がある。メモリ参照についても同様である。この置き換えがあるので、インクリメントとデクリメント命令に別々のパターンを与えるべきではない。代わりに、同一のパターンから生成されるようにする必要がある。このパターンは、オペランドを調べて適切な機械命令を生成するようなレジスタ同士の加算 insn をサポートする必要がある。

##ジャンプ命令のパターンを定義する

ほとんどの機種について、GNU CC は、その機種に条件コードがあることを想定している。比較 insn が条件コードを設定し、与えられたオペランドについての、符号付き比較と符号なし比較の両方の結果を記録する。それとは別の分岐 insn が、条件コードをテストし、その値にしたがって分岐したり、しなかったりする。分岐 insn は、符号付きと符号無しでは違ってくる。良く知られた機種、例えば、Vax や 68000、32000 等はこのように動作する。

機種によっては、符号付きと符号なしで別の比較命令を持っているが、条件分岐命令は、どちらか一方向けのセットしかないというものがある。こういう機種を扱うのに一番簡単な方法は、アセンブリコードが書き出される最後の段階までは、それ以外の機種と全く同じように扱うことである。この最後の段階で、比較命令用のコードを出力するときに、next_cc0_user (insn) を使って後続の分岐を先読みするのである。(変数 insn は、ある命令パターンの出力を書き出すコードの中では、出力中の insn を参照している。) その RTL を見て、符号なし分岐であれば、符号なし比較を出力し、さもなければ符号付き比較を出力する。その分岐自体を出力するときは、符号付き分岐と符号なし分岐を全く同一に扱うことができる。

こんなことが可能なのは、GNU CC が連続する RTL insn の対を生成するからである。間に note insn が入ってもよい。この対の一つは、条件コードを設定し、もう一つがそれをテストする。GNU CC は、この対を最後までいじらないようにする。

この方法を取るには、マシン記述マクロ NOTICE_UPDATE_CC をCC_STATUS_INIT を実行するように定義しなければならない。言い換えると、余計な比較命令はない。

機種によっては比較-分岐命令はあるが、条件コードはないというものがある。こういう機種についても同様の方法が使える。比較命令を「出力」すべき時が来たら、そのオペランドを二つの静的変数に記録する。次に続く「条件コードにより分岐」命令を出力するときは、実際には記録したオペランドを使う、比較-分岐命令を出力する。

比較-分岐命令向けにパターンを定義するのでも良い。最適化ありのコンパイルでは、比較命令と分岐命令の組をこのパターンに従って組み合わせる。だが、これは最適化を要求しない場合は行なわれない。このため、読者が定義するなんらかの特別なパターンに加えて、上記の解決策の一つを取る必要がある。

RISC 機種の多くでは、条件コードに影響する命令はほとんどなく、独立した条件コードレジスタさえないこともある。こういう機種では、条件コードの定義と使用は連続した insn でなければならないという制限は必要ないし、重要な最適化を妨げてしまう。例えば、IBM RS/6000 では、条件コードレジスタが条件分岐の三つ前の命令で設定されていない限り、成立した分岐に対して遅延が生じる。条件コードレジスタの定義と使い方を分離することが許されていないと、命令スケジューラは、この最適化を行なうことができない。

こういう機種では、(cc0) を使わず、代わりに条件コードを表すレジスタを使うこと。専用の条件コードレジスタが存在する場合には、ハードレジスタを使うこと。条件コードや比較の結果をどの汎用レジスタにでも置くことが出来るのなら、あるいは条件コードレジスタが複数あるなら、疑似レジスタを使うこと。

機種によっては、生成される分岐命令のタイプは条件コードの生成のされ方に依存する。例えば、68k と SPARC では、加算命令や減算命令で直接的に条件コードを設定すると、テスト命令が行なうような、オーバフロービットのクリアを行なわないので、ある種の条件分岐に対しては異なる分岐命令を使う必要がある。(cc0) を使う機種では、条件コードの設定と使用は、連続して置かなければならず(間に置いて良いのは note insn だけ)、cc_status 中のフラグを使えるようにしなければならない。(See Condition Code。) また、比較 insn と分岐 insn は、関数 prev_cc0_setter とnext_cc0_user によってお互いを見つけることができる。

だが、(cc0) を使わない機種ではこの事は正しくない。(cc0) を使わない機種では、比較 insn と分岐 insn が連続しているという仮定を置くことは出来ず、上記の方法は使えない。代わりに、条件コードレジスタのマシンモードを使って、条件コードレジスタの異なる形式を記録するようにする。

条件コードの値をストアするのに使うレジスタのモードは、クラス MODE_CC のモードでなければならない。普通は、CCmode になる。他にモードが必要になる場合は(上で述べた、Sparc の add の例について言えば)、マクロ EXTRA_CC_MODES を定義して、追加で必要なモードを列挙する(see Condition Code)。また、EXTRA_CC_NAMES を定義して、追加するモードの名前を列挙し、SELECT_CC_MODE を定義して、比較のオペランドに与えられたモードを選択するようにする。

RTL 生成の間、異なるモードが必要な事が判っている場合(例えば、IBM のほとんどのプロセッサのように、符号付きと符号なしで別々の比較命令を持っている機種の場合である)、RTL 生成時に指定することができる。

異なるモードが要求されるのが、命令組合せにより発生する場合は、マクロ SELECT_CC_MODE が比較の結果に対してどのマシンモードを使うべきかを決定する。そのパターンはこのモードを使って書く必要がある。上で議論した SPARC での加算の場合を考えると、パターンを以下のようにする必要がある。

```
(define_insn ""
  [(set (reg:CC_NOOV 0)
        (compare:CC_NOOV
          (plus:SI (match_operand:SI 0 "register_operand" "%r")
                   (match_operand:SI 1 "arith_operand" "rI"))
          (const_int 0)))]
  ""
  "...")
```

SPARC での SELECT_CC_MODE マクロは、引数が plus である比較に対しては CC_NOOVmode を返す。

##命令の正規化

複数の RTL 式がある一個の機械命令で実行される演算を表す場合が良くある。これは、論理命令、分岐命令、積和命令で良くあることである。そういう場合、コンパイラは複数の RTL 式を一個の正規形に変換して、必要とする insn パターンの数を減らそうとする。

代数的な単純化に加えて、以下の正規化が行なわれる。

交換可能な比較演算の場合、定数は常に第二オペランドとなる。定数を第二オペランドでしか使えない機種では、第二オペランドに定数がくるパターンだけを提供すれば良い。
以下の演算については、一方のオペランドだけが neg、not、mult、plus、minus 式の場合、それは第一のオペランドになる。

compare 演算子の場合、cc0 が使われる機種(see Jump Patterns) では、定数は常に第二オペランドになる。それ以外の機種では、定数を第一オペランドとする compare をコンパイラが作ろうとする場合が希にある。だが、そういう場合は、実際にそういう機械命令がない限り、第一オペランドとして定数にマッチするパターンを用意する価値があるほど多くはない。
neg、not、mult、plus、minus のオペランドは、上と同じ条件下で第一オペランドになる。

(minus x (const_int n)) は(plus x (const_int -n)) に変換される。
アドレスの計算の中で(すなわち、mem の中で)、左シフトは適当な 2 の冪乗の乗算に変換される。
ド・モルガンの法則を使って、ビット毎の論理積や論理和の中にあるビット毎の否定を移動する。この結果、一個のオペランドだけがnot 式になった場合、それが先頭のオペランドになる。
一つのオペランドと、もう一方のオペランドのビット毎の否定のビット毎の論理積を実行する命令がある機種では、その命令用のパターンは以下のように指定すべきである。

```
(define_insn ""
  [(set (match_operand:m 0 ...)
        (and:m (not:m (match_operand:m 1 ...))
                     (match_operand:m 2 ...)))]
  "..."
  "...")
```

同様に、"NAND" 命令用のパターンは以下のように書くべきである。

```
(define_insn ""
  [(set (match_operand:m 0 ...)
        (ior:m (not:m (match_operand:m 1 ...))
                     (not:m (match_operand:m 2 ...))))]
  "..."
  "...")
```

どちらの場合にも、たくさんある論理的に等価な RTL 式に対するパターンを含める必要はない。

* ビット毎の排他的論理和とビット毎の否定を両方含む RTL 式で可能なものは、(xor:m x y) と(not:m (xor:m x y)) だけである。
* 三項の和で、その一つが定数であるものは、次の形にしか現れない。

```
(plus:m (plus:m x y) constant)
``
* cc0 を使わない機種では、(compare x (const_int 0)) はx に変換される。
* あるグループのビット(普通は一個のビット)がゼロに等しいかどうかの比較は、等価な and や sign_extract 演算ではなくて、zero_extract を使って書かれる。

##機種固有の覗き穴最適化

命令パターンに加えて、ファイル md には、機種固有の覗き穴最適化の定義を書いても良い。

組合せフェーズが、特定の覗き穴最適化に気付かないときがある。それはどういう時かというと、プログラムのデータの流れを見ても、その覗き穴最適化を試すべきであるということが判らない時である。例えば、二つの連続する insn の目的が関係している場合は、二番目の insn が最初の insn で計算したレジスタを使わないように見える場合でも、組合せが行なえることがある。機種固有の覗き穴最適化器はそのような機会を検出する。

```
A definition looks like this:

(define_peephole
  [insn-pattern-1
   insn-pattern-2
   ...]
  "condition"
  "template"
  "optional insn-attributes")
```

最後の文字列オペランドは、マシン記述で機種固有の情報をなんら使っていないのなら、省略可能である。省略しない場合は、define_insn と同じ規則に従わなければならない。

このスケルトンでは、insn-pattern-1 等は連続する insn のマッチすべきパターンである。insn-pattern-1 が insn 列の先頭のものに、insn-pattern-2 がその次に、という具合にマッチするなら、その insn 列に最適化が適用される。

覗き穴によりマッチする各 insn は define_insn にもマッチしなければならない。覗き穴はコード生成の直前の最終段階でしか検査されない。このため、覗き穴にはマッチするものの define_insn にはマッチしないinsn は、最適化を行なわないコンパイルの場合のコード生成で、あるいは色々な最適化の段階で、異常終了を引き起こす。

insn のオペランドは、通常同様、match_operands や match_operator、match_dup にマッチする。通常と違うのは、オペランド番号が定義の中にある全ての insn パターンに適用されるという点である。このため、二つの insn にある同じオペランドを検査するのに、片方の insn では match_operand を、もう一方ではmatch_dup を使うことができる。

match_operand パターンで使われるオペランド制約は、覗き穴が適用されるかどうかについては、なんら直接的な効果は持たない。だが、後で検証されるので、この制約は、覗き穴がマッチするときはいつでも適用できるぐらい一般的なものになっていることを確認して欲しい。覗き穴にはマッチするが、制約が満たされない場合は、コンパイラが落ちるだろう。

覗き穴最適化の場合は、全てのオペランドの制約を省略しても安全である。あるいは、制約を書いて、既にテスト済みの規準を二重に検査することにしても良い。

ある insn の列がそのパターンに一度一致すると、condition が検査される。condition は一個の C の式であり、この最適化を実行するかどうかを最終的に決定する(この式がゼロでなければ最適化を行なう)。condition が指定されていないと(言い換えると、文字列が空の場合)、この最適化はそのパターンに一致する、あらゆる insn の列に適用される。

定義された覗き穴最適化はレジスタ割当が完了した後に適用される。このため、このため、覗き穴最適化の定義では、どのオペランドが最終的にどの種類のレジスタに割り当てられたかを、単にそのオペランドを見ることで調べることができる。

condition でオペランドを参照するには、オペランド番号が i なら operands[i] と書く((match_operand i ...) によりマッチする)。マッチしつつある insn 群の最後のものを参照するには変数 insn を使う。先行する insn 群を見つけるにはprev_active_insn を使う。

中間結果の計算を最適化するときは、condition を使って、その中間結果が他の場所で使われない時にのみ一致させることができる。C の式 dead_or_set_p (insn, op) を使うこと。ここで、insn は、最後に使われると想定している値が入っている insn である(insn の値から、prev_nonnote_insn を組み合わせて得られる)。op は、中間結果である(operands[i] から得られる)。

最適化を適用するということは、insn 列を一個の新たな insn で置き換えるということを意味する。template が、この組み合わされたinsn のアセンブラコードの最終的な出力を制御する。template は、define_insn のテンプレートと全く同じように動作する。このテンプレートのオペランド番号は、元の insn 列とマッチするのに使われたのと同じ番号である。

定義した覗き穴最適化の結果は、マシン記述の insn パターンのどれにもマッチする必要はない。実は一致する機会すらないのである。覗き穴最適化の定義は、それ自身が insn がどのように出力されるかを制御する insn のパターンとして働く。

定義された覗き穴最適化はアセンブラコードが出力されるときに実行されるので、生成される insn はどんな方法でも組み合わされたり、並べ替えられたりすることはない。

以下の例は、68000 のマシン記述から取ったものである。

```
(define_peephole
  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
   (set (match_operand:DF 0 "register_operand" "=f")
        (match_operand:DF 1 "register_operand" "ad"))]
  "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
  "*
{
  rtx xoperands[2];
  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);
#ifdef MOTOROLA
  output_asm_insn (\"move.l %1,(sp)\", xoperands);
  output_asm_insn (\"move.l %1,-(sp)\", operands);
  return \"fmove.d (sp)+,%0\";
#else
  output_asm_insn (\"movel %1,sp@\", xoperands);
  output_asm_insn (\"movel %1,sp@-\", operands);
  return \"fmoved sp@+,%0\";
#endif
}
")
```

この最適化により

```
jbsr _foobar
addql #4,sp
movel d1,sp@-
movel d0,sp@-
fmoved sp@+,fp0
```
が、以下のようになる。

```
jbsr _foobar
movel d1,sp@
movel d0,sp@-
fmoved sp@+,fp0
```

insn-pattern-1 等は、ほぼ define_insn の第二オペランドに同じである。重要な違いが一つある。define_insn の第二オペランドは、鍵括弧で囲まれた一つ以上のRTX からなる。普通は一つだけである。その場合、同じ動作を define_peephole の要素として書くことができる。しかし、define_insn に複数の動作があるときは、暗黙のうちにparallel で囲まれる。その場合、define_peephole では、parallel とその中に鍵括弧を明示的に書かなければならない。こうして、ある insn パターンが

```
(define_insn "divmodsi4"
  [(set (match_operand:SI 0 "general_operand" "=d")
        (div:SI (match_operand:SI 1 "general_operand" "0")
                (match_operand:SI 2 "general_operand" "dmsK")))
   (set (match_operand:SI 3 "general_operand" "=d")
        (mod:SI (match_dup 1) (match_dup 2)))]
  "TARGET_68020"
  "divsl%.l %2,%3:%0")
```

のようになっていたとすると、この insn を覗き穴に書くには以下のようにする。

```
(define_peephole
  [...
   (parallel
    [(set (match_operand:SI 0 "general_operand" "=d")
          (div:SI (match_operand:SI 1 "general_operand" "0")
                  (match_operand:SI 2 "general_operand" "dmsK")))
     (set (match_operand:SI 3 "general_operand" "=d")
          (mod:SI (match_dup 1) (match_dup 2)))])
   ...]
  ...)
```

##コード生成のための RTL 列の定義

機種によっては、RTL 生成用の標準のパターン名を一個の insn では扱えないが、RTL insn の列なら表現できるという場合がある。そのようなターゲット機種の場合は、define_expand を書くことでその RTL 列を生成する方法を指定することができる。

define_expand は、ある一個の RTL 式であり、ほぼ define_insn と同じである。しかし、define_expand は、define_insn と違って、RTL 生成にのみ使われ、一個以上の RTL insn を生成することができる。

define_expand RTX にはオペランドが4つある。

* 名前。各 define_expand には名前がなければならない。何故なら、名前で参照するのが唯一の使い方だからである。
* RTL テンプレート。これは、ちょうど define_peephole のRTL テンプレートと同じであり、それぞれが一個の insn であるRTL 式のベクトルになっている。
* 条件。C の式を一個含む一個の文字列である。この式を使って、このパターンの利用可能性がどのようにターゲット機種のサブクラスに依存するかを表す。このサブクラスは、GNU CC の実行時にコマンド行オプションにより選択されるものである。これは、標準名を持つ define_insn の条件と同じである。このため、条件がもしあるなら、一致する insn 中のデータに依存してはならない。ターゲット機種タイプのフラグにしか依存してはならないのである。GNU CC は、初期化を行なっている際にこれらの条件をテストする必要がある。これは、コンパイラの一回実行する毎に、名前付き命令で利用可能なものはどれかを正確に知る必要があるからである。
* 準備文。一個の文字列であり、ゼロ個以上の C の文を含む。これらの文は、RTL テンプレートから RTL コードが生成される前に実行される。
普通これらの文は、RTL テンプレート中の内部的なオペランドとして使われる一時レジスタを用意するが、emit_insn 等のルーチンを呼び出すことで RTL insn を直接生成することもできる。そうやって生成した insn は、RTL テンプレートから来る insn の前に置かなければならない。

define_expand により生成されるRTL insn はどれも、マシン記述中のdefine_insn のどれかにマッチしなければならない。どれにもマッチしない場合、その insn 用のコードを生成しようとしたり、最適化しようとしたときに異常終了してしまう。

RTL テンプレートは、RTL insn の生成を制御することに加えて、このパターンが使われるときに指定する必要があるオペランドをも記述する。特に、各オペランドに述語を与える。

真のオペランドは、パターンから RTL を生成するために指定する必要があり、RTL テンプレートの先頭に現れる match_operand で記述する必要がある。これにより、オペランドの述語についての情報が、その手の情報を記録する表に入力される。GNU CC はこの情報を使って、正しい RTL コードとして必要なら、オペランドをレジスタに事前ロードする。このオペランドが複数回参照されているなら、それ以降で参照するときはmatch_dup を使う必要がある。

RTL テンプレートは、内部「オペランド」も参照する。内部オペランドとは、一時レジスタやラベルであり、define_expand で作られる列の中でしか使われない。内部オペランドは、match_dup により RTL テンプレートに代入される。match_operand で代入されることはない。内部オペランドの値は、GNU CC がこのパターンを使う必要があるときに引数として渡されることはない。代わりに、準備文により、パターン内で計算が行なわれる。準備文は、値を計算し、operands の適切な要素に格納するので、match_dup がそれを見つけられるようになる。

準備文の中で使う特別なマクロが二つ定義されている。DONE と FAIL である。これらは後ろにセミコロンを付けて文として使うこと。


DONE

マクロ DONE を使って、このパターンに対する RTL 生成を終了させる。この時にパターンから作られる RTL insn は、準備文の中で emit_insn を明示的に呼び出すことによって既に出力済みのものだけになる。RTL テンプレートは生成されない。 

FAIL

パターンに対する照合を失敗させる。あるパターンが照合に失敗すると、そのパターンが利用できないことを意味する。GNU CC の呼びだし側ルーチンは、他のパターンを使って、コード生成の別の戦略を試す。
失敗は、現在、二項演算(加算、乗算、シフト等)とビットフィールド演算(extv、extzv、insv)でのみ使える。

次の例は、SPUR チップの左シフトの定義である。

```
(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (ashift:SI
          (match_operand:SI 1 "register_operand" "")
          (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "
{
  if (GET_CODE (operands[2]) != CONST_INT
      || (unsigned) INTVAL (operands[2]) > 3)
    FAIL;
}")
```

この例では、define_expand を使って、シフト量がサポート範囲の 0 から 3 の間に収まっていればシフトを行なうRTL insn を生成することができるようにしているが、機械命令が使えないようなそれ以外の場合には失敗するようにしている。失敗した場合には、別のパターン(例えば、ライブラリ呼びだしなど)を使った別の戦略を試みる。

GNU CC が、名前付きパターンの自明でない条件文字列を扱うことが出来たなら、define_insn をその場合に使うことができる。以下に、define_expand の威力をさらに利用する別の例(68000 でのゼロ拡張である)を示す。

```
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "")
        (const_int 0))
   (set (strict_low_part
          (subreg:HI
            (match_dup 0)
            0))
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "operands[1] = make_safe_from (operands[1], operands[0]);")
```

ここでは二つの RTL insn が生成される。一つは出力オペランド全体をクリアし、もう一つは入力オペランドを出力オペランドの下位半分にコピーする。この insn 列は、入力オペランドが出力オペランド(の古い値)を参照している場合は、正しくなくなる。そのため、準備文でそうならないことを保証している。関数 make_safe_from は、operands[1] がoperands[0] を参照していれば、operands[1] を一時レジスタにコピーする。そのコピーは、もう一つの RTL insn を生成することにより行なう。

最後に、三番目の例で内部オペランドの使い方を説明する。SPUR チップのゼロ拡張は、結果を半語のマスクとの and を取ることで行なわれる。だが、このマスクは、定数値としては、この機種で正しいものになるには大きすぎて、const_int では表現できない。このため、force_reg でレジスタにコピーして、そのレジスタを and の中で使わなければならない。

```
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
        (and:SI (subreg:SI
                  (match_operand:HI 1 "register_operand" "")
                  0)
                (match_dup 2)))]
  ""
  "operands[2]
     = force_reg (SImode, GEN_INT (65535)); ")
```

注意: define_expand を標準的な二項演算や単項演算、あるいはビットフィールド演算に使うときは、それが最後に生成する insn は、code_label や barrier や note であってはならない。insn か jump_insn か call_insn でなくてはならない。最後に実際の insn を置く必要がなければ、演算の結果を自分自身にコピーするinsn を生成する。そういう insn はコードはなんら生成しないが、GCC に問題が起きるのを回避する。

##命令の分割方法を定義する

あるパターンを複数の insn に分割する方法を指定しなければならない場合が二つある。遅延スロット(see Delay Slots)を必要とする命令や出力が複数サイクルの間利用できない命令(see Function Units)を持つ機種では、これらのケースを最適化するコンパイラフェーズでは、insn を一つの命令の遅延スロットに移動できる必要がある。しかし、insn の中には複数の機械命令を生成するものもある。そういう insn は遅延スロットに置くことはできない。

一個の insn を個々の insn のリストに書き直せることが多い。この場合、個々の insn はそれぞれ一個の機械命令に対応する。こうすると不利な点は、コンパイルが遅くなり、必要とするメモリスペースが多くなることである。書き換え後の insn が複雑過ぎると、そのためにいくつかの最適化を妨げることにもなる。命令スケジューリングまたは遅延スロットスケジューリングが改善されると信じる根拠がある場合は、コンパイラは insn を分割する。

insn の組合せフェーズでは、交換可能な insn の分割も行なう。三つの insn が複雑な式の一つの insn に統合されたものの、なんらかの define_insn パターンにマッチすることが不可能になった場合、組合せフェーズは複雑なパターンを認識できる二つの insn に分割しようとする。普通は、複雑なパターンをいくつかの部分式に分割することで二つのパターンに分ける。だが、場合によっては、RISC 機種で、ある大きな定数の加算を二つの insn で行なうような場合、その加算を二つの insn に分割する方法は機種依存である。

define_split の定義で、GNU CC に対し、複雑な insn をいくつかのもっと単純な insn に分割する方法を指定する。

```
(define_split
  [insn-pattern]
  "condition"
  [new-insn-pattern-1
   new-insn-pattern-2
   ...]
  "preparation statements")
```

insn-pattern は、分割する必要のあるパターンであり、condtion は define_insn の場合と同様、最後にテストされる条件である。insn-pattern にマッチし、condition を満たす insn が見つかると、その insn は、insn のリストの中で、new-insn-pattern-1、new-insn-pattern-2 等で与えられるinsn に置き換えられる。

preparation statements は、define_expand ( see Expander Definitions)で指定される文と同様のもので、生成されるコードの準備をしたり、パターンが固定していない insn をいくつか生成したりするために、新しい RTL が生成される前に実行される。ただし、define_expand にあるものと違って、これらの文は疑似レジスタを新たに生成してはならない。また、再ロードが一度完了したら、スタックフレームからスペースを割り当ててはならない。

パターンが insn-pattern とマッチするのには、二つの異なる状況がある。ある insn が遅延スロットスケジューリングや命令スケジューリング向けに分割する必要がある場合は、その insn は有効であることが既に知られている。この事は、何かの define_insn にマッチしていなければならず、reload_completed がゼロでなければ、その define_insn の制約を満たすことが知られているということを意味する。その場合、新しい insn パターンも何かの define_insn にマッチしなければならず、reload_completed がゼロでなければ、その定義の制約を満たさなければならない。

この define_split の使い方の例として、a29k.md から取った以下の例を考えてみる。この例では、HImode から SImode への sign_extend を二つのシフト insn の対に分割している。

```
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
  ""
  [(set (match_dup 0)
        (ashift:SI (match_dup 1)
                   (const_int 16)))
   (set (match_dup 0)
        (ashiftrt:SI (match_dup 0)
                     (const_int 16)))]
  "
{ operands[1] = gen_lowpart (SImode, operands[1]); }")
```

命令組合せ過程が insn パターンを分割しようとするのは、いつでも、そのパターンがどの define_insn にもマッチしない場合である。組合せ過程は、最初に一個の set 式を分割しようとし、次に parallel の中にあるが、スクラッチレジスタとして使うための疑似レジスタの clobber が後ろに続くような、同じ set 式を分割する。これらの場合、組合せ過程は、新しい insn パターンがちょうど二つ生成されることを想定する。組合せ過程がこれらのパターンがなんらかの define_insn による定義にマッチするかどうかを検査するので、読者が自分で define_split の中でこの検査を行なう必要はない(当たり前だが、マッチする insn を決して生成しないように define_split を書くのは意味がない)。

以下に define_split のこの使い方の例を示す。rs6000.md から取ったものである。

```
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                 (match_operand:SI 2 "non_add_cint_operand" "")))]
  ""
  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
"
{
  int low = INTVAL (operands[2]) & 0xffff;
  int high = (unsigned) INTVAL (operands[2]) >> 16;

  if (low & 0x8000)
    high++, low |= 0xffff0000;

  operands[3] = GEN_INT (high << 16);
  operands[4] = GEN_INT (low);
}")
```

ここで述語 non_add_cint_operand は、一個の加算 insn の有効なオペランドではない const_int にマッチする。小さな変位付きの加算は、次の演算のアドレスに代入できるように書かれる。

同じファイルから、スクラッチレジスタの使い方の例を見てみる。この例では、レジスタと大きな定数の等値性比較を生成している。

```
(define_split
  [(set (match_operand:CC 0 "cc_reg_operand" "")
        (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                    (match_operand:SI 2 "non_short_cint_operand" "")))
   (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
  "find_single_use (operands[0], insn, 0)
   && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
       || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
  [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
   (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
  "
{
  /* Get the constant we are comparing against, C, and see what it
     looks like sign-extended to 16 bits.  Then see what constant
     could be XOR'ed with C to get the sign-extended value.  */

  int c = INTVAL (operands[2]);
  int sextc = (c << 16) >> 16;
  int xorv = c ^ sextc;

  operands[4] = GEN_INT (xorv);
  operands[5] = GEN_INT (sextc);
}")
```

混乱を避けるために、一個の define_split を、ある define_insn にマッチする insn とマッチしない insn を同じように受け付けるように書いてはならない。代わりに、二つの define_split を別々に書いて、一つを有効な insn 用とし他方を有効でない insn 用とすること。

##命令の属性

ターゲット機種でサポートされている命令の記述に加えて、md ファイルでは、属性 のグループとそれぞれの属性の値を定義することも出来る。生成される各 insn には、属性毎に一つの値が割り当てられる。取る得る属性の一つとしては、insn がその機種の条件コードについて持つ効果がある。そして、この属性を使って NOTICE_UPDATE_CC が条件コードを追跡することができる。

* Defining Attributes: 属性とその値の指定方法
* Expressions: 属性値として使用可能な式
* Tagging Insns: 属性値の insn への割り当て
* Attr Example: 属性割り当ての例
* Insn Lengths: insn の長さの計算
* Constant Attributes: 定数である属性の定義
* Delay Slots: 遅延スロットの定義
* Function Units: insn スケジューリングに必要な情報の指定

##属性とその値の指定方法

define_attr 式を使って、ターゲットマシンで必要とされる各属性を定義する。以下のような形式になる。

(define_attr name list-of-values default)

name は、定義しようとしている属性の名前を指定する文字列である。

list-of-values は、属性に割り当てられる、コンマで区切った値のリストを指定する文字列か、その属性が数値を取ることを示すヌル文字列のどちらかである。

default は、ある属性式であり、この属性に対する明示的な値を含まない定義を持つパターンにマッチする insn のこの属性の値を与える。デフォルトの扱いについてのもっと詳細な情報は、See Attr Example。特定の insn に依存しない属性についての情報は、See Constant Attributes。

定義されている各属性毎に、たくさんの定義がファイル insn-attr.h に書き込まれる。属性に対して明示的な値の組が指定されている場合は、以下のように定義されている。

* \#define が、シンボル HAVE_ATTR_name に対して書かれている。
* ある列挙型クラスが attr_name に対して定義される。この列挙型の要素は、upper-name_upper-value という形になり、属性名と属性値はまず大文字に変換される。
* 関数 get_attr_name が定義されており、この関数は insn を一つ受取、その insn の属性値を返す。

例えば、md ファイルに以下のように書いてあったとすると、

```
(define_attr "type" "branch,fp,load,store,arith" ...)
```

ファイル insn-attr.h には以下のように出力される。

```
#define HAVE_ATTR_type
enum attr_type {TYPE_BRANCH, TYPE_FP, TYPE_LOAD,
                 TYPE_STORE, TYPE_ARITH};
extern enum attr_type get_attr_type ();
```

属性が数値を取るなら、enum 型は定義されず、属性値を取得する関数は int を返す。


##属性値として使用可能な式

属性を定義するのに使われる RTL 式は、前出のコードに加えて、以下で議論する、属性定義に固有のコードを幾つか使っている。属性値式は、以下の形のどれか一つでなければならない。

(const_int i)

整数 i が、数値属性の値を指定する。i は非負でなければならない。

数値属性の値は、const_int か、const_string で文字列で表現した整数、eq_attr(以下参照)、attr、symbol_ref、単純算術式のどれかで指定することができ、set_attr は特定の命令を上書きする(see Tagging Insns)。 

(const_string value)

文字列 value は、定数属性値を指定する。value が "*" として指定されると、その属性のデフォルト値が、この式を含む insn に対して使われることを意味する。"*" は、明らかに、define_attr の default 式で使うことはできない。

値が指定されている属性が数値的なら、value は非負の整数(この場合、普通 const_int)を含む文字列でなければならない。数値的でなければ、その属性に対して有効な値の一つを含んでいなければならない。 

(if_then_else test true-value false-value)

test は属性テストを指定する。その形式は以下で定義される。この式の値は、test が真であれば true-value であり、真でなければ false-value となる。 

(cond [test1 value1 ...] default)

この式の第一オペランドはあるベクトルであり、偶数個の式をもち、test 式と value 式の対からなる。cond 式の値は最初の真である test 式に対応する値のものである。真となる test 式がない場合は、cond 式の値は default 式の値である。
test 式は、以下の形のうちの一つを取る。

(const_int i)

このテストは、i がゼロでなければ真になり、さもなければ偽になる。 

(not test)

(ior test1 test2)

(and test1 test2)

これらのテストは、指定された論理関数が真になれば、真である。 

(match_operand:m n pred constraints)

このテストは、属性値が決定されようとしている insn のオペランドn のモードが m であり(テストのこの部分は、m がVOIDmode なら無視される)、かつ文字列 pred で指定される関数が、オペランド n とモード m を渡したときにゼロでない値を返したときに、真になる(テストのこの部分は、pred がヌル文字列なら無視される)。

オペランド constraints は無視されるので、ヌル文字列とすべきである。 

(le arith1 arith2)

(leu arith1 arith2)

(lt arith1 arith2)

(ltu arith1 arith2)

(gt arith1 arith2)

(gtu arith1 arith2)

(ge arith1 arith2)

(geu arith1 arith2)

(ne arith1 arith2)

(eq arith1 arith2)

これらのテストは、二つの算術式について指定された比較の結果が真になれば、真となる。算術式は、plus、minus、mult、div、mod、abs、neg、and、ior、xor、not、ashift、lshiftrt、ashiftrt といった式から構成される。

const_int と symbol_ref は常に有効な項である(追加の形式については see Insn Lengths)。symbol_ref は一個の文字列であり、一個の C の式を示す。この式は、get_attr_... ルーチンで評価されたときに int を生じる。普通はグローバル変数にならないといけない。 

(eq_attr name value)

name は、属性名を指定する文字列である。

value は文字列であり、属性 name の有効な値であるか、幾つかの値をカンマで区切ったリストか、あるいは ! の後に一個の値か値のリストを続けたものである。value が ! で始まっていなければ、このテストは、現在の insn の属性 name の値が value で指定されたリストの中に入っていれば、真となる。value が ! で始まっていると、このテストは属性値が指定されたリストに入っていない時に真となる。

例えば

```
(eq_attr "type" "load,store")
```

は、次の式に等価である。

```
(ior (eq_attr "type" "load") (eq_attr "type" "store"))
```

name が alternative の属性を指定するものなら、それはGNU CC の変数 which_alternative の値を参照し(see Output Statement)、その値は小さな整数でなくてはならない。例えば、

```
(eq_attr "alternative" "2,3")
```
は、次の式に等価である。

```
(ior (eq (symbol_ref "which_alternative") (const_int 2))
     (eq (symbol_ref "which_alternative") (const_int 3)))
```

ほとんどの属性に対して、テスト eq_attr は、テストされる属性の値が、ある特定のパターンにマッチする全ての insn に対して知られているなら、簡略化される。これは非常に良くあるケースである。 

(attr_flag name)

attr_flag 式の値は、name で指定されたフラグが現在スケジューリング中の insn に対して真になるなら、真となる。

name はある文字列であり、テストすべきフラグの固定したセットを一つ指定する。フラグ forward と backward をテストして、条件分岐の方向を決定する。フラグ very_likery、likely、very_unlikely、unlikely をテストして、条件分岐が成立すると予想されるかどうかを決定する。

フラグ very_likely が真なら、フラグ likely もまた真になる。very_unlikely と unlikely についても同様である。

この例では、条件分岐の遅延スロットを記述している。このスロットは、分岐が成立する前方への分岐(真の無効化)か分岐が成立しない場合の後方への分岐(偽の無効化)が無効化される。

```
(define_delay (eq_attr "type" "cbranch")
  [(eq_attr "in_branch_delay" "true")
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "forward"))
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "backward"))])
```

フラグ forward と backward は、現在スケジュールされつつあるinsn が条件分岐でなければ、偽になる。

フラグ very_likely と likely は、スケジュールされつつあるinsn が条件分岐でなければ、真になる。フラグ very_unlikely と unlikely は、スケジュールされつつあるinsn が条件分岐でなければ、偽になる。

attr_flag は、遅延スロットスケジューリングの間でだけ使われ、他のパスには何の意味も持たない。 

(attr name)

別の属性の値を返す。数値属性に対して最も役に立つが、同様に、非数値属性にたいしても eq_attr と attr_flag がより効率の良いコードを生成する助けとなる。

##属性値の insn への割り当て

ある insn のある属性に割り当てられる値は、主に、その insn により照合される(あるいは define_peephole が生成する)パターンにより決定される。各 define_insn と define_peephole は、オプションの最後の引数を持つことができ、一致する insn の属性値を指定することができる。ある特定の insn において指定されていない属性値は全て、その属性のデフォルト値に設定される。このデフォルト値は、その属性の define_attr で指定される。属性のデフォルト値を多用すると、ほとんどの insn パターンの定義で一つか二つの属性値を指定するだけで済む。次の節の例を参照のこと。

define_insn と define_peephole の最後のオプションの引数は、式のベクトルであり、それぞれの式がある一個の属性の値を定義する。属性値を割り当てる最も一般的な方法は、set 式を使い、その第一オペランドを設定する属性名を与える attr 式とすることである。この set 式の第二のオペランドは属性式(see Expressions)であり、属性の値を与える。

属性値が属性 alternaitve に依存するとき(すなわち、それが、その insn の制約にある利用可能な選択肢である)は、set_attr_alternative 式を使うことができる。これは属性式のベクトルを指定することを許す。ベクトルの中のそれぞれの式が各属性を表す。

任意の属性式ほど一般的な機能が必要ない場合、もっと簡単なset_attr 式を使うことができる。この式を使うと、一個の文字列を指定することで、一個の属性値か、あるいは各選択肢毎に一個の属性値を与えるリストを表すことができる。

上記の指定方法をそれぞれ以下に示す。どちらの場合も、name は、設定すべき属性を指定する文字列である。

(set_attr name value-string)

value-string は、希望の属性値を与える文字列か、あるいは一連の属性値をカンマで区切ったリストを表す文字列である。この要素数は、insn パターンの制約の選択肢数と一致しなければならない。

選択肢のどれかに * を指定することができる。その場合、属性値は、その選択肢にマッチする insn のデフォルト値になる。 

(set_attr_alternative name [value1 value2 ...])

insn の選択肢により、この値は指定された値のうちの一つになる。これは、属性 alternative の cond を使ってのテストの省略形である。 

(set (attr name) value)

この set の第一オペランドは、特別な RTL 式 である attr 式でなければならない。この式の唯一のオペランドは、設定する属性の名前を指定する文字列である。value は、その属性の値である。
以下に同じ属性値の指定を表す、三つの異なる方法を示す。

```
(set_attr "type" "load,store,arith")

(set_attr_alternative "type"
                      [(const_string "load") (const_string "store")
                       (const_string "arith")])

(set (attr "type")
     (cond [(eq_attr "alternative" "1") (const_string "load")
            (eq_attr "alternative" "2") (const_string "store")]
           (const_string "arith")))
```

define_asm_attributes 式は、asm 文から生成されたinsn に割り当てられた属性を指定する方法を提供する。次の形を取る。

(define_asm_attributes [attr-sets])

ここで、atr-sets は、define_insn や define_peephole 式両方に指定するのと同じものである。

これらの値は、普通はその属性値の「最悪の場合」になる。例えば、条件コードが破壊されることを示したりする。

length 属性の指定は特別に扱われる。一個の asm insn の長さを計算するには、式 define_asm_attributes で指定された長さに、asm 文に指定されている機械命令の数を掛けたものになる。asm 文中の機械命令数は、命令文字列中のセミコロンと改行の数で決まる。このため、define_asm_attributes で指定されるlength 属性の値は、一個の機械命令の可能な最大長にしなくてはならない。

##属性割り当ての例

デフォルトをうまく使うのが、insn の属性を効率良く使うには重要である。通常、insn は types と、type と呼ばれている属性に分けられる。type は、このデフォルト値を表すのに使われる。この属性は、普通は他の属性のデフォルト値を定義するのにしか使われない。例を使ってこの属性の使い方を説明する。

ある RISC マシンを考えよう。このマシンには条件コードがあり、レジスタで実行されるのは全語の演算だけである。全ての命令をロード、ストア、(整数)算術演算、浮動小数点演算、分岐に分割できるとしよう。

ここでは、ある insn の条件コードに対する効果を決定することに注意を集中することにし、さらに可能な効果として次のものに限定する。条件コードは、予測できない形で設定され得る(破壊される)、変更されない、演算結果に一致するように設定される、以前に条件コードに設定した項目が修正されたときにのみ変更される。

そういう機種用の md ファイルの例の一部を示す

```
(define_attr "type" "load,store,arith,fp,branch" (const_string "arith"))

(define_attr "cc" "clobber,unchanged,set,change0"
             (cond [(eq_attr "type" "load")
                        (const_string "change0")
                    (eq_attr "type" "store,branch")
                        (const_string "unchanged")
                    (eq_attr "type" "arith")
                        (if_then_else (match_operand:SI 0 "" "")
                                      (const_string "set")
                                      (const_string "clobber"))]
                   (const_string "clobber")))

(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,r,m")
        (match_operand:SI 1 "general_operand" "r,m,r"))]
  ""
  "@
   move %0,%1
   load %0,%1
   store %0,%1"
  [(set_attr "type" "arith,load,store")])
```

上の例で我々は、マシンワードより小さな量について算術演算を実行すると、それにより条件コードに全ワードの結果に対応する値を設定するので、条件コードが破壊されると仮定していることに注意。

##insn の長さの計算

多くの機種では、複数のタイプの分岐命令が提供されており、それぞれ分岐の変位の長さが異なる。大部分の場合は、アセンブラが正しい命令を選ぶ。だが、アセンブラが不可能な場合は、特別な属性、length 属性が定義されているときは GCC が行なうことができる。この属性は、define_attr でヌル文字列を指定することで数値を持つように定義しなければならない。

length 属性の場合は、さらに算術項の二つの形式があり、テスト式で使うことができる。

(match_dup n)

これは、現在の insn のオペランド n のアドレスを参照している。このアドレスは label_ref でなければならない。 

(pc)

現在の insn のアドレスを参照する。これを次の insn のアドレスとする使い方の方がより一貫性が保てるのだろうが、そうすると現在の insn の長さを計算するときに混乱する可能性がある。

通常の insn については、長さは length 属性の値により決まる。addr_vec と addr_diff_vec の insn パターンの場合は、長さはベクトル数に各ベクトルの大きさを掛けたものとして計算される。

長さは、アドレス可能な記憶域の単位(バイト)で測る。

以下のマクロを使って長さの計算を洗練されたものにすることができる。

FIRST_INSN_ADDRESS

insn の length 属性が使われているとき、このマクロはある関数の先頭の insn のアドレスに代入されるべき値を指定する。これが指定されていないと、0 が使われる。 

ADJUST_INSN_LENGTH (insn, length)

定義されていると、命令 insn に、それが使われている文脈の関数として割り当てられている長さを修正する。length は左辺値であり、最初に計算した insn の長さが入っている。これは、その insn の正しい長さに更新する必要がある。

このマクロは通常は必要とされない。必要となる場合の一つは、ROMP である。この機種では、addr_vec insn の大きさは、アラインメントが必要とされるかも知れないという事実を補償するために、2 づつ増加しなければならない。

get_attr_length(length 属性の値)を返すルーチンを出力ルーチンの中で使うと、以下の例が示すように、書き出すべき分岐命令の形を決めることができる。

可変長分岐の指定の例として、IBM 360 を考える。あるレジスタに、ある関数の開始アドレスが設定されるという規約を採用したとすると、その開始点から 4k バイト以内のラベルには一個の 4 バイト命令でジャンプすることが出来る。それ以外の場合は、6バイトの命令列を使って、メモリからアドレスをロードし、次にそのアドレスに分岐する必要がある。

こういう機種では、分岐命令のパターンは以下のような指定になる。

```
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
  "*
{
   return (get_attr_length (insn) == 4
           ? \"b %l0\" : \"l r15,=a(%l0); br r15\");
}"
  [(set (attr "length") (if_then_else (lt (match_dup 0) (const_int 4096))
                                      (const_int 4)
                                      (const_int 6)))])
```

##定数である属性の定義

define_attr の特別な形式、つまり、デフォルト値の式が const 式の場合、ある特定のコンパイラの実行については定数である属性を示す。定数属性は、どの種類のプロセッサが使われるかを指定するのに使われる。例えば、以下のようになる。

```
(define_attr "cpu" "m88100,m88110,m88000"
 (const
  (cond [(symbol_ref "TARGET_88100") (const_string "m88100")
         (symbol_ref "TARGET_88110") (const_string "m88110")]
        (const_string "m88000"))))

(define_attr "memory" "fast,slow"
 (const
  (if_then_else (symbol_ref "TARGET_FAST_MEM")
                (const_string "fast")
                (const_string "slow"))))
```

定数属性用に生成されたルーチンには、どの特定の insn にも依存しないので、パラメータはない。定数属性の値を定義するのに使われる RTL 式は、symbol_ref 形式を使っても良いが、insn の属性を含む、match_operand 形式や eq_attr 形式は使ってならない。

##遅延スロットの定義

insn の属性の機構を使うと、ターゲットマシンに遅延スロットがもしあれば、遅延スロットを必要であると指定することができる。ある命令は、物理的にその直後に置かれている命令群が、その命令の前に置かれているかのように実行されるとき、遅延スロットを必要とすると言われる。古典的な例では、分岐命令と呼び出し命令が該当し、分岐や呼び出しが実行される前に後続の命令を実行することがある。

機種によっては、条件分岐命令が、遅延スロットに置かれている命令を選択的に無効化することができる。これは、遅延スロットにある命令が、分岐の結果によっては実行されないということを意味する。分岐が真のときに無効化を行なう命令と分岐が偽の時に無効化を行なう命令の両方がサポートされている。

遅延スロット空けジューリングが命令スケジューリングと異なるのは、ある命令が遅延スロットを必要とするかどうかを決めるには、生成される命令の型にだけ依存し、命令間のデータ流には依存しないという点にある。データ依存の命令スケジューリングに関する議論については次の節を参照のこと。

ある insn が一個以上の遅延スロットを必要とするという要件は、define_delay 式により指示される。define_delay 式は以下の形式を取る。

```
(define_delay test
              [delay-1 annul-true-1 annul-false-1
               delay-2 annul-true-2 annul-false-2
               ...])
```

test は、属性のテストであり、この define_delay がある特定のinsn に適用されるかどうかを指示する。もし適用されるのであれば、必要な遅延スロットの数が二番目の引数として指定されるベクターの長さにより決定される。遅延スロット n に置かれている insn は、属性テスト delay-n を満足しなければならない。annul-true-n は属性テストであり、分岐が真の時にどの insn が無効化されるかを指定する。同様に、annul-false-n は分岐が偽の時に、遅延スロットにあるうちのどの insn が無効化されるかを指定する。遅延スロットの無効化がサポートされていないなら、(nil) を指定すること。

例えば、良くある場合として分岐 insn と呼び出し insn が一個の遅延スロットを必要とし、そのスロットには分岐あるいは呼び出し以外の任意の insn を置くことができる場合、以下のコードを md ファイルに置くことになる。

```
(define_delay (eq_attr "type" "branch,call")
              [(eq_attr "type" "!branch,call") (nil) (nil)])
```

define_delay 式は複数指定することができる。その場合、各 define_delay 式は、別々の遅延スロット要件を指定し、二つの define_delay 式のテストで両方真になる insn があってはならない。

例えば、分岐には一個の遅延スロットを必要とするが、呼び出しには二つの遅延スロットが必要で、遅延スロットには分岐 insn も呼び出し insn も置くことができず、分岐用の遅延スロットに有効な任意の insn が分岐が真の場合には無効化可能であるという機種では、以下のように表現する。

```
(define_delay (eq_attr "type" "branch")
   [(eq_attr "type" "!branch,call")
    (eq_attr "type" "!branch,call")
    (nil)])

(define_delay (eq_attr "type" "call")
              [(eq_attr "type" "!branch,call") (nil) (nil)
               (eq_attr "type" "!branch,call") (nil) (nil)])
```

##insn スケジューリングに必要な情報の指定

多くの RISC マシンでは、特定のサイクル数またないとその結果が得られないような命令が存在する。良く見られるのは、メモリからデータをロードする命令である。多くのマシンでは、ロード命令の後、あまり早くロードされるデータを参照すると、パイプラインがストールする。

さらに、最近の多くのマイクロプロセッサは、複数の機能ユニット、普通は一個の整数向けのユニットと一個の浮動小数点ユニットを持っており、そのため、必要とされる結果が用意できていないときに良くパイプラインがストールする。

この節では、ある命令の実行から、その結果が使えるようになるまでにどれだけの時間が経過する必要があるかを指定する方法を説明する。また、ある命令の実行することにより、機能ユニットの競合にのために、同種の命令の実行を遅らせることがあるのはどういう場合かを指定する方法についても説明する。

この節で説明する指定方法のために、マシンを機能ユニットに分割し、各機能ユニットは特定の種類の命令を first-in-first-out 順に実行するものとする。各サイクル毎に一つの命令を受付、続く命令でその結果が利用できる(フォワーディングによることが多い)機能ユニットについては、指定を行う必要がない。古典的な RISC マイクロプロセッサは、通常機能ユニットは一つしかなく、それをメモリ と呼ぶことが出来る。最近のスーパースカラ・プロセッサは、浮動小数点演算用の機能ユニットを複数持つことが多い。少なくとも、一個の浮動小数点加算器と乗算器を持つのが普通である。

ある insn のクラスによるある機能ユニットの使用方法は、define_function_unit 式で指定される。それは以下のようになる。

```
(define_function_unit name multiplicity simultaneity
                      test ready-delay issue-delay
                     [conflict-list])
```

name は、機能ユニット名を指定する文字列である。

multiplicity は整数であり、プロセッサの持つ同等のユニット数を指定する。二個以上のユニットが指定された場合は、各ユニットは独立にスケジュールされる。本当に独立なユニット数を指定すべきである。パイプライン化されたユニットは一個のユニットとして指定すべきである。(一個の命令クラスに対し複数の機能ユニットがあり、それらが真に独立しており、パイプライン化されていない機種の良く知られている例としては、CDC 6600 の二つの乗算ユニットと二つの増分ユニットがあるのみである。)

simultaneity は、各機能ユニットの実態で同時に実行できる命令の最大数か、機能ユニットがパイプライン化されていて制限がないのであればゼロを指定する。

機能ユニット name を参照している、全ての define_function_unit の定義は、multiplicity とsimultaneity について同じ名前と値を持たなければならない。

test は属性テストであり、この定義において記述しようとしているinsn を選択する。一個の insn は、複数の機能ユニットを使っても良く、一個の機能ユニットは複数の define_function_unit で指定されていても良いということに注意して欲しい。

ready-delay はある整数であり、ストールなしで命令の結果が使えるようになるまでのサイクル数を指定する。

issue-delay はある整数であり、test 式に一致した命令がこの機能ユニットを使い始めてから、後続の命令が使い始められるまでのサイクル数を指定する。コストが N だと N-1 サイクルの遅延を表す。後続の命令は、以前の命令がより大きな値の ready-delay を持っている場合にも遅延する可能性がある。このブロックの効果は、simultaneity、ready-delay、issue-delay、conflict-list といった項から計算される。普通のパイプライン化されていない機能ユニットについては、simultaneity は 1 であり、このユニットは、実行している命令のready-delay サイクルの間ブロックされる。より小さな値のissue-delay は無視される。

conflict-list はオプションのリストであり、この機能ユニットの衝突の詳細なコストを与える。指定されていると、条件のテスト式のリストになっており、その式は、name で実行されるように選ばれたinsn に適用される。その insn の後に、既に name で実行中のtest にマッチする特定の insn が続く。リストのそれぞれの insn に対し、issue-delay が衝突のコストを指定する。リストに無い insn については、コストはゼロである。指定されていない場合は、conflict-list は、機能ユニットを使う全ての命令がデフォルトになる。

このベクトルが使われる典型的な場合としては、浮動小数点機能ユニットが単精度演算か倍精度演算のどちらかはパイプライン化できるが両方は出来ない場合や、メモリユニットがロード命令はパイプライン化できるがストア命令はできない場合等がある。

例として古典的な RISC マシンを考えてみよう。ロード命令の結果は二サイクルの間利用できず(一個の「遅延」命令が必要)、ロード命令は同時には一個しか実行できないとする。これは以下のように指定できる。

```
(define_function_unit "memory" 1 1 (eq_attr "type" "load") 2 0)
```

浮動小数点機能ユニットが単精度か倍精度のどちらかはパイプライン処理できるが、両方はできないという場合、以下のように指定することができる。

```
(define_function_unit
   "fp" 1 0 (eq_attr "type" "sp_fp") 4 4 [(eq_attr "type" "dp_fp")])
(define_function_unit
   "fp" 1 0 (eq_attr "type" "dp_fp") 4 4 [(eq_attr "type" "sp_fp")])
```

注意: スケジューラは、機能ユニットの衝突を避け、define_function_unit の全ての指定を使おうとする。我々は最近、これらの指定では、複数のパイプラインユニットを使う命令を持つ、いくつかの新しめの「スーパスカラ」プロセッサをモデル化できないということに気が付いた。これらの命令は、第二の機能ユニットがそれらの命令を実行するのに使われている間に潜在的な衝突を起こす可能性があり、その衝突を表現する方法がないのである。このようなプロセッサの機能ユニットの衝突の仕組みの例や、その表現方法について提案があれば、知らせて欲しい。

##ターゲット記述マクロ

マシン記述は、ファイル machine.md の他に、machine.h という名前の C ヘッダファイルから構成される。このヘッダファイルは、多数のマクロを定義するものであり、.md ファイルに記述しきれないターゲット機種の情報を伝える。tm.h というファイルは、machine.h へのリンクにならねばならない。そして、ヘッダファイル config.h はtm.h をインクルードしており、ほとんどのソースファイルがconfig.h をインクルードしている。

* Driver: ドライバプログラムのコンパイル過程の実行制御
* Run-time Target: -m68000 や -m68020 のような -m オプションの定義方法
* Storage Layout: データサイズとアラインメントの定義
* Type Layout: 基本データ型の大きさと特長の定義
* Registers: ハードウェアレジスタの名前付けと記述方法
* Register Classes: ハードウェアレジスタのクラス
* Stack and Calling: スタックの成長方向と量の定義
* Varargs: varargs マクロの定義
* Trampolines: 入れ子関数のための実行時コードの設定
* Library Calls: ライブラリルーチンの暗黙呼び出しの制御
* Addressing Modes: メモリオペランドとして有効なアドレッシングモードの定義
* Condition Code: 条件コードの更新方法の定義
* Costs: 演算の相対的なコストの定義
* Sections: text、data、その他のセクション
* PIC: 位置独立コード(PIC)向けのマクロ
* Assembler Format: 出力すべき命令と疑似命令の書き方の定義
* Debugging Info: デバッグ情報の出力形式の定義
* Cross-compilation: クロスコンパイラでの浮動小数点の扱い
* Misc: その他

##コンパイラドライバ gcc の制御

コンパイラドライバの制御に関するマクロを以下に示す。

SWITCH_TAKES_ARG (char)

一個のC の式。オプション -char が引数を取るかどうかを指定する。この式の値は、オプションが取る引数の数である。多くのオプションでは 0 になる。

このマクロは、デフォルトでは、DEFAULT_SWITCH_TAKES_ARG に定義される。DEFAULT_SWITCH_TAKES_ARG は、標準のオプションを正しく扱う。引数を取るオプションを新たに追加しない限り SWITCH_TAKES_ARG を定義する必要はない。定義する場合には、まず DEFAULT_SWITCH_TAKES_ARG を呼び出してから、追加したオプションの検査を行なうようにすること。 

WORD_SWITCH_TAKES_ARG (name)

C の式であり、オプション -name が引数を取るかどうかを指定する。この式の値は、オプションが取る引数の数である。多くのオプションでは 0 になる。複数文字からなるオプション名の場合には、SWITCH_TAKES_ARG の代わりにこちらを使う。

このマクロは、デフォルトで DEFAULT_WORD_SWITCH_TAKES_ARG に定義されており、標準のオプションを正しく扱うことができる。定義し直す場合には、まず DEFAULT_WORD_SWITCH_TAKES_ARG を呼び出してから、追加したオプションの検査を行うようにする必要がある。 

SWITCH_CURTAILS_COMPILATION (char)

一個の C の式であり、-char というオプションが、実行形式の生成の前でコンパイルを止めるかどうかを決定する。この式の値は、ブール型であり、オプションが実行形式の生成を止めるならゼロでない値であり、止めないならゼロである。

デフォルトでは、このマクロは DEFAULT_SWITCH_CURTAILS_COMPILATION として定義される。DEFAULT_SWITCH_CURTAILS_COMPILATION は標準のオプションを正しく取り扱う。実行形式の生成に影響を与えるオプションを追加するのでない限り、SWITCH_CURTAILS_COMPILATION を定義する必要はない。再定義するなら、DEFAULT_SWITCH_CURTAILS_COMPILATION をまず呼び出して、次に追加したオプションの検査を行うようにする必要がある。 

SWITCHES_NEED_SPACES

文字列を値とする C の式であり、リンカに渡すオプションのうち、オプションとその引数との間に空白を必要とするものを列挙する。
このマクロが定義されない場合、デフォルトは "" になる。 

CPP_SPEC

一個の C の文字列定数。CPP に渡すオプションを GNU CC のドライバプログラムに 知らせる。これは同時に、ユーザが指定したオプションをGNU CC が CPP に渡すオプションに変換する方法を指定することも出来る。
何もする必要が無いときには、このマクロは定義しないこと。 

NO_BUILTIN_SIZE_TYPE

このマクロが定義されていると、プリプロセッサは組み込みマクロ__SIZE_TYPE__ を定義しない。その場合は代わりに、マクロ __SIZE_TYPE__ を CPP_SPEC で定義する必要がある。
SIZE_TYPE がプリプロセッサからは参照できないターゲット依存のフラグに依存するなら、このマクロを定義すべきである。その他の場合は、定義すべきでない。 

NO_BUILTIN_PTRDIFF_TYPE

このマクロを定義した場合、プリプロセッサは組み込みマクロ__PTRDIFF_TYPE__ を定義しない。その場合は代わりに __PTRDIFF_TYPE__ を、CPP_SPEC で定義する必要がある。
PTRDIFF_TYPE がプリプロセッサからは参照できないターゲット依存のフラグに依存するなら、このマクロを定義すべきである。その他の場合は、定義すべきでない。 

SIGNED_CHAR_SPEC

このマクロは C の文字列定数に定義し、CPP に渡すべきオプションをGNU CC のドライバプログラムに知らせる。デフォルトでは、cc1 が char を unsigned char と同じように扱うなら、-D__CHAR_UNSIGNED__ というオプションを渡すように定義されている。
デフォルトの定義を変える必要がないのであれば、このマクロは定義しないこと。 

CC1_SPEC

GNU CC のドライバプログラムが cc1 に渡すオプションをC の文字列定数で定義する。これは同時に、ユーザが指定したオプションをGNU CC が cc1 に渡すオプションに変換する方法を指定することも出来る。
何もする必要が無いときには、このマクロは定義しないこと。 

CC1PLUS_SPEC

C の文字列定数であり、GNU CC のドライバプログラムに対し、cc1plus に渡すべきオプションを知らせる。
何もする必要がなければ、このマクロは定義しないこと。 

ASM_SPEC

C の文字列定数であり、GNU CC のドライバプログラムに対し、アセンブラに渡すべきオプションを知らせる。さらに、GNU CC に与えられたオプションを、GNU CC がアセンブラに渡すべきオプションに変換する方法の指定も行う。例としては sun3.h を参照のこと。
何もする必要がなければ、このマクロは定義しないこと。 

ASM_FINAL_SPEC

C の文字列定数であり、GNU CC のドライバプログラムに対し、通常のアセンブラの後に後処理を行うプログラムを実行する方法を知らせる。通常は、この後処理は不要である。この例としては、mips.h を参照のこと。
何もする必要がなければ、このマクロは定義しないこと。 

LINK_SPEC

C の文字列定数であり、GNU CC のドライバプログラムに対し、リンカに渡すべきオプションを知らせる。さらに、GNU CC に与えられたオプションを、GNU CC がリンカに渡すべきオプションに変換する方法を指定する。
何もする必要がなければ、このマクロは定義しないこと。 

LIB_SPEC

C の文字列定数で、LINK_SPEC に良く似た使われ方をする。違いは、LIB_SPEC はリンカに指定されたコマンドの最後に置かれることである。
このマクロが定義されていない場合は、デフォルトは普通置かれている場所から標準 C ライブラリをロードすることになる。gcc.c を参照のこと。 

LIBGCC_SPEC

C の文字列定数で、GNU CC のドライバプログラムに、いつどのように、libgcc.a への参照をリンカのコマンド行に置くかを指示する。この定数は、LIB_SPEC の値の前後両方に置かれる。
このマクロが定義されていない場合は、GNU CC のドライバはデフォルトでは、-shared オプションが指定されていない限り、文字列 -lgcc をリンカに渡す。 

STARTFILE_SPEC

LINK_SPEC と良く似ている、やはり別の C の文字列定数である。違いは、STARTFILE_SPEC がリンカに渡されるコマンド行引数の先頭で使われる点である。
このマクロが定義されていなければ、デフォルトは C の標準的なスタートアップファイルを通常の場所からロードするという定義になる。gcc.c を参照のこと。 

ENDFILE_SPEC

LINK_SPEC と良く似ている、もう一つのやはり別の C の文字列定数である。違いは、ENDFILE_SPEC がリンカに渡されるコマンド行引数の最後で使われる点である。
何もする必要がなければ、このマクロは定義しないこと。 

EXTRA_SPECS

このマクロで、specs ファイルに追加する指定を定義する。ここで追加した指定は、CC1_SPEC の様な様々な指定で使用できる。
定義は、構造体の配列の初期化子とすべきである。この構造体は、指定名を定義する文字列定数と指定そのものを与える文字列定数を含む。

何もする必要がなければ、このマクロは定義しないこと。

EXTRA_SPECS が役に立つのは、ある一つのアーキテクチャに関連するいくつものターゲットがあるときである。そのような場合、互いに似通った ..._SPECS がいくつもあり、保守者はこれらの定義を一箇所で集中管理したいであろう。

例えば、PowerPC の System V.4 のターゲットは、EXTRA_SPECS を使って、System V の呼びだしシーケンスを使うときは _CALL_SYSV を、古い AIX ベースの呼びだしシーケンスを使うときは _CALL_AIX を定義している。

ターゲットファイル config/rs6000/rs6000.h では以下のような定義を行なっている。

```
#define EXTRA_SPECS \
  { "cpp_sysv_default", CPP_SYSV_DEFAULT },

#define CPP_SYS_DEFAULT ""
```
ターゲットファイル config/rs6000/sysv.h では以下のような定義を行なっている。

```
#undef CPP_SPEC
#define CPP_SPEC \
"%{posix: -D_POSIX_SOURCE } \
%{mcall-sysv: -D_CALL_SYSV } %{mcall-aix: -D_CALL_AIX } \
%{!mcall-sysv: %{!mcall-aix: %(cpp_sysv_default) }} \
%{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT}"

#undef CPP_SYSV_DEFAULT
#define CPP_SYSV_DEFAULT "-D_CALL_SYSV"
一方、config/rs6000/eabiaix.h の定義は以下の通りである。

#undef CPP_SYSV_DEFAULT
#define CPP_SYSV_DEFAULT "-D_CALL_AIX"
```

LINK_LIBGCC_SPECIAL

ライブラリ libgcc.a はドライバプログラム自身が探すべきであり、リンカには -L オプションを渡すべきでなければ、このマクロを定義する。このマクロを定義した場合、ドライバプログラムは、引数 -lgcc をリンカに渡して libgcc.a の検索を行なわせ、検索を行なうディレクトリを -L オプションでリンカに渡す。 

LINK_LIBGCC_SPECIAL_1

ドライバプログラムがライブラリ libgcc.a を探すべきであるなら、このマクロを定義する。このマクロが定義されていない場合、引数 -lgcc をリンカに渡して libgcc.a の検索を行なわせる。このマクロは LINK_LIBGCC_SPECIAL とほぼ同じだが、-L オプションを渡さない点が異なる。 

LINK_COMMAND_SPEC

C の文字列定数。リンカを実行するの必要な完全なコマンド行を指定する。これを定義するときは、gcc.c にあるリンクのためのコマンド行に変更が加わる度に読者の移植部分を更新する必要がある。このため、リンカを起動するコマンド行を完全に再定義する必要があり、かつ、読者が必要な効果を得るための方法が他にない場合だけ、このマクロを定義すること。 

MULTILIB_DEFAULTS

このマクロは、C の文字列の配列の初期化式として定義して、ドライバプログラムに対し、どのオプションがこのターゲットのデフォルトなのか、そして、どれが MULTILIB_OPTIONSを使った場合に特別に扱う必要がないオプションかを知らせる。
MULTILIB_OPTIONS がターゲットの makefile 断片で定義されていない場合や、 MULTILIB_OPTIONS に列挙されているオプションの中にデフォルトで指定されるものが無い場合は、このマクロは定義しないこと。 

RELATIVE_PREFIX_NOT_LINKDIR

このマクロを定義すると、gcc は、プレフィックスが絶対パスの場合は、-B で指定されたプレフィックスをリンカの -L オプションについてだけ変換する。 

STANDARD_EXEC_PREFIX

コンパイラの実行形式ファイル群を検索する時のデフォルトの接頭辞である、/usr/local/lib/gcc-lib/ を別のものに置き換えたい場合は、このマクロを、それを表す C の文字列定数として定義する。 

MD_EXEC_PREFIX

このマクロが定義されていれば、STANDARD_EXEC_PREFIX の後で、これを接頭辞として追加で検索が行なわれる。-b オプションが指定されたり、クロスコンパイラとして構築された場合は、MD_EXEC_PREFIX の検索は行なわれない。MD_EXEC_PREFIX を定義する場合は、それを configure.in 中の、アセンブラを検索するのに使われるディレクトリのリストに追加するのを忘れないこと。 

STANDARD_STARTFILE_PREFIX

crt0.o のようなスタートアップファイルを検索する時のデフォルトの接頭辞である、/usr/local/lib/ を別のものに置き換えたい場合は、このマクロを、それを表す C の文字列定数として定義する。 

MD_STARTFILE_PREFIX

このマクロが定義されていれば、標準の接頭辞でスタートアップファイル検索が行なわれた後で、このマクロを接頭辞として追加で検索が行なわれる。-b オプションが指定されたり、クロスコンパイラとして構築された場合は、MD_STARTFILE_PREFIX の検索は行なわれない。 

MD_STARTFILE_PREFIX_1

このマクロが定義されていれば、標準の接頭辞でスタートアップファイル検索が行なわれた後で、このマクロを接頭辞としてさらにもう一度追加で検索が行なわれる。-b オプションが指定されたり、クロスコンパイラとして構築された場合は、この接頭辞での検索は行なわれない。 

INIT_ENVIRONMENT

ドライバから呼び出されるプログラム、例えばアセンブラやローダに対して環境変数を指定したければ、このマクロを C の文字列定数として定義する。ドライバは、このマクロの値を putenv に渡して、必要な環境変数の初期化を行なう。 

LOCAL_INCLUDE_DIR

ローカルのヘッダファイルを検索するときのデフォルトの接
頭辞である、/usr/local/include の代わりのものを使いたいときは、それを C の文字列定数としてこのマクロに定義する。LOCAL_INCLUDE_DIR は、SYSTEM_INCLUDE_DIR の前に検索される。
クロスコンパイラの場合はこのマクロは使わないし、/usr/local/include やその代わりの場所は検索しない。 

SYSTEM_INCLUDE_DIR

標準のディレクトリの前にヘッダファイルを検索したい、システム固有のディレクトリがあれば、このマクロで C の文字列定数として定義する。SYSTEM_INCLUDE_DIR は、 STANDARD_INCLUDE_DIR の前に検索される。
クロスコンパイラの場合はこのマクロは使わないし、これで指定されたディレクトリを検索しない。 

STANDARD_INCLUDE_DIR

ヘッダファイルを検索するときのデフォルトの接頭辞である、/usr/include を別のものに置き換えたいときは、このマクロでC の文字列として定義する。
クロスコンパイラの場合はこのマクロは使わないし、/usr/include やその代わりのディレクトリを検索しない。 

STANDARD_INCLUDE_COMPONENT

STANDARD_INCLUDE_DIR に対応する「成分」である。成分の説明については以下の INCLUDE_DEFAUTLS を参照のこと。このマクロを定義しない場合は、成分は一つも使われない。 

INCLUDE_DEFAULTS

インクルードファイルのデフォルトの検索パス全体を上書きしたい場合は、このマクロを定義する。ネイティブコンパイラの場合は、デフォルトの検索パスは通常は、GCC_INCLUDE_DIR、LOCAL_INCLUDE_DIR、SYSTEM_INCLUDE_DIR、GPLUSPLUS_INCLUDE_DIR、STANDARD_INCLUDE_DIR から成る。さらに、GPLUSPLUS_INCLUDE_DIR と GCC_INCLUDE_DIR はMakefile で自動的に定義され、GCC に固有の検索パスを指定する。ディレクトリ GPLUSPLUS_INCLUDE_DIR は、C++ プログラムについてだけ使われる。

このマクロは、構造体の配列の初期化子として定義しなければならない。配列の各要素は、それぞれ四つの要素を持つ。ディレクトリ名(文字列定数)、成分名、C++ 向けディレクトリ用フラグ、C++ プログラムをコンパイルするときには、そのディレクトリのインクルード行をextern "C" で囲む必要がないかどうかを示すフラグ、である。配列の終りはヌルの要素で示す。

成分名は、インクルードファイルがどの GNU パッケージのものかを示す。これは全て大文字で記す。例えば、GCC や BINUTILS とする。インクルードファイルの入っているパッケージが、ベンダ提供のオペレーティングシステムの一部である場合は、成分名は 0 と書くようにする。

例えば、VAX/VMS 向けの定義は以下のようになる。

```
#define INCLUDE_DEFAULTS \
{                                       \
  { "GNU_GXX_INCLUDE:", "G++", 1, 1},   \
  { "GNU_CC_INCLUDE:", "GCC", 0, 0},    \
  { "SYS$SYSROOT:[SYSLIB.]", 0, 0, 0},  \
  { ".", 0, 0, 0},                      \
  { 0, 0, 0, 0}                         \
}
```

実行形式ファイルのプレフィックスを試す順序を以下に示す。

* ユーザにより -B で指定されたプレフィックス。
* もし指定されていれば、環境変数 GCC_EXEC_PREFIX。
* 環境変数 COMPILER_PATH で指定されたディレクトリ。
* マクロ STANDARD_EXEC_PREFIX。
* /usr/lib/gcc/。
* 指定されていれば、マクロ MD_EXEC_PREFIX。

開始ファイルは、以下のプレフィックスを順番に探す。

* ユーザが -B で指定したプレフィックス。
* 定義されていれば、環境変数 GCC_EXEC_PREFIX。
* 環境変数 LIBRARY_PATH で指定されたディレクトリ群(ネイティブの場合のみ。クロスコンパイラでは使われない。)
* マクロ STANDARD_EXEC_PREFIX 。
* /usr/lib/gcc/.
* 定義されていれば、マクロ MD_EXEC_PREFIX。
* 定義されていれば、マクロ MD_STARTFILE_PREFIX。
* マクロ STANDARD_STARTFILE_PREFIX 。
* /lib/.
* /usr/lib/.

##実行時ターゲット指定

以下に実行時のターゲット指定を示す。

CPP_PREDEFINES

C の文字列定数を定義する。この文字列には、マシンとシステムを特定する事前定義マクロを定義する、-D オプションを指定する。ここで指定されたマクロは、-ansi オプションが指定されない限り定義済となる。

さらに、これらのマクロ名の前後に __ を付加した名前のマクロのセットが並行して定義済となる。これら __ 付きのマクロは ANSI 標準により許されており、-ansi オプションの指定の有無に関わらず、定義済となる。

例えば、Sun では、次のような指定をすることができる。

"-Dmc68000 -Dsun -Dunix"
この結果、マクロ __mc68000__、__sun__、__unix__ が無条件に定義され、mc68000、sun、unix が-ansi オプションが指定されないときに定義される。 

extern int target_flags;

この宣言は必須である。 

TARGET_...

この一連のマクロを定義することで、コンパイラのコマンド行引数により、ターゲット機種の選択的機能の使用を有効／無効にすることができる。例えば、一個のマシン記述で 68000 と 68020 の両方に対応できるので、コマンド行引数で、コンパイラに 68020 固有の命令を使うかどうかを指定できる。コマンド行引数が動作する仕組みは、target_flags 中のビットが立っているかどうかをテストする TARGET_68020 というマクロによるものである。

このようなオプション毎に TARGET_featurename というマクロを定義する。この定義では、target_flags 中のビットが立っているかどうかをテストしなければならない。例えば、以下のように書く。

```
#define TARGET_68020 (target_flags & 1)
```

こういったマクロが使われるのは、一つには、命令パターン中の条件式である。TARGET_68020 が、68000 のマシン記述ファイル、m68k.md にどれぐらい現れるか注意してみると良いだろう。 

TARGET_SWITCHES

このマクロでは、target_flags 中のビットをセットしたりクリアするコマンド行オプションの名前を定義する。この定義は、各コマンド行オプション毎にグループ分けした初期化子とする。

各グループは、オプション名を定義する文字列定数、target_flags にセットすべきビット群を含む数値、それに --help オプションを指定したときに表示される説明となる第二の文字列から成る。数値が負の数の場合、その数値で指定されるビットを立てる代わりに、クリアする。説明文字列が、存在はするが空の場合、そのオプションについてのヘルプ情報は何も表示されないが、隠しオプションには数えない。実際のオプション名は、ここで指定した名前に -m を付加したものになる。

ヌル文字列を持つグループが一個存在する必要がある。このグループで指定する数値が、target_flags のデフォルト値になる。どのターゲットオプションも最初はこのデフォルト値に対して作用する。

以下の例では -m68000 と -m68020 をお互いに反対の意味を持つように定義し、後者をデフォルトとしている。

```
#define TARGET_SWITCHES \
  { { "68020", 1, "" },      \
    { "68000", -1, "Compile for the 68000" }, \
    { "", 1, "" }}
```

TARGET_OPTIONS

TARGET_SWITCHES と同様のマクロだが、値を持つコマンド行オプションの名前を定義する。この定義は、コマンド行オプション毎のグループ分けした初期化子とする。
各グループはそれぞれ、フィールドとして、オプション名の固定部分を定義する文字列定数、ある変数のアドレス、それに説明文字列を持つ。この変数は、char * 型であり、指定したオプションの固定部分がマッチした場合、変動部分がこの変数に設定される。実際のオプション名は、指定した名前に -m を付加したものになる。

以下の例では、-mshort-data-number というオプションを定義している。指定されたオプションが -mshort-data-512 なら、変数 m88k_short_data には、文字列 "512" がセットされる。

```
extern char *m88k_short_data;
#define TARGET_OPTIONS \
 { { "short-data-", &m88k_short_data, "Specify the size of the short data section" } }
```

TARGET_VERSION

このマクロは C の文として定義する。この文は、選択された特定のマシン記述を説明する文字列を stderr に出力するようにする。どのマシン記述でも必ず TARGET_VERSION を定義して欲しい。以下に定義例を示す。

```
#ifdef MOTOROLA
#define TARGET_VERSION \
  fprintf (stderr, " (68k, Motorola syntax)");
#else
#define TARGET_VERSION \
  fprintf (stderr, " (68k, MIT syntax)");
#endif
```

OVERRIDE_OPTIONS

場合によっては、コマンド行オプションのある組合せが、ある特定のターゲット機種では意味をなさないことがある。そういう場合を考慮に入れるにはマクロ OVERRIDE_OPTIONS を定義する。このマクロは、定義されていると、全てのコマンド行オプションがパーズされた直後に一回だけ実行される。
このマクロを使って、-O オプションを指定したときに色々な特別の最適化を実行するようにしてはいけない。そのためには、OPTIMIZATION_OPTIONS というマクロがある。 

OPTIMIZATION_OPTIONS (level, size)

このマクロは、定義されていれば、最適化レベルが決まった直後で、コマンド行オプションの残りがパースされる前に一回だけ実行される。このマクロに設定されている値は、他のコマンド行オプションのデフォルト値として使われる。

level は指定された最適化レベルであり、-O2 が指定されれば 2 であり、-O が指定されれば 1、どちらも指定されなければ0 である。

size は、-Os が指定されていればゼロでない値であり、指定されていなければゼロである。

このマクロを使って機種固有ではないオプションを変えるべきではない。機種固有でないオプションは、全てのサポートされている機種で同じ最適化レベルによって統一的に選択されるべきである。このマクロは、機種固有の最適化を有効にするのに使うこと。

このマクロの中で、write_symbols を調べてはいけない。 デバッグ用オプションは、生成コードを変えるとは想定されていない。 

CAN_DEBUG_WITHOUT_FP

フレームポインタ無しでもデバッグできるようにするなら、このマクロを定義する。このマクロが定義されていると GNU CC は、-O が指定されていれば必ず -fomit-frame-pointer オプションを有効にする。

##記憶領域のレイアウト

以下に示すテーブルでは、データのサイズやアラインメントをビット単位で表すマクロの定義を示している。注意して欲しいのは、これらのマクロは定数である必要はないということである。target_flags のような静的変数を参照する C の式でもかまわないのである。See Run-time Target.

BITS_BIG_ENDIAN

バイトの中で最上位のビットが最下位の数を保持しているなら、このマクロを1 に定義する。そうでなければ、0 に定義する。1 に定義した場合は、ビットフィールド命令はビットを最上位ビットから数える。ビットフィールド命令がない場合でも、このマクロは定義しなければならない。その場合は、どんな値に定義してもかまわない。このマクロは定数である必要はない。

このマクロは、構造体のフィールドがバイトまたはワードにどのように詰め込まれるかには影響しない。それは、BYTES_BIG_ENDIAN により制御される。 

BYTES_BIG_ENDIAN

ワードの中の最下位バイトが最下位の数を保持しているなら、このマクロを 1 に定義する。このマクロは定数である必要はない。 

WORDS_BIG_ENDIAN

複数のワードからなるデータ中で最上位のワードが最下位の数を保持しているなら、このマクロを 1 に定義する。これは、メモリとレジスタの両方に適用される。GNU CC は基本的に、メモリ中のワードの順番とレジスタ中のワードの順番が同じであると仮定している。このマクロは定数である必要はない。 

LIBGCC2_WORDS_BIG_ENDIAN

WORDS_BIG_ENDIAN が定数でない場合はこのマクロを定義する。これは WORDS_BIG_ENDIAN と同じ意味を持つ定数値でなければならない。この値は、CPP マクロに基づいて設定されることが多い。 

FLOAT_WORDS_BIG_ENDIAN

DFmode または XFmode、TFmode の浮動小数点数がメモリ中に格納されるときに、符号ビットを含むワードが最下位アドレスに置かれる場合は、このマクロを値 1 として定義する。このマクロが定数である必要はない。

メモリ中に格納されるワードの順序が、複数ワードの整数の場合と同じなら、このマクロを定義する必要はない。 

BITS_PER_UNIT

アドレス可能な格納単位(バイト)中のビット数を定義するマクロである。通常は 8 になる。 

BITS_PER_WORD

ワードのビット数。普通は 32 である。 

MAX_BITS_PER_WORD

ワード中の最大ビット数。定義されていない場合は、デフォルトでBITS_PER_WORD になる。定義する場合は、BITS_PER_WORD が実行時に取りうる最大値である定数値とする。 

UNITS_PER_WORD

ワード中の格納単位数。普通は 4 である。 

MIN_UNITS_PER_WORD

ワード中の格納単位の最小数。定義されていない場合は、デフォルトでUNITS_PER_WORD になる。定義する場合は、UNITS_PER_WORD が実行時に取りうる最小値となる定数値とする。 

POINTER_SIZE

ポインタの幅をビット数で表す。Pmode の幅よりも大きな値を指定してはならない。Pmode の幅と同じでない場合は、POINTERS_EXTEND_UNSIGNED を定義しなければならない。 

POINTERS_EXTEND_UNSIGNED

C の式で、その値は、POINTER_SIZE ビット幅から Pmode に拡張する必要があるポインタがゼロ拡張されるならゼロでない値とし、符号拡張されるなら 0 とする。
POINTER_SIZE が Pmode の幅に同じならこのマクロを定義する必要はない。 

PROMOTE_MODE (m, unsignedp, type)

あるオブジェクトが、型が type であり、指定されたモード m と符号 unsignedp を持ち、レジスタに格納されることになっているなら、このマクロは m と unsignedp を更新する。

多くの RISC マシンでは、全ワードに対して操作を行なう演算しか持っていないので、m が BITS_PER_WORD よりも幅の狭い整数モードならこのマクロで m を word_mode に設定するように定義する。大部分の場合、整数モードの場合だけ拡幅すべきである。何故なら、精度の高い浮動小数点演算は、普通は精度の低いものより高くつくからである。

多くの機種では、このマクロの定義で unsignedp を変えることはしていない。だが、機種によっては特定のモードについては符号付きか符号なしかのどちらかの量を優遇する命令を持っている。例えば、DEC Alpha では、メモリからの 32ビットのロードと 32ビットの加算命令は結果を 64 ビットに符号拡張する。そういう機種では、どちらの拡張が効率が良いかにしたがって unsignedp を設定するようにする。

m を更新することが絶対にないのであればこのマクロは定義しないこと。 

PROMOTE_FUNCTION_ARGS

PROMOTE_MODE で記述される格上げを関数の出力(?)引数に対しても行なうべきなら、このマクロを定義する。 
PROMOTE_FUNCTION_RETURN
PROMOTE_MODE で記述される格上げを関数の戻り値に対しても行なうべきなら、このマクロを定義する。

このマクロが定義されるなら、FUNCTION_VALUE はPROMOTE_MODE によりなされるのと同じ格上げを実行しなければならない。 

PROMOTE_FOR_CALL_ONLY

PROMOTE_MODE で記述される格上げを、関数の出力引数か関数の戻り値に対してのみ、PROMOTE_FUNCTION_ARGS とPROMOTE_FUNCTION_RETURN で指定されているように、行なうべきなら、このマクロを定義する。 

PARM_BOUNDARY

スタック上の関数のパラメータに通常必要とされるアラインメントをビット数で表す。スタックに置かれるパラメータは全て、データ型によらず、少なくともこの量だけのアラインメントが取られる。多くのマシンでは、この大きさは整数の大きさと同じである。 

STACK_BOUNDARY

スタックポインタに保証されているアラインメントがあるなら、このマクロを定義する。定義は、望まれるアラインメントをビット単位で表す C の式とする。この値は、PREFERRED_STACK_BOUNDARY が定義されていない場合のデフォルトとして使われる。 

PREFERRED_STACK_BOUNDARY

スタックポインタについて一定のアラインメントを保持したいのであればこのマクロを定義する。定義は、望ましいアラインメントをビット数で表す C の式とする。STACK_BOUNDARY も定義されている場合は、このマクロを評価したなら、STACK_BOUNDARY 以上の値になるようにしなければならない。
PUSH_ROUNDING が定義されていなければ、スタックは常に指定された境界に整合される。PUSH_ROUNDING が定義されていて、アラインメントの制限の指定がPREFERRED_STACK_BOUNDARY より緩ければ、スタックは引数をプッシュしている間一時的に整合が取られないことがある。 

FUNCTION_BOUNDARY

関数の入り口点で必要とされるアラインメントをビット数で表す。 

BIGGEST_ALIGNMENT

対象機種で任意のデータ型が要求するうちで最大のアラインメントをビット数で表したもの。 

MINIMUM_ATOMIC_ALIGNMENT

定義されていれば、最小のアラインメントをビット数で表したものである。これは、隣り合うオブジェクトを煩わせることなく、一回の操作で参照可能なオブジェクトに与えることができるものである。通常、BITS_PER_UNIT になるが、バイト単位あるいはハーフワード単位のストア演算がないマシンではもっと大きくなりうる。 

BIGGEST_FIELD_ALIGNMENT

この機種で任意の構造体のフィールドが要求するアラインメントをビット数で表したもの。これが定義されていると、構造体のフィールドに関してはBIGGEST_ALIGNMENT に優先する。 

ADJUST_FIELD_ALIGN (field, computed)

通常の方法で計算したアラインメントが computed である場合の、ある構造体フィールド field のアラインメントを表す式。GNU CC は、これが定義されていれば、構造体のフィールドに限って、BIGGEST_ALIGNMENT や BIGGEST_FIELD_ALIGNMENT の値の代わりにこの値を使う。 

MAX_OFILE_ALIGNMENT

対象機種向けのオブジェクトファイル形式でサポートされている最大のアラインメント。このマクロで、__attribute__ ((aligned (n))) という構文を使って指定できるアラインメントを制限する。これが定義されていない場合は、デフォルト値は BIGGEST_ALIGNMENT になる。 

DATA_ALIGNMENT (type, basic-align)

定義するなら、静的メモリ領域に置かれる変数のアラインメントを計算する C の式とする。type はデータの型であり、basic-align はそのオブジェクトが通常持つであろうアラインメントである。通常のアラインメントの代わりに、このマクロの値を使ってそのオブジェクトのアラインメントを取る。

このマクロが定義されなければ、basic-align が使われる。

このマクロの使い道は、一つには、より少ないキャッシュラインに収まるように、中間の大きさのデータのアラインメントを大きくすることにある。もう一つの使い方は、文字の配列をワード境界に整合することを強制することで、定数を文字配列にコピーするような strcpy の呼び出しをインライン展開可能にすることにある。 

CONSTANT_ALIGNMENT (constant, basic-align)

メモリに置かれる定数に与えるべきアラインメントを計算する C の式を定義する。constant が定数で、basic-align がそのオブジェクトの通常のアライメントである。このマクロの値が、上記のアラインメントの代わりに、このオブジェクトを整合境界に置くのに使われる。
このマクロが定義されていなければ、basic-align が使われる。

このマクロの典型的な使い方は、文字列定数をワード境界に整合することを強制することで、定数をコピーする strcpy の呼び出しをインライン展開可能にすることにある。 

LOCAL_ALIGNMENT (type, basic-align)

定義されていれば、一個の C の式であり、局所的なメモリ領域に置かれる変数のアラインメントを計算する。type はデータ型であり、basic-align はそのオブジェクトが通常取るであろうアラインメントである。このマクロの値が、上記のアラインメントの代わりに、このオブジェクトを整合境界に置くのに使われる。
このマクロが定義されていない場合は、basic-align が使われる。

このマクロの使い道の一つは、中間の大きさのデータのアラインメントをより少ないキャッシュ・ラインに全て収まるように大きくすることである。 

EMPTY_FIELD_BOUNDARY

int : 0; のような空のビットフィールの後に続くビットフィールドに指定すべきビット単位のアラインメントである。
PCC_BITFIELD_TYPE_MATTERSもまた、空のビットフィールドから生じるアラインメントに影響を及ぼすことに注意してほしい。 

STRUCTURE_SIZE_BOUNDARY

構造体や共用体の大きさが、その倍数になるべきビット数。各構造体や共用体の大きさは、この定数の倍数に切り上げられる。
このマクロを定義しない場合は、デフォルトは BITS_PER_UNIT と同じになる。 

STRICT_ALIGNMENT

指定されたデータが満足すべきアラインメントにあっていない場合、命令が正しく動作しないなら、このマクロの値を 1 に定義する。命令が単に遅くなるだけなら、0 に定義する。 

PCC_BITFIELD_TYPE_MATTERS

ビットフィールドとビットフィールド含む構造体のアラインメントの扱いを、他の多くの C コンパイラが取っている方法に合わせる場合は、このマクロを定義する。
この場合の動作は、ビットフィールドに指定した型(int、short、またはその他の整数型)が、構造体全体のアライメントに制約を課す。これは、その構造体が、その型の普通の(ビットフィールドではない)フィールドを持っているかのようになる。さらに、このビットフィールドは、その普通のフィールド内に収まるように構造体内で配置される。普通のフィールドの境界を越えることはない。

つまり、多くの機種では型が int のビットフィールドは4バイト境界を越えることはないし、構造体全体のアライメントは4バイトに強制される。(実際に使われる場合、このアライメントは 4 バイトでないこともある。他のアラインメント関係のパラメータにより制御される。)

このマクロは、C の式として定義する。この式の値が 0 でなければ上記の動作を有効にする。

このマクロが定義されていなかったり、値がゼロの場合は、ビットフィールドの中にはアラインメント境界を越えるものもありうる。メモリを直接参照できる、insv や extv、extzv insn があれば、コンパイラはそのような参照をサポート出来る。

ビットフィールドを使えるようにするもう一つの有名な方法は、STRUCTURE_SIZE_BOUNDARY を BIGGEST_ALIGNMENT と同じ大きさに定義することである。そうすると、どの構造体もワード単位でアクセスできる。

対象の機種がビットフィールドを持っていないか、STRUCTURE_SIZE_BOUNDARY を上記のように定義しない限り、PCC_BITFIELD_TYPE_MATTERS が 0 でない値を持つようにしなければならない。

目的が、何か別のコンパイラで使われているビットフィールドの配置規約と同じ規約を GNU CC に使わせることにあるなら、以下に示す方法で、他のコンパイラがどうなっているかを調べることができる。このプログラムをコンパイルして実行すれば良い。

```
struct foo1
{
  char x;
  char :0;
  char y;
};

struct foo2
{
  char x;
  int :0;
  char y;
};

main ()
{
  printf ("Size of foo1 is %d\n",
          sizeof (struct foo1));
  printf ("Size of foo2 is %d\n",
          sizeof (struct foo2));
  exit (0);
}
```

これが 2 と 5 を出力するなら、コンパイラの動作はPCC_BITFIELD_TYPE_MATTERS から得られるものである。 

BITFIELD_NBYTES_LIMITED

PCC_BITFIELD_TYPE_MATTERS と同様だが、その効果は構造体内のビットフィールドの整合に限られる。 
ROUND_TYPE_SIZE (type, computed, specified)
このマクロは、一個の型(type により木ノードとして与えられる) 全体の大きさを表す式を定義する。これを定義するのは、普通の方法で計算した大きさがcomputed であり、アラインメントがspecified となっている場合である。

デフォルトは、computed を specified の倍数に切り上げる。 

ROUND_TYPE_ALIGN (type, computed, specified)

このマクロは、一個の型(type により木ノードとして与えられる) のアラインメントを表す式を定義する。これを定義するのは、通常の方法で計算したアラインメントがcomputed であり、明示的に指定されたアラインメントがspecified となっている場合である。

デフォルトでは、specified の方が大きければそれを使う。さもなければ、computed と BIGGEST_ALIGNMENT の小さいほうを使う。 

MAX_FIXED_MODE_SIZE

実際に使われるべき最大整数のマシンモードの大きさをビット数で表す整数式。この大きさ以下の全ての整数マシンモードは、適切な大きさの構造体と共用体に使うことができる。このマクロが定義されていない場合は、GET_MODE_BITSIZE (DImode) が仮定される。 

STACK_SAVEAREA_MODE (save_level)

定義されていれば、enum machine_mode 型の式であり、save_stack_level という名前付きパターン(see Standard Names) のセーブ領域オペランドのモードを指定する。save_level は、SAVE_BLOCK、SAVE_FUNCTION、SAVE_NONLOCAL のどれかであり、三つの名前付きパターンのうち、どれのモードが指定されているかを選択する。

必ず Pmode を返すのであれば、このマクロを定義する必要はない。このマクロを定義するのは、save_stack_level パターンが32 ビットモードと 64 ビットモードの両方をサポートする必要がある場合が一番多いだろう。 

STACK_SIZE_MODE

定義されていれば、enum machine_mode 型の式であり、allocate_stack という名前付きパターン(see Standard Names) のサイズ・インクリメント・オペランドのモードを指定する。

必ず word_mode を返すのであれば、このマクロを定義する必要はない。このマクロを定義するのは、allocate_stack パターンが32 ビットモードと 64 ビットモードの両方をサポートする必要がある場合が一番多いだろう。 

CHECK_FLOAT_VALUE (mode, value, overflow)

(double 型の)値 value がモード mode として有効かどうかを検査する C の式である。対象とするターゲット機種のモード mode で表せる範囲の値に、value が収まるかどうかを検査するということを意味する。モード mode のクラスは常に MODE_FLOAT である。overflow は、その値が既に範囲からはみでていることがわかっている場合は、ゼロでない値になる。

value が有効でないか、overflow がゼロでなければ、overflow を 1 に設定し、何らかの有効な値を value に割り当てるべきである。無効な値をそのままにしておくと、コンパイラが不正なアセンブラコードを出力し、Unix のアセンブラを異常終了させる可能性がある。

なすべき処理がなければこのマクロを定義する必要はない。 

TARGET_FLOAT_FORMAT

ターゲットマシンの浮動小数点数形式を識別するためのコード。定義済の値が三つある。
IEEE_FLOAT_FORMAT
IEEE 形式の浮動小数点数であることを示す。これがデフォルトになるので、IEEE 形式を使っている時はこのマクロを定義する必要はない。 

VAX_FLOAT_FORMAT

VAX で使用されている固有の形式であることを示す。 

UNKNOWN_FLOAT_FORMAT

このコードは、何か他の形式であることを示す。
このマクロの値を HOST_FLOAT_FORMAT(see Config)と比べて、ターゲットマシンのフォーマットがホストマシンと同じかどうかを決める。何か他の形式が、サポートされている機種で実際に使われているのなら、そのための新しいコードで定義する必要がある。

メモリ中に格納された浮動小数点数のワードの並び方は、ターゲットマシンについては FLOAT_WORDS_BIG_ENDIAN で、ホストマシンについては HOST_FLOAT_WORDS_BIG_ENDIAN で制御される。 

DEFAULT_VTABLE_THUNKS

GNU CC は、C++ の仮想関数テーブル(vtable)の実装方法を二種類サポートしている。伝統的な方法と「thunks」と呼ばれる方法である。-fvtable-thunk オプションでどちらかの方法を選択する。このオプションのデフォルト値を表す C の式としてこのマクロを定義する。DEFAULT_VTABLE_THUNKS が 0 なら、GNU CC はデフォルトでは伝統的な実装方法を取る。「thunk」の実装の方が効率が良い(特に、ASM_OUTPUT_MI_THUNK を実装している場合。Function Entry を参照)。だが、伝統的な実装でコンパイルされたコードとのバイナリ互換性がない。新規に移植を行うなら、DEFAULT_VTABLE_THUNKS を 1 に定義しよう。

このマクロを定義しなければ、-fvtable-thunk のデフォルトは 0 になる。

##ソース言語のデータ型のレイアウト

以下のマクロ群で、コンパイルされるプログラムで使用される基本データ型の大きさと特徴を定義する。前節のマクロと違うのは、C 言語、C 言語に関係する言語に固有の特徴を示すものであり、基本的なストレージ配置を示すものではないという点にある。

INT_TYPE_SIZE

ターゲットマシンの int 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで1ワードになる。 

MAX_INT_TYPE_SIZE

ターゲットマシンの int 型の大きさの最大値をビット数であらわしたもの。定義されていない場合は、デフォルトで INT_TYPE_SIZE になる。定義する場合は、INT_TYPE_SIZE が実行時に取りうる最大の定数値に定義する。これは、cpp で使われる。 

SHORT_TYPE_SIZE

ターゲットマシンの short 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで半ワードになる。(もしこれが一ストレージ単位よりも小さくなるなら、一単位に切り上げられる。) 

LONG_TYPE_SIZE

ターゲットマシンの long 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで一ワードになる。 

MAX_LONG_TYPE_SIZE

ターゲットマシンの long 型の大きさの最大値をビット数であらわしたもの。定義されていない場合は、デフォルトで LONG_TYPE_SIZE になる。定義する場合は、LONG_TYPE_SIZE が実行時に取りうる最大の定数値に定義する。これは、cpp で使われる。 

LONG_LONG_TYPE_SIZE

ターゲットマシンの long long 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで二ワードになる。GNU Ada をサポートする場合には、このマクロの値は少なくとも 64 でなければならない。 

CHAR_TYPE_SIZE

ターゲットマシンの char 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで1/4ワードになる。(もしこれが一ストレージ単位よりも小さくなるなら、一単位に切り上げられる。) 

MAX_CHAR_TYPE_SIZE

ターゲットマシンの char 型の大きさの最大値をビット数であらわしたもの。定義されていない場合は、デフォルトで CHAR_TYPE_SIZE になる。定義する場合は、CHAR_TYPE_SIZE が実行時に取りうる最大の定数値に定義する。これは、cpp で使われる。 

FLOAT_TYPE_SIZE

ターゲットマシンの float 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで1ワードになる。 

DOUBLE_TYPE_SIZE

ターゲットマシンの double 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで2ワードになる。 

LONG_DOUBLE_TYPE_SIZE

ターゲットマシンの long double 型の大きさをビット数で表す C の式。これを定義しない場合は、デフォルトで2ワードになる。 

WIDEST_HARDWARE_FP_SIZE

ハードウェアでサポートされている最大精度の浮動小数点形式の大きさをビット数で表す C の式。このマクロを定義する場合は、LONG_DOUBLE_TYPE_SIZE 以下の値を指定しなければならない。このマクロを定義しない場合は、LONG_DOUBLE_TYPE_SIZE の値がデフォルトになる。 

DEFAULT_SIGNED_CHAR

値が 1 か 0 になる式で、それぞれchar 型がデフォルトでは符号付きか符号無しかを示す。ユーザは、いつでも -fsigned-char や-funsigned-char オプションで変更できる。 

DEFAULT_SHORT_ENUMS

enum 型に、その型の取りうる値の範囲を表現するのに必要なバイト数のみを割り当てるかどうかを指定する C の式を定義する。ゼロでない値を指定すると必要なバイト数のみを割り当てる。値がゼロなら、全ての enum 型は int と同じく割り当てられる。
このマクロを定義しなければ、デフォルトは 0 である。 

SIZE_TYPE

大きさを示す値に使うデータ型名を表す文字列を指定する C の式を定義する。typedef 名 size_t は、この文字列の内容を使って定義される。

この文字列にはキーワードを二つ以上書いても良い。その場合、キーワード同士を空白で区切り、最初に長さを表すキーワードを書き、次に必要なら unsigned を、最後に int を書くようにする。この文字列は、c-decl.c というファイルの関数 init_decl_processing で定義されているデータ型名の一つに厳密に一致しなければならない。int を省略したり、順序を変えたりしてはならない。そうすると、起動時にコンパイラが異常終了してしまう。

このマクロを定義しないと、デフォルトは "long unsigned int" になる。 

PTRDIFF_TYPE

二つのポインタ同士の引き算の結果に使うデータ型名を表す文字列を指定する C の式を定義する。typedef 名 ptrdiff_t は、この文字列の内容を使って定義される。詳細は上の SIZE_TYPE を参照のこと。

このマクロを定義しないと、デフォルトは "long int" になる。 

WCHAR_TYPE

幅広文字に使うデータ型名を表す文字列を指定する C の式を定義する。typedef 名 wchar_t は、この文字列の内容を使って定義される。詳細は上の SIZE_TYPE を参照のこと。

このマクロを定義しないと、デフォルトは "int" になる。 

WCHAR_TYPE_SIZE

幅広文字に使うデータ型の大きさをビット数で表した C の式。これは cpp で使われる。cpp は、WCHAR_TYPE を使うことができない。 

MAX_WCHAR_TYPE_SIZE

幅広文字のデータ型の最大の大きさをビット数で表したもの。これが定義されていない場合は、デフォルトは WCHAR_TYPE_SIZE になる。定義されている場合は、WCHAR_TYPE_SIZE が実行時に取りうる最大値となる定数値になる。これは、cpp で使われる。 

OBJC_INT_SELECTORS

Objective C のセレクタの型を int とすべきなら、このマクロを定義する。
このマクロが定義されていなければ、セレクタは struct objc_selector * 型になる。 

OBJC_SELECTORS_WITHOUT_LABELS

コンパイラが、全てのセレクタを一つのベクトルに統合することができ、そのベクトルの開始点のラベル一つだけを使う場合には、このマクロを定義する。定義しない場合は、コンパイラは各セレクタに各々のアセンブララベルを与えなければならない。

一部の機種では、各セレクタに別々のラベルを与えることが大事で、そうすることによってリンカが重複したセレクタを消去出来るようになる。 

TARGET_BELL

C の定数式で、エスケープ・シーケンス \a に対応する整数値を表す。 

TARGET_BS

TARGET_TAB

TARGET_NEWLINE

C の定数式で、それぞれ、エスケープ・シーケンス \b、
\t、\n に対応する整数値を表す。 

TARGET_VT

TARGET_FF

TARGET_CR

C の定数式群で、それぞれ、エスケープ・シーケンス \v、\f、\r に対応する整数値を表す。

##レジスタの使用方法

この節では、ターゲットマシンにどんなレジスタがあり、一般的にはどのように使うことができるかを記述する方法を説明する。

ある特定の命令でどのレジスタが使用できるかは、レジスタクラスを使って記述する。Register Classes を参照のこと。レジスタを使ってスタックフレームをアクセスするための情報については、Frame Registers を参照のこと。レジスタを使って値を渡す方法については、Register Arguments を、レジスタで値を返す方法については、Scalar Return を参照。

* Register Basics: レジスタの数と種類
* Allocation Order: レジスタ割り当ての順序
* Values in Registers: 各レジスタが保持できる値の種類
* Leaf Functions: 末端関数にレジスタ番号付け替え
* Stack Registers: 80387 のようなレジスタスタックの操作
* Obsolete Register Macros: 80387 で以前使われていたマクロ

##レジスタの基本的特徴

レジスタには色々な特徴がある。

FIRST_PSEUDO_REGISTER

コンパイラに知らせるべきハードウェアレジスタの数。ハードウェアレジスタの番号は、0 から FIRST_PSEUDO_REGISTER-1 になる。つまり、最初の疑似レジスタ番号は FIRST_PSEUDO_REGISER になる。 

FIXED_REGISTERS

コンパイルされたコード全体を通して決まった目的で使用され、そのために一般の目的で使用することのできないレジスタを指定するための初期化子である。このようなレジスタとしては、スタックポインタ、フレームポインタ(フレームポインタを必要としないときは汎用レジスタとして使うことができるような機種の場合は除く)、アドレス可能なレジスタの一つとして考えることのできる機種ではプログラムカウンタ、あるいはある標準的な使い方をするように番号が付けられた他のレジスタ等がある。

この情報は、一連の数字コンマで区切り、中括弧で囲んで表す。n 番目の数字は、レジスタ n が固定であれば 1 で、固定でなければ 0 である。

このマクロで初期化されたレジスタの表、それに以下のマクロのどれかで初期化された表は、次のどちらかの方法で上書きされる可能性がある。つまり、マクロ CONDITIONAL_REGISTER_USAGE の作用により自動的にか、あるいはユーザが指定したコマンド行オプション -ffixed-reg、-fcall-used-reg、-fcall-saved-reg により書き換えられる。 

CALL_USED_REGISTERS

FIXED_REGISTERS とほぼ同様だが、固定レジスタに加えて、(一般には)関数呼び出しで破壊されるレジスタについても 1 とする。このため、このマクロにより、関数呼び出しを越えて保存されなければならない値の一般的な割当には利用できないレジスタを識別する。

あるレジスタの CALL_USED_REGISTERS での値が 0 なら、そのレジスタが関数内で使われていれば、コンパイラは自動的に、そのレジスタを関数の入り口点でセーブし、関数の終了点でリストアする。 

HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)

一個の C の式。この式は、モード mode の値を、その一部が破壊されることなく呼出しを越えて、ハードレジスタ番号regno に格納するのが許されない時はゼロでない値になる。ほとんどの機種ではこのマクロを定義する必要はない。レジスタの全内容を呼出しを越えては保存しない機種でのみ必要になる。 

CONDITIONAL_REGISTER_USAGE

0個以上の C の文で、四つの変数 fixed_regs と call_used_regs、global_regs(この三つは char [] 型)、reg_class_contents (HARD_REG_SET 型)を条件により更新する。このマクロが呼ばれる前に、fixed_regs、call_used_regs、reg_class_contents がそれぞれ、FIXED_REGISTERS、CALL_USED_REGISTERS、REG_CLASS_CONTENTS により初期化され、global_regs がクリアされ、コマンド行オプション-ffixed-reg、-fcall-used-reg、-fcall-saved-reg がどんなものであれ適用される。

これは、固定レジスタや呼び出し破壊レジスタがターゲットのフラグに依存する場合に必要になる。

することがなければ、このマクロを定義する必要はない。

あるクラスのレジスタ全体の使用法がターゲットのフラグに依存する場合は、そのことを GCC に知らせるのにこのマクロを使うことができる。このマクロで、GCC で使うべきでないクラスのレジスタのそれぞれについて、fixed_regs と call_used_regs を 1 になるように更新する。また、マクロ REG_CLASS_FROM_LETTER を定義して、使うべきでないクラスの文字を引数として呼ばれた場合は、NO_REGS を返すようにする。

(だが、このクラスが GENERAL_REGS に含まれておらず、このクラスを許す制約を持つ全ての insn のパターンが、ターゲットスイッチにより制御されるなら、GCC は、ターゲットスイッチが反対しているならこれらのレジスタを使うのを自動的に避ける。) 

NON_SAVING_SETJMP

このマクロが定義されていてかつその値がゼロでない場合は、setjmp とその関連関数がレジスタのセーブに失敗するか、あるいは longjmp がレジスタのリストアに失敗するということを意味する。これを補償するために、コンパイラはsetjmp を使っている関数ではレジスタに変数を置くのを避ける。 

INCOMING_REGNO (out)

ターゲット機種にレジスタウィンドウがあればこのマクロを定義する。これは C の式であり、呼び出し側関数からは out と見えるレジスタ番号に対応するレジスタを、被呼び出し側関数から見た場合のレジスタ番号を返す。レジスタ番号 out が外向きのレジスタでなければout を返す。 

OUTGOING_REGNO (in)

ターゲット機種にレジスタウィンドウがあればこのマクロを定義する。これは C の式であり、被呼び出し側関数からは in と見えるレジスタ番号に対応するレジスタを、呼び出し側関数から見た場合のレジスタ番号を返す。レジスタ番号 in が内向きのレジスタでなければin を返す。


##レジスタの割当順

レジスタの割り当てには順番がある。

REG_ALLOC_ORDER

定義されていれば、整数のベクトルの初期化子である。GNU CC が優先して使うべき順番に並んでいる、ハードレジスタ番号群を含む。(最も優先すべきものから最も優先度の低いものへという順番である。)

このマクロが定義されていないと、レジスタは一番小さい番号から先に使われる(等しいもの以外は全て)。

このマクロの使い道の一つは、一番大きな番号のレジスタを常にセーブする必要があり、かつ、 複数のレジスタをセーブする命令が連続したレジスタの列しかサポートしていない機種の場合である。そういう機種では、REG_ALLOC_ORDER を、割当可能な一番大きな番号のレジスタを先に列挙する初期化子になるように定義する。 

ORDER_REGS_FOR_LOCAL_ALLOC

一個の C の文(セミコロンなし)であり、基本ブロックに局所的な疑似レジスタ用のハードレジスタを割り当てる順番を選択する。

希望のレジスタの順番を配列 reg_alloc_order に格納する。要素 0 は最初に割り当てるレジスタとすべきである。要素 1 がその次のレジスタで、以下同様である。

マクロの本体では、このマクロの実行前の reg_alloc_order の内容について何も仮定してはいけない。

大部分の機種では、このマクロを定義する必要はない。

##レジスタへの値の収まり方

この節では、どんな種類の値(特に、どのマシンモード)を各レジスタが保持できるのか、そして、指定されたモードに必要な連続するレジスタはいくつ必要なのかを記述するマクロについて説明する。

HARD_REGNO_NREGS (regno, mode)

レジスタ番号は regno から始まり、モード mode の値を保持するのに必要とされる、連続するハードレジスタの数を表す C の式である。
全てのレジスタがちょうど一ワードである機種では、このマクロの適切な定義は以下のようになる。

```
#define HARD_REGNO_NREGS(REGNO, MODE)            \
   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
    / UNITS_PER_WORD))
```

ALTER_HARD_SUBREG (tgt_mode, word, src_mode, regno)

一個の C の式であり、以下の式に対し調整済みハードレジスタ数を返す。

(subreg:tgt_mode (reg:src_mode regno) word)
これは、ターゲット機種に、SPARC V9 のように、サイズの入り交じったビッグエンディアンのレジスタがある場合に必要になるかもしれない。 

HARD_REGNO_MODE_OK (regno, mode)

モード mode の値を regno 番のハードレジスタ(あるいは、そのレジスタで始まる複数のレジスタ)に格納することが可能なら、ゼロでない値を取る C の式。全てのレジスタが同じ大きさの機種では、適切な定義は以下のようになる。

```
#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
```

固定レジスタの数を検査するコードをこれに入れる必要はない。割当機構はそれらが常に占有されていると想定しているからである。

機種によっては、倍精度の値は偶数番と奇数番のレジスタ対に保持しなければならない。これを実装するには、倍精度のモードでは奇数番のレジスタをはじくように、このマクロを定義すれば良い。

あるモードをあるレジスタにいれても大丈夫なための最低限の要件は、movmode 命令パターンがそのレジスタと、同じクラスの他のハードレジスタの間での移動をサポートし、かつ、ある値をそのレジスタに移動して取り出してもその値を変えないことである。

word_mode を移動するのに使ったのと同じ命令が、それより幅の狭い全ての整数モードに対して動作するので、れを利用する movhi 等のパターンを定義していれば、どのマシンでも HARD_REGNO_MODE_OK がこれらのモードを区別する必要はない。これは、HARD_REGNO_MODE_OK と MODES_TIEABLE_P の間の相互作用のために便利である。全ての整数モードが結合可能であることが望まれる。

多くの機種には、浮動小数点算術演算用の特別なレジスタがある。浮動小数点マシンモードは浮動小数点レジスタでのみ許されると思ってしまう人がよくいる。それは正しくない。整数を保持できるどんなレジスタでも、浮動小数点マシンモードを安全に保持できる。これは、浮動小数演算がそのレジスタで行なえるかどうかには関係しない。整数の移動命令を使って、この浮動小数点値を移動することができる。

だが、機種によっては、その逆は真である。固定小数点マシンモードは浮動小数点レジスタに入れることができない。これは、浮動小数点レジスタが、そこに格納された値を正規化する場合に真になる。なぜなら、浮動小数点数でない値を格納すると正しくない値に変えられてしまうからである。それに該当する場合は、HARD_REGNO_MODE_OK では、浮動小数点レジスタ中の固定小数点マシンモードを拒絶すべきである。だが浮動小数点レジスタが自動的には正規化を行なわない場合は、任意のビットパターンをそのレジスタに格納することができ、問題なく、その値を変えずに取り出すことができるなら、どのマシンモードも浮動小数点レジスタに入れることができ、このマクロをそうするように定義できる。

特別な浮動小数点レジスタで一番大事なことは、浮動小数点算術命令で受け付けるレジスタであるということである。だが、これは HARD_REGNO_MODE_OK とは何の関係もない。そういう命令については適切な制約を書くことで扱える。

機種によっては、浮動小数点レジスタはアクセスが特に遅いことがあるので、浮動小数点演算を行なわないのであれば、浮動小数点レジスタよりもスタックフレームに値を格納したほうが良いだろう。浮動小数点レジスタがクラス GENERAL_REGS に入っていない限り、何かのパターンの制約で要求しない限り浮動小数点レジスタが使われることはない。 

MODES_TIEABLE_P (mode1, mode2)

モード mode1 の値を、コピーすることなしに、モード mode2 でアクセス可能ならゼロでない値を持つ C の式。

HARD_REGNO_MODE_OK (r, mode1) とHARD_REGNO_MODE_OK (r, mode2) が、どの r についても常に同じなら、MODES_TIEABLE_P (mode1, mode2) はゼロでない値になるべきである。任意の r について両者が異なるなら、何か他の機構により、より狭いモードでその値をアクセス出来ることが保証されない限りは、このマクロが 0 を返すようにすべきである。

このマクロは、可能な限り多くの場合にゼロでない値を返すように定義すべきである。そうしておくと、GNU CC のレジスタ割当がより良いものになる。 

AVOID_CCMODE_COPIES

GCC が CCmode レジスタとの間のコピーを避けるべきならこのマクロを定義する。CCmode との間のコピーのサポートが不完全な場合だけこのマクロを定義すること。

##末端関数の扱い

機種によっては、末端関数(すなわち、他の関数の呼び出しがない関数)は、その関数自身のレジスタウィンドウを作らないのであれば、より効率良く実行させることができる。これが意味することは、通常届けられるレジスタの代わりに、呼びだし側によって渡されたレジスタで引数を受け取る必要があるということである。

末端関数が特別に取り扱われるのは、一般には他に幾つかの条件も満たされるときに限られる。例えば、末端関数ではレジスタをその関数自身の変数や一時領域にしか使わない場合が多い。我々は「末端関数」という言葉で、この特別な取扱いが可能な関数を指すことにする。このため、関数呼び出しのない関数は必ずしも「末端関数」とは限らないことになる。

GNU CC は、関数が末端関数としての取扱いに向いているかどうかを知る前にレジスタ番号を割り当てる。そのため、末端関数を出力するにはレジスタ番号の付け替えをする必要がある。以下のマクロでこの処理を行なう。

LEAF_REGISTERS

あるベクトルの C の初期化子。ハードレジスタ番号が添え字となる。末端関数処理の対象候補で使えるレジスタに対しては要素が 1 となる。

末端関数用の処理の中にレジスタ番号の付け替えがあるなら、ここで印を付けたレジスタは番号付け替えの前のものであり、GNU CC が普通に割り当てたものである。番号付け替えの後で、アセンブラコード中で実際に使われるレジスタは、このベクトルの中で 1 と印を付けるべきである。

ターゲット機種が末端関数の取扱いを最適化する手段を提供している場合にだけこのマクロを定義すること。

LEAF_REG_REMAP (regno)

一個の C の式で、その値は、関数が末端関数として取り扱われるときは、regno を番号付け替えした後のレジスタ番号になる。

regno が、番号付け替えの前には末端関数に現れるべきでないレジスタ番号なら、この式の値は -1 となるべきで、そうするとコンパイラがアボートする。

このマクロは、ターゲット機種が末端関数の扱いを最適化する手段を提供しており、そのためにはレジスタの番号付け替えが必要である場合にのみ、定義する。

通常、FUNCTION_PROLOGUE と FUNCTION_EPILOGUE は末端関数を特別に取り扱わなければならない。C の変数である current_function_is_leaf を調べてゼロでなければ末端関数である。current_function_is_leaf はローカルレジスタの割当に先だって設定され、以降のコンパイラパスで有効である。また、C の変数 
current_function_uses_only_leaf_regs を調べてゼロでなければ、末端レジスタしか使わない末端関数である。変数 current_function_uses_only_leaf_regs は、再ロード後に有効になり、LEAF_REGISTERS が定義されている場合にのみ意味がある。

##スタックを形成するレジスタ

「レジスタ」の幾つかがスタックを形成するような計算機を扱う特別な機能が存在する。このような計算機には 80386 向けの 80387 コプロセッサがある。スタック・レジスタは、通常、スタックにプッシュされることにより書き込まれ、スタックのてっぺんから相対的に番号が付けられる。

現在、GNU CC は、スタック状レジスタのグループを一つしか扱えず、しかも、そのレジスタは連続した番号になっていなければならない。

STACK_REGS

マシンに何らかのスタック様レジスタがあれば、これを定義する。 

FIRST_STACK_REG

先頭のスタック様レジスタの番号。これはスタックの一番上にあるものである。 

LAST_STACK_REG

最後のスタック様レジスタの番号。これはスタックの底にあるものである。

##レジスタの使用法を調整する古いマクロ

以下の機能はあまりちゃんとは動いていない。これらが存在するのは、80386 の 80387 コプロセッサ向けのコードを正しく生成するのに必要とされるからである。これはもはやマシン記述では使われておらず、将来のバージョンでは削除される可能性がある。なので使わないように。

OVERLAPPING_REGNO_P (regno)

定義されていれば、C の式である。この式は、ハードレジスタ番号regno がオーバーラップレジスタなら、ゼロでない値となる。これは、あるハードレジスタが異なる番号のハードレジスタとオーバーラップしているということを意味する。(このオーバーラップは望ましくないことだが、これがないとサポートできないようなマシンをサポートすることができる。) このマクロは、お互いにオーバーラップしている全てのレジスタについてゼロでない値を返さなければならない。GNU CC は、オーバーラップレジスタをある限られた方法でしか使うことができない。基本ブロック内の割当に使うことができ、再ロードで落とされてしまう可能性がある。それで全てである。

このマクロが定義されていないと、お互いにオーバーラップするハードレジスタはないということになる。それが普通だ。 

INSN_CLOBBERS_REGNO_P (insn, regno)

定義されていれば、C の式である。この式の値は、insn insn が、ハードレジスタ番号 regno の内容を未知の力により破壊されてしまう効果を持っている場合はゼロでない値にすべきである。「未知の力」とはこの場合、その insn の RTL 式はそのような効果を記述していないということである。

このマクロが定義されていないと、未知の力でレジスタの内容を破壊する insn は存在しないということを意味する。それが普通の状況である。その他のものがすべて同じなら、RTL 式を見ればその全ての動作がわかるというのが最も良いのである。

##レジスタクラス

多くのマシンでは、番号のついたレジスタが全て等価であるとは限らない。例えば、あるレジスタ群はインデックスアドレッシングには使用できないとか、あるレジスタ群は一部の命令では使用できない等々。このようなマシンによる制限は、レジスタクラス を使って、コンパイラに知らせる。

レジスタクラスはたくさん定義することができ、それぞれに名前を与えて、どのレジスタがそのクラスに所属するかを指定する。そうしておけば、オペランドとして許されるレジスタクラスを特定の命令パターンに対して指定することができる。

一般に、各レジスタは色々なクラスに所属することになる。事実、ALL_REGS というクラスを作り、全てのレジスタを所属させなくてはならない。もう一つ別の、NO_REGS というクラスを作らなくてはならず、このクラスに所属するレジスタはない。二つのクラスの和を作ると別のクラスになることもあるが、必須ではない。

必須のクラスの一つに GENERAL_REGS がある。この名前には何も特別な意味はないが、オペランドの制約文字 r とg はこのクラスを指す。GENERAL_REGS と ALL_REGS が同じなら、単に ALL_REGS に展開されるマクロとして定義する。

クラスを順序付けて、クラス x がクラス y に含まれるなら、x のクラス番号は y の番号より小さくなるようにする。

GENERAL_REGS 以外のクラスのオペランド制約での指定方法は、機種依存のオペランド制約文字によって行なわれる。色々なクラスに対応する制約文字を定義し、オペランド制約でそれを使うことができる。

ある命令が二つのクラスを両方とも許すような場合は常に、その二つのクラスの和となるクラスを定義すべきである。例えば、ある命令のある特定のオペランドとして、浮動小数点(コプロセッサ) レジスタと汎用レジスタのどちらでも使えるなら、その両方を含む、FLOAT_OR_GENERAL_REGS というクラスを定義すべきである。そうしないと生成されるコードが最上のものではなくなる。

また、そのレジスタクラスについて、ある種の冗長な情報を指定しなければならない。クラス毎に、そのクラスを含んでいるクラスと、そのクラスに含まれるクラスを指定し、クラスの対毎に、その対の和に含まれる最大のクラスを指定する。

複数の連続するレジスタを占める値がある特定のクラスに入ることが期待されるときは、それに使われるレジスタが全てそのクラスに所属しなければならない。このため、レジスタクラスを使って、レジスタ対を偶数番レジスタで始まるように強制的に要求することは出来ない。そのためには、HARD_REGNO_MODE_OK を使う。

ビット毎の論理積やシフト命令の入力オペランドに使われるレジスタクラスには特別な要件がある。そのようなクラスはそれぞれ、固定小数点マシンモード毎に、そのモードからメモリへ、あるいはメモリからそのモードへ転送可能なレジスタのサブクラスがなければならない。例えば、機種によっては、一バイト値(QImode)についての演算は特定のレジスタに限られる。その場合、ビット毎の論理積やシフト命令で使われる各レジスタクラスは、それから一バイト値をロードしたりストア可能なレジスタからなるサブクラスがなければならない。これは、PREFERRED_RELOAD_CLASS が常に可能な値を返すことができるようにするためである。

enum reg_class
ある列挙型で、全てのレジスタクラス名を列挙値として定義しなければならない。NO_REGS は先頭に来なければならない。ALL_REGS は最後のレジスタクラスとならなくてはならず、その後にさらに一個の列挙値 LIM_REG_CLASSES が続く。LIB_REG_CLASSES は、レジスタクラスではないが、クラスが幾つあるかを知らせるためにある。
各レジスタクラスは番号を持っており、それは クラス名を int 型にキャストした値である。この番号は、以下に説明する多くの表の添え字として使われる。 

N_REG_CLASSES

区別できるレジスタクラスの数であり、以下のように定義される。

```
#define N_REG_CLASSES (int) LIM_REG_CLASSES
```

REG_CLASS_NAMES

レジスタクラス名を C の文字列定数として持つ初期化子。この名前は、デバッグ出力で使われることがある。 

REG_CLASS_CONTENTS

レジスタクラスの内容をビットマスクである整数として含む初期化子。n 番目の整数は、クラス n の内容を指定する。整数 mask は次のように解釈される。もし、mask & (1 << r) が 1 なら、レジスタ r はそのクラスに所属する。

レジスタが 32 より多い機種では、このためには一個の整数では足りない。その時は、整数は副初期化子で置き換えられる。副初期化子は、複数の整数を中括弧で囲んだものである。各副初期化子は、hard-reg-set.h で定義されている HARD_REG_SET 型の初期化子として適切でなければならない。 

REGNO_REG_CLASS (regno)

ハードレジスタ regno を含むレジスタクラスを表す値を持つ C の式。一般にはそのようなクラスは複数ある。その場合、「最小」のクラス、つまり、そのレジスタを含むそれ以上小さなクラスがないようなクラスを選ぶ。 

BASE_REG_CLASS

ベースレジスタとして有効なレジスタが所属しなければならないクラス名を定義するマクロである。ベースレジスタとは、レジスタの値に変位を加算したものをアドレスとするときに使われるレジスタである。 

INDEX_REG_CLASS

インデックスレジスタとして有効なレジスタが所属しなければならないクラス名を定義するマクロである。インデックスレジスタとは、その値をスケール因子分掛けたものか、別のレジスタに加算した(同様に変位にも加算される)ものをアドレスとするときに使われるレジスタである。 

REG_CLASS_FROM_LETTER (char)

レジスタクラスについての機種依存のオペランド制約文字を定義するC の式。char があるオペランド制約文字なら、この値は対応するレジスタクラスとなる。オペランド制約文字以外なら、この値は NO_REGS とする。GENERAL_REGS クラスに対応するレジスタ文字 r は、このマクロには渡されないであろうから、それを扱う必要はない。 

REGNO_OK_FOR_BASE_P (num)

レジスタ番号 num がオペランドのアドレスのベースレジスタとして使うのに適当なものなら、0 でない値を持つ C の式。適切なハードレジスタか、あるいは適切なハードレジスタが割り当て済の疑似レジスタのどちらでも良い。 

REGNO_MODE_OK_FOR_BASE_P (num, mode)

REGNO_OK_FOR_BASE_P と同様の C の式だが、この式は mode のメモリ参照のモードを調べる。メモリ参照のモードが、あるレジスタをベースレジスタとして使って良いかどうかに影響するなら、このマクロを定義する。このマクロが定義してあると、コンパイラは REGNO_OK_FOR_BASE_P の代わりにこちらを使う。 

REGNO_OK_FOR_INDEX_P (num)

レジスタ番号 num がオペランドのアドレスのインデックスレジスタとして使うのに適当なものなら、0 でない値を持つ C の式。適切なハードレジスタか、あるいは適切なハードレジスタが割り当て済の疑似レジスタのどちらでも良い。
インデックスレジスタとベースレジスタの違いは、インデックスレジスタはスケーリングされることである。あるアドレスが二つのレジスタの和を含んでいて、そのどちらもスケーリングされないのであれば、どちらか一つが「ベース」となり、他方は「インデックス」というラベルが貼られる。だが、どちらのラベル付が使われても、レジスタがそれぞれの役割を果たす、その機種の制約に収まらなければならない。コンパイラは両方のラベル付を試して、有効なものを一つ見つけ出し、どちらのラベル付も動作しない場合にのみ、一方のレジスタ、あるいは両方のレジスタを再ロードする。 

PREFERRED_RELOAD_CLASS (x, class)

値 x をクラス class のレジスタにコピーする必要があるときに使うレジスタクラスについて制限を追加する C の式。この式の値はあるレジスタクラスである。おそらく class か、別のより小さなクラスである。多くの機種では、以下の定義が安全である。

```
#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
```

より制限の強いクラスを返したほうが良いコードが出るということが時々ある。例えば、68000 の場合には、x が moveq 命令で有効な範囲内にある整数定数であるときは、このマクロの値は class がデータレジスタを含んでいる限り、常に DATA_REGS になる。

x が const_dobule の場合、NO_REGS を返すことにより x を強制的にメモリ定数とすることができる。これは、浮動小数点即値をある種のレジスタにはロード出来ないようなマシンで役に立つ。 

PREFERRED_OUTPUT_RELOAD_CLASS (x, class)

PREFERRED_RELOAD_CLASS と同様だが、入力の再ロードではなく出力の再ロード向けである。このマクロを定義しない場合は、デフォルトは class がそのまま使われる。 

LIMIT_RELOAD_CLASS (mode, class)

一個の C の式。モード mode の値を、通常 クラス class が使われる再ロード・レジスタで保持することが可能であることが必要な場合に使うレジスタクラスについて制限を追加する。

PREFERRED_RELOAD_CLASS とは違って、このマクロは単純にはある再ロードクラスに入らない、ある種のモードが存在するときに使われるべきである。

この値はレジスタクラスである。おそらく、class か何か別のより小さなクラスであろう。

このマクロは、ターゲット機種の制限により、このマクロで何か自明ではないことをする必要があるとき以外は定義しないこと。 

SECONDARY_RELOAD_CLASS (class, mode, x)

SECONDARY_INPUT_RELOAD_CLASS (class, mode, x)

SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, x)

多くの機種では、直接メモリへ、あるいはメモリからコピーできないレジスタがある。あるいは、他の型のレジスタからのコピーさえもできないレジスタが存在することもある。例えば、MQ レジスタは、多くの機種で、汎用レジスタとの間でしかコピー出来ず、メモリとの間でのコピーはできない。機種によっては全てのレジスタとメモリ間でのコピーを許しているものがあるが、あるメモリ位置(例えば、RT のシンボリック・アドレスや、PIC をコンパイルする時の SPARC の特定のシンボリック・アドレス等)を格納するにはスクラッチレジスタを必要とするものがある。場合によっては、中間レジスタとスクラッチレジスタの両方が必要である。

このマクロを定義して、再ロード・パスに、再ロードのためには、データを保持するレジスタに加えて、少なくとも一個のレジスタを割り当てる必要があることを知らせるようにすべきである。特に、x を mode のレジスタ class にコピーするのに中間レジスタが必要な場合は、SECONDARY_INPUT_RELOAD_CLASS を定義して、それに属する全てのレジスタが中間レジスタやスクラッチレジスタとして使えるような最大のレジスタを返すようにすべきである。

mode のレジスタ class を x にコピーするのに中間レジスタやスクラッチレジスタが必要な場合は、SECONDARY_OUTPUT_RELOAD_CLASS を定義して、必要とされる最大のレジスタを返すようにすべきである。入力再ロードと出力再ロードの要件が同じなら、これらの二つのマクロを同じ定義にする代わりに、マクロ SECONDARY_RELOAD_CLASS を使うべきである。

これらのマクロが返す値はしばしば GENERAL_REGS となる。予備のレジスタが必要でない場合は NO_REGS を返す。これは、x と モード mode でクラス class のレジスタの間で、スクラッチレジスタなしで直接コピー可能な場合である。常に NO_REGS を返すのならこのマクロは定義しないこと。

スクラッチレジスタが必要な場合(中間レジスタの必要の有無に関わらず)、see Standard Names で必要とされる、reload_inm かreload_outm のパターンを定義すべきである。これらのパターンは、通常 define_expand で実装され、オペランド 2 がスクラッチレジスタである点を除いて、movm のパターンと同じにすべきである。

一個のレジスタクラスを含む再ロードレジスタとスクラッチレジスタに対する制約を定義する。元の再ロードレジスタ(クラスが class)がパターンで指定された制約に当てはまるなら、このマクロが返す値がスクラッチレジスタのクラスとして使われる。当てはまらないのであれば、再ロードレジスタが二つ追加で必要になる。その二つのレジスタのクラスは、insn パターンの制約から得られる。

x は、疑似レジスタか疑似レジスタの subreg でなければならない。これらは、ハードレジスタかメモリのどちらかにある。どちらにあるかは、true_regnum を使って調べる。疑似レジスタがメモリにあれば -1 を返し、レジスタにあればハードレジスタ番号を返す。

このマクロは、ある特定のクラスのレジスタはメモリにだけコピー可能であり、もう一つの別のクラスのレジスタにはコピーできないという場合は使うべきでない。その場合、二番目の再ロードレジスタは不要であり役に立たない。代わりに、スタック位置を使ってコピーを行なわなければならず、movm パターンはメモリを中間の格納場所として使うべきである。これは、浮動小数点レジスタと汎用レジスタの間で良く起こることである。 

SECONDARY_MEMORY_NEEDED (class1, class2, m)

特定の機種には、レジスタの幾つかはメモリを使わないと他のレジスタにコピーできないという性質がある。そういう機種では、このマクロを次のような一個の C の式に定義する。すなわち、この式は、class1 のレジスタにあるモード m のオブジェクトがクラスclass2 のレジスタにコピーできるのは、class1 のレジスタをメモリにストアしてそのメモリ位置を class2 のレジスタにロードする場合だけなら、ゼロでない値となる。
このマクロは、値が常にゼロになるようなら定義しないこと。 

SECONDARY_MEMORY_NEEDED_RTX (mode)

SECONDARY_MEMORY_NEEDED が定義されていると普通、コンパイラがレジスタのコピーに必要なメモリ位置用のスタックスロットを割り当てる。このマクロが定義されていると、コンパイラは代わりに、このマクロで定義されるメモリ位置を使う。
SECONDARY_MEMORY_NEEDED を定義しない場合は、このマクロを定義しないこと。 

SECONDARY_MEMORY_NEEDED_MODE (mode)

コンパイラが、モード mode の二つのレジスタ間でコピーするのに第二のメモリ位置を必要とするときは、普通は、BITS_PER_WORD ビットの量を保持するのに充分なメモリを確保し、ストアとロード操作を、多ビット幅でそのクラスが mode のクラスと同じであるモードで実行する。
これはほとんどの機種でなすべき正しいことである。レジスタの全ビットがコピーされ、レジスタを狭いモードでアクセスするのを抑止しているからである。これにより、機種によっては浮動小数点レジスタを禁止する。

だが、このデフォルトの動作が正しくない機種もある。例えば、DEC Alpha がそうで、short 型の整数を浮動小数点レジスタにストアする仕方と整数レジスタにストアする仕方が異なる。こういう機種では、デフォルトの拡幅が正しく動作しないので、このマクロを定義して、ある場合には拡幅を抑制しなければならない。詳細については alpha.h を参照のこと。

SECONDARY_MEMORY_NEEDED を定義しない場合や、mode をBITS_PER_WORD ビット長のモードに広げるのが正しい機種の場合は、このマクロを定義しないこと。 

SMALL_REGISTER_CLASSES

機種によっては、ハードレジスタを任意の insn 群を越えて生存させるのは危険が伴う場合がある。こういう機種は普通、特定のレジスタ(例えばアキュムレータ)に値が入っていないといけない命令を持っているので、必要とされるハードレジスタがこのような insn を越えて、別の目的に使われると、再ロードに失敗する。
そういう機種では、SMALL_REGISER_CLASSES をゼロでない値を持つ式として定義する。このマクロの値がゼロでないと、コンパイラはハードレジスタの生存期間を最小化することを試みる。

このマクロをゼロでない値に定義するのは常に安全である。だが、不必要に定義すると、ある場合に実行可能な最適化の程度が減ることになる。必要な場合にこのマクロをゼロでない値に定義しないと、コンパイラはスピルレジスタを使いつくし、致命的エラーのメッセージを出力する。ほとんどの機種では、このマクロは何も定義すべきでない。 

CLASS_LIKELY_SPILLED_P (class)

一個の C の式。この式の値は、クラス class のレジスタに割り当てられた疑似レジスタが、class のレジスタはスピルレジスタとして必要であるために、スピルされそうならゼロでない値となる。
このマクロのデフォルト値は、class にレジスタがちょうど一個ある場合は 1 を返し、それ以外の場合はゼロを返す。ほとんどの機種では、このデフォルトを使うべきである。このマクロを何か他の式に定義するのは、local-alloc.c で割り当てられた疑似レジスタが、それ用のハードレジスタがスピルレジスタ用に必要であるために、結局メモリに取られる場合だけにすること。このマクロが指定されたクラスに対してゼロでない値を返すなら、そのクラスの疑似レジスタは global.c でだけ割り当てられる。global.c は、疑似レジスタを別のレジスタに再割当する方法を知っている。再割当に使える別のレジスタがない場合は、このマクロの定義を変えるべきでない。なぜなら、そういう場合は、定義を変えるとレジスタの割当を遅くするだけであるから。 

CLASS_MAX_NREGS (class, mode)

C の式。モードが mode の値を保持するのに必要な、クラス class の連続するレジスタの最大数を表す。
これは、マクロ HARD_REGNO_NREGS と密接に関係する。実際、マクロ CLASS_MAX_NREGS (class, mode) の値は、クラス class の全ての regno の値について、HARD_REGNO_NREGS (regno, mode) の最大値となるべきである。

このマクロは、再ロードパスにおいて複数ワードの値の扱いを制御する手助けをする。 

CLASS_CANNOT_CHANGE_SIZE

一個の C の式。定義されていれば、レジスタにロードしたときのモードと同じサイズのモードでコンパイラが常にアクセスしなければならないレジスタを含むクラスを表す。
例えば、Alpha の場合は、32ビットの整数オブジェクトか浮動小数点オブジェクトを浮動小数点レジスタにロードすると、64ビットに拡張される。したがって、64ビットのオブジェクトをロードし、次に 32 ビットのオブジェクトとしてストアすると、普通のレジスタがそうであるように、下位の 32 ビットはストアされない。このため、alpha.h ではこのマクロを FLOAT_REGS として定義している。

他に特別なマクロが三つあって、どのオペランドがどの制約文字に収まるかを記述する。

CONST_OK_FOR_LETTER_P (value, c)

一個の C の式。この式は、特定の範囲の整数値を指定する、機種依存のオペランド制約文字(I、J、K、... P) を定義する。c がこれらの文字のどれかであれば、この式で、ある整数である value が適切な範囲にあるかどうかを調べ、そうであれば1 を返し、それ以外の場合は 0 を返す。c がこれらの文字でなければ、value の値によらずにこの式の値は 0 とすべきである。 

CONST_DOUBLE_OK_FOR_LETTER_P (value, c)

一個の C の式。この式は、特定の範囲の const_double の値を指定する機種依存のオペランド制約文字を定義する(G か H)。
c がこれらの文字のどれかであれば、この式で、コード const_double の RTX である value を調べて、適切な範囲にあれば 1 を返し、それ以外の場合は 0 を返す。c がこれらの文字でなければ、value に関わらず、この式の値は 0 とすべきである。

const_double は、全ての浮動小数点定数と DImode の固定小数点定数に使われる。与えられた文字は、どちか片方の値、あるいは両方の値を受け入れることができる。GET_MODE を使ってこの二つの種類を区別することができる。 

EXTRA_CONSTRAINT (value, c)

一個の C の式。オプションの機種依存制約文字(Q、R、S、T、U)を定義する。これらの式を使って、ターゲット機種の特定の型のオペランド、普通はメモリ参照を区別することができる。普通は、このマクロは定義されない。ある特定のターゲット機種で必要な場合は、value が、制約文字 c で表現されるオペランドの型に対応するなら 1 を返す必要がある。c が追加の制約として定義されていない場合は、返される値は value に関わらずに 0 にならなければならない。

例えば、ROMP では、ロード命令は、メモリ参照がシンボリックアドレスを含んでいれば、出力を r0 に置くことができない。制約文字 Q が、シンボリックアドレスを含まないメモリアドレスを表現するものとして定義されている。ある選択肢が、入力に制約 Q が、出力に r が指定されている。次の選択肢は、入力に m が、出力には r0 を含まないレジスタクラスが指定されている。

##スタックレイアウトと呼び出し規約

以下では、スタックのレイアウトと呼び出し規約について述べる。

* Frame Layout:
* Stack Checking:
* Frame Registers:
* Elimination:
* Stack Arguments:
* Register Arguments:
* Scalar Return:
* Aggregate Return:
* Caller Saves:
* Function Entry:
* Profiling:

##基本的なスタックレイアウト

基本的なスタック配置について説明する。

STACK_GROWS_DOWNWARD

ワードをスタック上にプッシュした場合に、スタックポインタの値が小さなアドレス方向に移動するなら、このマクロを定義する。

以下で「もし ... ならこのマクロを定義する」と書いてある場合は、コンパイラはこのマクロを #ifdef で調べるだけなので、何に定義されているかの詳細は関係がない。 

FRAME_GROWS_DOWNWARD

局所変数用のスロットのアドレスのフレームポインタからのオフセットが負であれば、このマクロを定義する。 
ARGS_GROW_DOWNWARD
関数の一連の引数がスタック上でアドレスが減少する方向に置かれるなら、このマクロを定義する。 

STARTING_FRAME_OFFSET

確保すべき局所変数のスロットの、フレームポインタからのオフセットである。

FRAME_GROWS_DOWNWARD であれば、次のスロットのオフセットを、STARTING_FRAME_OFFSET から先頭のスロットの長さを差し引くことで求める。FRAME_GROWS_DOWNWARD でなければ、先頭のスロットの長さをSTARTING_FRAME_OFFSET に加算することで求める。 

STACK_POINTER_OFFSET

スタックポインタレジスタから、出力引数が置かれる先頭の位置へのオフセットを定義する。これが指定されていない場合は、デフォルト値のゼロが使われる。多くの機種ではゼロが適切な値である。

ARGS_GROW_DOWNWARD が定義されている場合は、これは、出力引数が置かれている先頭の位置の直前の位置へのオフセットになる。 

FIRST_PARM_OFFSET (fundecl)

引数ポインタレジスタからの先頭の引数のアドレスのオフセットを定義する。マシンによっては、関数の戻り値型に依存する。

ARGS_GROW_DOWNWARD が定義されている場合は、これは、先頭の引数のアドレスの直前の位置へのオフセットになる。 

STACK_DYNAMIC_OFFSET (fundecl)

スタックポインタレジスタから、例えば alloca により、スタック上に動的に確保されるものへのオフセットを定義する。

このマクロのデフォルト値は、STACK_POINTER_OFFSET に出力引数の長さを足したものある。多くの機種ではこのデフォルト値で正しい値である。詳細は、function.c を参照のこと。 

DYNAMIC_CHAIN_ADDRESS (frameaddr)

呼び出し側フレームへのポインタが格納されているスタックフレームのアドレスを表す RTL を値とする C の式。frameaddr は、スタックフレーム自身のアドレスを表す RTL 式であると仮定する。

このマクロを定義しない場合のデフォルトは、frameaddr の値を返すことである。すなわち、スタックフレームのアドレスが、前のフレームを指すスタックのワードのアドレスでもある。 

SETUP_FRAME_ADDRESSES

定義されていれば、任意のフレームがアクセスできるようにスタックを設定する機種固有のコードを生成する C の式である。例えば、Sparc では、任意のスタックフレームをアクセス可能になる前に全てのレジスタ・ウィンドウをスタックにフラッシュしなければならない。このマクロを定義する必要は滅多にないだろう。 

BUILTIN_SETJMP_FRAME_VALUE
定義されていれば、C の式であり、現在のフレームのアドレスを組み込みの setjmp バッファに格納するのに使われる rtx を保持する。デフォルト値である virtual_stack_vars_rtx が、ほとんどの機種で正しい値である。このマクロを定義する必要が出てくる理由の一つは、hard_frame_pointer_rtx が読者の機種でこのマクロに適した値の場合があるからである。 

RETURN_ADDR_RTX (count, frameaddr)

一個の C の式。その値は、プロローグの後、現在のフレームから count 段さかのぼったフレームの戻りアドレス値を表す RTL である。frameaddr は、count 番目のフレームのフレームポインタか、RETURN_ADDR_IN_PREVIOUS_FRAME が定義されているなら、count - 1 番目のフレームポインタである。

この式の値は count がゼロの場合は常に正しいアドレスにならなければならない。だが、他のフレームの戻りアドレスを決める方法がない場合は NULL_RTX でも良い。 

RETURN_ADDR_IN_PREVIOUS_FRAME

ある特定のスタックフレームの戻りアドレスが直前のスタックフレームのフレームポインタからアクセスされるなら、このマクロを定義する。 

INCOMING_RETURN_ADDR_RTX

一個の C の式。この式の値は、任意の関数の先頭で、プロローグの前においての入力戻りアドレスの位置を表す RTL である。この RTL はある REGか、ある MEM のどちらかである。REG は、戻り値が REG にセーブされることを示し、MEM はスタック上の位置を表す。

このマクロを定義する必要があるのは、DWARF 2 で提供されているような呼び出しフレームデバッグ情報をサポートしたいときだけである。 

INCOMING_FRAME_SP_OFFSET

一個の C の式。この式の値は、任意の関数の先頭で、プロローグの前においてのスタックポインタレジスタの値から、スタックフレームの頂上までのオフセットをバイト数で与える整数である。フレームの頂上は、直前のフレームでのコール命令の直前でのスタックポインタの値として定義される。
このマクロを定義する必要があるのは、DWARF 2 で提供されているような呼び出しフレームデバッグ情報をサポートしたいときだけである。 

ARG_POINTER_CFA_OFFSET

C の式である。引数ポインタから正規フレームアドレス(canonical frame address (cfa))へのオフセットをバイト数で表した整数である。最終的な値は、INCOMING_FRAME_SP_OFFSET で計算した値と一致する必要がある。残念なことに、INCOMING_FRAME_SP_OFFSET はレジスタが仮想的な実体である間は使えないのである。

このマクロを定義する必要があるのは、DWARF 2 で提供されているような呼び出しフレームデバッグ情報をサポートしたいときだけである。

##スタック検査方法の指定

GNU CC は、-fstack-check が指定された場合は、スタックの参照がスタックの境界内に収まっているかどうかを検査する。検査方法は以下の三つの内の一つである。

* マクロ STACK_CHECK_BUILTIN の値がゼロでなければ、GNU CC は、スタック検査をコンフィギュレーションファイルの適切な場所、例えば FUNCTION_PROLOGUE で設定済みであると想定する。GNU CC は他には特別な処理は行なわない。
* STACK_CHECK_BUILTIN がゼロで、mdファイルで名前付きパターンcheck_stack を定義していれば、GNU CC はそのパターンを、スタック値と比較するアドレスである引数を一つ付けて、呼び出す。スタックポインタが範囲外にある場合はエラーを報告するように、このパターンを設定しなければならない。
* 上のどちらも真でない場合は、GNU CC は、以下で定義するマクロの値を使って、定期的にスタックポインタを探るコードを生成する。

普通は以下のマクロの値としてデフォルト値が使われるので、GNU CC は三番目の方法を取ることになる。

STACK_CHECK_BUILTIN

スタック検査が、機種依存の方法でコンフィギュレーションファイルにより行なわれるなら、ゼロでない値となる。読者の機種の ABI がスタック検査を要求しているか、GNU CC の移植性の良い方法よりも幾らか効率の良いスタック検査を行なわせたいのなら、このマクロを定義すべきである。このマクロのデフォルト値はゼロである。 

STACK_CHECK_PROBE_INTERVAL

GNU CC がスタックの探針用命令を生成しなければならない間隔を表す整数である。普通は、スタック領域の終りの「ガード・ページ」の大きさよりも大きくならないように、このマクロを定義する。デフォルト値の 4096 がほとんどのシステムで適切である。 

STACK_CHECK_PROBE_LOAD

GNU CC がスタック探針をロード命令として実行すべきならゼロでない整数となり、ストア命令を使うべきならゼロとなる。デフォルトはゼロであり、ほとんどのシステムで最も効率の良い選択である。 

STACK_CHECK_PROTECT

スタックのオーバフローから回復するのに必要なスタックのバイト数。デフォルト値の 75 ワードがほとんどの機種で適切である。 

STACK_CHECK_MAX_FRAME_SIZE

あるスタックフレームの最大の大きさをバイト数で表す。GNU CC は、非末端関数では、少なくともこれだけのバイト数のスタックが利用可能であることを保証する探針命令を生成する。スタックフレームがこの大きさよりも大きいときは、スタック検査は信頼できなくなり、GNU CC は警告を発する。デフォルトは、GNU CC がほとんどのシステムで一個の命令しか生成しないように選ばれる。普通は、このマクロのデフォルト値は変えるべきではない。 

STACK_CHECK_FIXED_FRAME_SIZE

GNU CC はこの値を見て、上述の警告メッセージを生成する。これは、ある関数で使われるフレームの固定部分の大きさを表し、非呼びだし側セーブのレジスタ、一時変数とユーザ定義変数の領域は含まない。この量については上限を指定するだけで良く、普通はデフォルトの 4 ワードを使う。 

STACK_CHECK_MAX_VAR_SIZE

-fstack-check が指定された場合に、GNU CC がスタックフレームの固定領域に置くオブジェクトの最大の大きさをバイト数で表したもの。GNU CC は、上記のマクロの値からデフォルト値を計算する。普通はそのデフォルトを書き換える必要はない。

##スタックフレームを扱うレジスタ

スタックフレームを指すレジスタについて説明する。

STACK_POINTER_REGNUM

スタックポインタレジスタのレジスタ番号である。FIXED_REGISTERS により固定レジスタとして指定されていなければならない。大抵の機種では、このレジスタはハードウェアによって決められている。 

FRAME_POINTER_REGNUM

フレームポインタレジスタのレジスタ番号である。フレームポインタは、スタックフレーム中の自動変数を参照するのに使われる。マシンによっては、このレジスタがハードウェアによって決められている場合がある。ハードウェアによって決められていない場合は、好きなレジスタをフレームポインタとして使うことができる。 

HARD_FRAME_POINTER_REGNUM

マシンによっては、フレームポインタと自動変数の開始オフセットとのオフセットが、レジスタの確保が完了するまで分からない場合がある。(例えば、セーブされたレジスタがこの二つの位置の間にあるような場合である。) この種類のマシンでは、FRAME_POINTER_REGNUM として特別な固定したレジスタを定義し、オフセットが分かるまでは内部的にこれを使うようにする。そして、HARD_FRAME_POINTER_REGNUM は、フレームポインタとして実際に使われるハードレジスタ番号を定義する。

このマクロは次のような非常に希な場合にだけ定義するべきである。その場合とは、フレームポインタと自動変数の間のオフセットがレジスタ割当が完了するまで計算できないという場合である。このマクロが定義されている場合は、ELIMINABLE_REGS の定義で、FRAME_POINTER_REGNUM を消去して、HARD_FRAME_POINTER_REGNUM か STACK_POINTER_REGNUM に置き換える方法も示さなければならない。

FRAME_POINTER_REGNUM と同じになる場合は、このマクロは定義しないこと。 

ARG_POINTER_REGNUM

引数ポインタレジスタのレジスタ番号である。このレジスタは、関数の引数リストをアクセスするのに使われる。機種によっては、フレームポインタレジスタと同じである。また、機種によっては、ハードウェアによりどのレジスタかが決まっている場合もあるし、引数ポインタレジスタとして任意のレジスタを自分で選択出来る場合もある。引数レジスタがフレームポインタレジスタと同じではない場合は、FIXED_REGISTERS に従って、それに固定レジスタである印を付けるか、それを消去可能になるように調整しなければならない。(see Elimination) 

RETURN_ADDRESS_POINTER_REGNUM

戻りアドレスポインタレジスタのレジスタ番号。これは、現在の関数の戻りアドレスをスタックからアクセスするのに使われる。機種によっては、戻りアドレスが、フレームポインタやスタックポインタや引数ポインタからの固定のオフセットにない場合がある。このレジスタはスタック上の戻りアドレスを指すように定義でき、ELIMINABLE_REGS により、フレームポインタかスタックポインタに変換される。

スタックから戻りアドレスを得る方法が他にあるのなら、このマクロは定義しないこと。 

STATIC_CHAIN_REGNUM

STATIC_CHAIN_INCOMING_REGNUM

関数の静的チェーンポインタを渡すのに使うレジスタの番号である。レジスタ・ウィンドウが使われる場合は、呼び出された関数から見えるレジスタ番号は STATIC_CHAIN_INCOMING_REGNUM である。一方、呼びだし側関数から見えるレジスタ番号は STATIC_CHAIN_REGNUM である。この二つのレジスタが同じなら、STATIC_CHAIN_INCOMING_REGNUM は定義しなくて良い。

静的チェーンレジスタは固定レジスタである必要はない。

静的チェーンがメモリで渡されるなら、これらのマクロは定義すべきではない。代わりに次の二つのマクロを定義すべきである。 

STATIC_CHAIN

STATIC_CHAIN_INCOMING

静的チェーンがメモリで渡されるなら、これらのマクロは、それらがどこに格納されるかを示す mem 式を与える RTX を提供する。STATIC_CHAIN と STATIC_CHAIN_INCOMING は、それぞれ、呼びだし側関数と呼び出された関数から見える位置を表す。前者はスタックポインタからのオフセットの位置にあり、後者はフレームポインタからのオフセット位置にあることが多い。

変数 stack_pointer_rtx、frame_pointer_rtx、arg_pointer_rtx が、これらのマクロの使用に先だって初期化されるので、マクロを参照するのにはこちらの変数を使うべきである。

静的チェーンがレジスタで渡されるなら、先の二つのマクロを代わりに定義すべきである。


##フレームポインタと引数ポインタの消去

フレームポインタと引数ポインタの消去について説明する。

FRAME_POINTER_REQUIRED

ある関数がフレームポインタを持たなければならず、かつ使う必要がある場合はゼロでない値を持つ C の式を定義する。この式は、再ロードのパスで評価される。この式の値がゼロでなければ、その関数はフレームポインタを持つようになる。

原理的にはこの式で現在の関数を調べてその結果に従ってフレームポインタの有無を決定することができるが、ほとんどのマシンでは定数 0 か定数 1 を使えば充分である。そのマシンがフレームポインタなしで生成したコードを許し、かつ、フレームポインタを使わないことで時間や空間の節約になるなら、0 を使う。フレームポインタを使わないことに何の利点もなければ、1 を使う。

場合によっては、フレームポインタなしには正しいコードを生成する方法が分からない場合がある。GNU CC はそういう場合を認識し、FRAME_POINTER_REQUIRED の値に関わらず自動的に関数にフレームポインタを与える。読者が心配することはない。

フレームポインタを必要としない関数では、固定レジスタとしていない限り、フレームポインタレジスタを通常の使用目的に確保することができる。詳細は FIXED_REGISTERS の項を参照のこと。 

INITIAL_FRAME_POINTER_OFFSET (depth-var)

関数のプロローグの直後の時点でのフレームポインタとスタックポインタの値の差を変数 depth-var に格納する作業を行なう、C の文である。この値は、get_frame_size () の結果と二つのレジスタのテーブル、regs_ever_live と call_used_regs 等の情報から計算することができる。

ELIMINABLE_REGS が定義されているなら、このマクロは使われないので定義する必要がない。ELIMINABLE_REGS が定義されていなければ、FRAME_POINTER_REQUIRED が常に真になるように定義されていても、このマクロを定義しなければならない。FRAME_POINTER_REQUIRED が常に真の場合は、depth-var には何を設定しても良い。 

ELIMINABLE_REGS

このマクロが定義されていれば、レジスタ対のテーブルを指す。このレジスタ対のテーブルは、スタックフレーム中を指すレジスタのうち不要なものを消去するために使うものである。このマクロが定義されていない場合は、GNU CC が試みる消去は、フレームポインタへの参照をスタックポインタへの参照に置き換えることだけである。

このマクロの定義は構造体の初期化式のリストからなり、リストの各要素は、置き換え前のレジスタと置き換え後のレジスタ対を指定する。

マシンによっては、引数ポインタの位置はコンパイルが完了するまでは分からない場合がある。そう言う場合は、別個のハードレジスタを引数ポインタとして使わなければならない。このハードレジスタは、フレームポインタか引数ポインタかのどちらかで置き換えることで消去可能である。どちらになるかは、フレームポインタが消去されたかどうかにより決まる。

この場合、以下のように指定しなければならない。

```
#define ELIMINABLE_REGS  \
{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
 {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
 {FRAME_POINTER_REGNUM, 
```

STACK_POINTER_REGNUM}}

引数ポインタをスタックポインタで置き換える消去が先頭に指定されているのは、それが望ましい消去だからであることに注意。 

CAN_ELIMINATE (from-reg, to-reg)

レジスタ番号 from-reg をレジスタ番号 to-reg で置き換える試みが許されているならゼロでない値を返す C の式である。このマクロは ELIMINABLE_REGS が定義されている場合にのみ定義すれば良く、通常は定数 1 になる。というのは、レジスタ消去を妨げるほとんどの場合は、GNU CC が既に知っていることだからである。 

INITIAL_ELIMINATION_OFFSET (from-reg, to-reg, offset-var)

このマクロは、INITIAL_FRAME_POINTER_OFFSET に似ている。指定されたレジスタ対の差の初期値を指定する。ELIMINABLE_REGS が定義されているなら、このマクロを定義しなければならない。 

LONGJMP_RESTORE_FROM_STACK

関数 longjmp が、setjmpが明示的に退避したレジスタではなく、スタックフレームからレジスタを復帰する場合は、このマクロを定義する。このような機種では、ある種の量は、setjmp の呼び出しを越えてレジスタに保存されてはならない。

##関数の引数のスタック渡し

この節で説明するマクロ群は、引数がスタック上にどのように渡されるかを制御する。引数のレジスタ渡しを制御するマクロについては、次の節で参照のこと。

PROMOTE_PROTOTYPES

プロトタイプ宣言で int 型より小さい整数型として宣言されている引数を、実際には int 型として渡すべきである場合にはこのマクロを定義する。ある種の型の不一致によるエラーを避けるだけでなく、マシンによってはより良いコードを生成することがある。 

PUSH_ROUNDING (npushed)

ある命令が npushed バイトをプッシュしようとしたときに実際にスタックにプッシュされるバイト数を表す C の式を定義する。

ターゲットマシンにプッシュ命令がないのなら、このマクロは定義しないこと。このマクロが定義されていなければ、GNU CC は別の戦略をとる。つまり、引数全体のブロックを割り当て、引数をそこに格納する。

マシンによっては、

```
#define PUSH_ROUNDING(BYTES) (BYTES)
```

という定義で充分である。しかし、別のマシンでは、一バイトをプッシュするように見える命令が実際にはアラインメントを維持するために二バイトをプッシュすることがある。そういう場合は以下のように定義する。

```
#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)
```

ACCUMULATE_OUTGOING_ARGS

このマクロが定義されていると、出力引数に必要とされるメモリスペースの最大量は、計算されたうえで、current_function_outgoing_args_size という変数に置かれる。各呼び出しではスタックにはスペースはプッシュされない。代わりに、呼び出される関数のプロローグがこの量だけスタックフレームの大きさを増やす必要がある。

PUSH_ROUNDING と ACCUMULATE_OUTGOING_ARGS の両方を定義するのは正しくない。 

REG_PARM_STACK_SPACE (fndecl)

引数の値がレジスタで渡される場合でも、その引数用にスタックが割り当てられていると、関数の方で仮定すべきであるなら、このマクロを定義する。

このマクロの値は、fndecl で表される関数にレジスタで渡される引数用の領域の大きさをバイト数で表したものである。この値は、GNU CC がライブラリ関数を呼び出すときはゼロになりうる。

この領域は呼びだし側で割り当てることも可能だし、マシン依存のスタックフレームの一部であっても良い。OUTGOING_REG_PARM_STACK_SPACE でどちらかを指定する。 

MAYBE_REG_PARM_STACK_SPACE

FINAL_REG_PARM_STACK_SPACE (const_size, var_size)

関数が、その引数値がレジスタで渡される場合でもスタックスペースを割り当てる場合は、上記のマクロに加えてこれらのマクロを定義する。これらのマクロは、レジスタにある引数用に割り当てられたスタックスペースが、その関数宣言に依存しない単なる定数ではない場合に使うべきである。

最初のマクロの値は、レジスタで渡される引数用に予約されると最初に仮定した領域の大きさをバイト数で表したものである。

二番目のマクロの値は、レジスタで渡される引数用に予約される領域の実際の大きさをバイト数で表したものである。このマクロは引数を二つ取る。スタック上に取られる固定長の引数のバイト数を表す整数と、スタック上に取られる可変長の引数のバイト数を表すツリーである。

これらのマクロが定義されていると、REG_PARM_STACK_SPACE は以下の関数に対してだけ呼び出される。すなわち、libcall 関数、現在の関数、それに、このようなスタックスペースを割り当てなければならないことが知られているとき呼び出される関数である。どの場合にも、このマクロの値は簡単に計算できる。

呼び出された関数がこのようなスタックスペースを必要とするか、必要な場合はどれだけのスペースを予約すれば良いのかを決めるときに、GNU CC はREG_PARM_STACK_SPACE の代わりにこの二つのマクロを使う。 

OUTGOING_REG_PARM_STACK_SPACE

レジスタで渡された引数用の予約領域を割り当てるのが、呼び出し側の責任であるなら、これを定義する。
ACCUMULATE_OUTGOING_ARGS が定義されている場合は、このマクロは、これらの引数用領域をcurrent_function_outgoing_args_size の値に含めるかどうかを制御する。 

STACK_PARMS_IN_REG_PARM_AREA

REG_PARM_STACK_SPACE は定義されているが、スタック上のパラメータがそれで指定された領域をスキップしない場合はこのマクロを定義する。
普通、パラメータがレジスタで渡されない場合は、REG_PARM_STACK_SPACE 領域を越えたスタック上に置かれる。このマクロを定義するとこの動作を抑制し、パラメータをスタック上の自然な位置に渡すようにする。 

RETURN_POPS_ARGS (fundecl, funtype, stack-size)

関数が戻るときにポップする自分自身の引数のバイト数を表す C の式。あるいは、その関数は自分では引数をポップしないために呼びだし側が、その関数が戻った後で、全部ポップしなければならないときは、0 である。
fundecl は一個の C の変数であり、その値は問題の関数を記述する木ノードである。通常、このノードの型は、関数の宣言を記述する FUNCTION_DECL である。これから、その関数の DECL_MACHINE_ATTRIBUTES を得ることができる。

funtype は一個の C の変数であり、その値は問題の関数を記述する木ノードである。通常、このノードの型は、関数のデータ型を記述する FUNCTION_TYPE である。これから、戻り値と引数(既知であれば)のデータ型を得ることができる。

ライブラリ関数の呼び出しを考えるときは、fundecl にはそのライブラリ関数の識別子ノードが入る。つまり、色々なライブラリ関数を区別する必要があるときは、名前で区別することができるのである。ここで「ライブラリ関数」というのは、算術演算を行なうのに使われる関数で、コンパイラが特別にその名前を知っているものであり、コンパイルされるC のコードには現れないものである。

stack-size は、スタックで渡される引数のバイト数である。可変のバイト数が渡される場合は、stack-size はゼロになり、引数のポップは常に呼び出し側関数の責任になる。

VAX の場合は、全ての関数が引数をポップするので、このマクロの定義はstack-size になる。68000 では、標準の呼び出し規約を使うと、引数をポップする関数はないので、このマクロの値は常にゼロになる。ただし、別の呼び出し規約も利用可能で、その場合固定数の引数を取る関数はその引数をポップするが、それ以外の関数(例えば printf) は何もポップしない(呼び出し側が全部ポップする)。後者の規約が使われるときは、funtype を調べて、関数が固定数の引数を取るかどうかが決定される。

##引数のレジスタ渡し

この節では、色々な型の引数をレジスタで渡す方法、あるいはスタックで渡す方法を制御するマクロについて説明する。

FUNCTION_ARG (cum, mode, type, named)
関数の引数がレジスタで渡されるかどうか、そしてどのレジスタで渡されるのかを制御する C の式を定義する。
引数の cum は、以前の引数を全て要約する。mode は、引数のマシンモードである。type は、ツリーノードとしての引数のデータ型か、未知であれば 0 である(C サポートライブラリ関数の場合)。named は、通常の引数では 1 になり、呼び出される関数のプロトタイプの... に対応する引数では 0 になる。

この式の値は、引数を渡すハードレジスタについては reg RTX であり、引数をスタックで渡す場合は 0 である。

Vax や 68000 のような、通常全ての引数がプッシュされる機種では、ゼロという定義で充分である。

この式の値は parallel RTX とすることもできる。これは、一個の引数が複数の位置に置かれて渡される場合に使われる。この parallel のモードは引数全体のモードにすべきである。parallel は、任意の個数の expr_list 対を保持する。そのそれぞれが、引数の一部がどこに渡されるかを記述する。各 expr_list では、第一オペランドは、引数のこの部分を渡すハードレジスタを表す reg RTX でなければならない。そして レジスタ RTX のモードが引数のこの部分の大きさを表す。expr_list の第二オペランドは、const_int であり、引数全体のうち、この部分が始まる位置のオフセットを与える。特別な例外として、parallel RTX の先頭の expr_list の第一オペランドはゼロであっても良い。これは、expr_list の第二オペランドから始まるバイト列がスタックに格納され、レジスタには保持されないことを表す。

ANSI ライブラリ stdarg.h を、引数の幾つかが通常はレジスタで渡されるような機種で動作させるようにする普通の方法は、名前のない引数を代わりにスタックで渡すようにすることである。これは、named が 0 の場合には常に FUNCTION_ARG が 0 を返すようにすれば良い。

このマクロを定義するのに MUST_PASS_IN_STACK (mode, type) というマクロを使って、この引数がスタックで渡さなければならない型かどうかを決めることができる。REG_PARM_STACK_SPACE が定義されていない場合に、このような引数に対して FUNCTION_ARG がゼロでない値を返すと、コンパイラは異常終了する。REG_PARM_STACK_SPACE が定義されていると、この引数はスタックで計算された後、レジスタにロードされる。 

MUST_PASS_IN_STACK (mode, type)

C の式である。これを評価すると、type 単独でレジスタで渡す方法がわからないときは、ゼロでない値になる。ファイル expr.h で通常適切な定義を定義している。詳細については expr.h を参照のこと。 

FUNCTION_INCOMING_ARG (cum, mode, type, named)

ターゲットマシンに「レジスタウィンドウ」がある場合にはこのマクロを定義し、関数から見て引数が入っているレジスタと、呼び出し側が引数を渡したレジスタが必ずしも同じである必要はないということを指示する。

そういう機種では、FUNCTION_ARG が、呼び出し側が値を渡すレジスタを計算する。そして、FUNCTION_INCOMING_ARG を同様の形で定義して、呼び出される関数にどこに引数が到着するかを知らせるようにする。

FUNCTION_INCOMING_ARG が定義されていなければ、FUNCTION_ARG が両方の役割を果たす。 

FUNCTION_ARG_PARTIAL_NREGS (cum, mode, type, named)

一個の C の式。ある引数の先頭で、レジスタに置かなければならないワード数を表す。この値は、全体がレジスタで渡されるか、全体がスタックにプッシュされる引数についてはゼロにならなければならない。

機種によっては、ある種の引数は部分的にレジスタとメモリに分かれて渡さなければならないことがある。そういう機種では、典型的には、先頭の n ワードの引数がレジスタで渡され、残りはスタックで渡される。ある一個の複数語の引数(double や構造体)がその境界をまたがるなら、その先頭の数ワードをレジスタで渡し、残りはスタックにプッシュしなければならない。このマクロはコンパイラに、これが何時発生するかとレジスタに行くべき語数を知らせる。

これらの引数に対して FUNCTION_ARG は、この引数に対して呼び出し側により使われる先頭のレジスタを返すべきである。同様に、FUNCTION_INCOMING_ARG は、呼び出された側により使われる先頭のレジスタを返すべきである。 

FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named)

引数が参照で渡されなければならない事を示す C の式。引数一個につき、その引数のコピーがメモリに作られ、そこへのポインタが、引数自体の代わりに渡される場合は、ゼロでない値となる。ポインタは、その型へのポインタを渡すのに適切な方法で渡される。

REG_PARM_STACK_SPACE が定義されない機種では、適切な定義は以下のようになる。

```
#define FUNCTION_ARG_PASS_BY_REFERENCE\
(CUM, MODE, TYPE, NAMED)  \
  MUST_PASS_IN_STACK (MODE, TYPE)
```

FUNCTION_ARG_CALLEE_COPIES (cum, mode, type, named)

一個の C の式。定義されていると、不可視の参照で渡された引数のコピーを作るのが呼び出された関数の責任であるのはいつかを示す。普通、呼び出し側がコピーを作り、そのコピーのアドレスを呼び出されるルーチンに渡す。FUNCTION_ARG_CALLEE_COPIES が定義されていて、それがゼロでなければ、呼び出し側はコピーを作らない。代わりに、「生の」値へのポインタを渡す。呼び出された関数はこの値を変更してはならない。この値が変更されないことに決められるなら、コピーを作る必要はない。それ以外の場合はコピーを作らなければならない。 

CUMULATIVE_ARGS

ある C の型。この型は、FUNCTION_ARG の先頭の引数とその他の関連する値として使われる変数を宣言する。幾つかのターゲット機種用には、int 型で充分であり、これまでのところ、その引数のバイト数を保持可能である。

スタックで渡された引数については、CUMULATIVE_ARGS には一切記録する必要がない。コンパイラは、他の変数群でそれらを記録する。全ての引数がスタックで渡されるターゲット機種では、CUMULATIVE_ARGS には何も格納する必要がない。だが、このデータ構造は存在しなくてはならず、空であってはいけないので、その場合は int を使うこと。 

INIT_CUMULATIVE_ARGS (cum, fntype, libname, indirect)

一個の C の文(セミコロンなし)。この文は、引数リストの先頭の状態を表す変数 cum を初期化する。変数の型は CUMULATIVE_ARGS である。fntype の値は、引数を受け取る関数のデータ型を表すツリーノードか、その引数がコンパイラがサポートしているライブラリ関数に対するものなら 0 である。indirect の値は、間接呼びだし、例えば、関数ポインタを通しての呼び出しの場合はゼロでない値である。indirect の値は明示的に指定された関数の呼び出しか、ライブラリ関数への呼びだし、あるいはコンパイル中の関数の引数を見つけるのに INIT_CUMULATIVE_ARGSが使われるときは、ゼロである。

コンパイラサポートライブラリ関数への呼び出しを処理する際には、libname がどれであるかを特定する。libname は、関数名を文字列として含む symbol_ref RTX である。libname は、普通の C の関数呼び出しが処理される場合は 0 である。つまり、このマクロが呼び出されると必ず、libname か fntype のどちらかはゼロでない。だが、両方同時にゼロでない値になることはない。 

INIT_CUMULATIVE_INCOMING_ARGS (cum, fntype, libname)

INIT_CUMULATIVE_ARGS とほぼ同じだが、コンパイル中の関数の引数を見つける目的のために、それを上書きする。このマクロが定義されていないと、INIT_CUMULATIVE_ARGS が代わりに使われる。

libname に渡される値は常に 0 である。なぜなら、特別な呼びだし規約を使うライブラリルーチンは GNU CC でコンパイルされることは決してないからである。引数 libname は INIT_CUMULATIVE_ARGS との対称性のために存在する。 

FUNCTION_ARG_ADVANCE (cum, mode, type, named)

一個の C の文(セミコロンなし)。要約変数 cum を更新して、引数リストの中のある引数を越えたところまで進める。mode、type、named の値がその引数を記述する。一旦これが行なわれると、変数 cum は、FUNCTION_ARG 等を使って 後続の引数の解析を行なうに適したものになる。

このマクロは、問題の引数がスタックで渡されたものなら何もする必要がない。コンパイラは、引数に使われるスタック領域の量を特別な助けがなくとも追跡する方法を知っている。 

FUNCTION_ARG_PADDING (mode, type)

一個の C の式。定義されていれば、引数を余分なスペースで詰め込むかどうか、詰め込むならどちら向きにするかを決める。この式の値は、enum direction 型でなければならない。upward は引数の上側に詰め込み、downward は下側を詰め込む。none は詰め込みをしない。

詰め込みは、いつでも次の FUNCTION_ARG_BOUNDARY の倍数にちょうど達するだけの量である。このマクロはそれを制御しない。

このマクロには、ほとんどのシステムに対して正しくなる、デフォルトの定義がある。リトルエンディアンの機種では、デフォルトは上向きに詰め込みをする。ビッグエンディアンの機種では、int よりも小さい固定サイズの引数に対しては下向きに、その他の引数については上向きに詰め込みをする。 

FUNCTION_ARG_BOUNDARY (mode, type)

一個の C の式。定義されていれば、指定されたモードとタイプの引数のアラインメント境界をビット単位で与える。これが定義されていないと、全ての引数について PARM_BOUNDARY が使われる。 

FUNCTION_ARG_REGNO_P (regno)

regno が関数の引数が渡されることもあるハードレジスタ番号なら、ゼロでない値となる C の式である。この場合の引数には、静的チェーンと構造体値アドレスのような暗黙の引数は含まない。多くの機種では、この目的ではレジスタは使えない。関数の引数が全てスタックで渡されるからである。 

LOAD_ARGS_REVERSED

定義されていると、引数がそれぞれ対応する引数レジスタにロードされる順番が反転され、最後の引数が最初にロードされる。このマクロが影響するのは、レジスタで渡す引数だけである。

##スカラ関数値の返し方

この節では、スカラを値として返す方法を制御するマクロについて議論する。スカラ値とは、レジスタに収まる値である。

TRADITIONAL_RETURN_FLOAT

-traditional オプションを指定した場合、float を返すように宣言された関数がその値を double 型に変換させるようにすべきでなければ、このマクロを定義する。 

FUNCTION_VALUE (valtype, func)

ある関数がデータ型 valtype の値を返す場所を表すRTL を作る C の式である。valtype は、あるデータ型を表す木ノードである。その型を表すのに使われるマシンモードを得るにはTYPE_MODE (valtype) を使う。多くの機種では、そのモードだけが適切である。(実際に、ほとんどの機種では、スカラ値は、モードに関わらず同じ場所に返される。)

この式の値は、通常、戻り値が格納されるハードレジスタについてはreg RTX となる。この値は、戻り値が複数の場所に置かれるなら、parallel RTX でも良い。parallel 形式の説明については、FUNCTION_ARG を参照のこと。

PROMOTE_FUNCTION_RETURN が定義されている場合は、valtype がスカラ型なら、PROMOTE_MODE で指定されているのと同じ規則を適用しなければならない。

呼び出される具体的な関数が分かっているのなら、func はその関数を表す木ノード(FUNCTION_DECL)である。分かっていない場合は、func はヌルポインタである。このため、特定の関数について、その呼び出し側が全部わかっている場合は、戻り値を返すのに異なる規約を使うことが可能になる。

FUNCTION_VALUE は集合型のデータ型の戻り値には使われない。これらはまた別の方法で返されるからである。以下の、STRUCT_VALUE_REGNUM と関連マクロを参照のこと。 

FUNCTION_OUTGOING_VALUE (valtype, func)

ターゲット機種に「レジスタ・ウィンドウ」があるため、ある関数がその値を返すのに入れるレジスタが、呼び出し側がその値を見つけるレジスタと同じでない場合は、このマクロを定義する。
そういう機種では、FUNCTION_VALUE が、呼び出し側がその値を見いだすレジスタを計算する。FUNCTION_OUTGOING_VALUE は、同様な形式で定義し、その関数に値をどこに置くかを知らせるようにすべきである。

FUNCTION_OUTGOING_VALUE が定義されていない場合は、FUNCTION_VALUE が両方の目的を果たす。

FUNCTION_OUTGOING_VALUE は集合型のデータ型の戻り値には使われない。これらはまた別の方法で返されるからである。以下の、STRUCT_VALUE_REGNUM と関連マクロを参照のこと。 

LIBCALL_VALUE (mode)

あるライブラリ関数がモードmode の値を返す場所を表すRTL を作り出す C の式である。呼び出される具体的な関数が分かっているのなら、func はその関数を表す木ノード(FUNCTION_DECL)である。分かっていない場合は、func はヌルポインタである。このため、特定の関数について、その呼び出し側が全部わかっている場合は、戻り値を返すのに異なる規約を使うことが可能になる。

ここで言う「ライブラリ関数」とは、コンパイラのサポートルーチンであり、算術演算を実行するのに使われることに注意すること。ライブラリ関数名は、コンパイラが特別に知っており、コンパイルされるC のコードには現れない。

LIBIRARY_VALUE の定義は、集合データ型については気にする必要はない。集合データを返すようなライブラリ関数は一つもないからである。 

FUNCTION_VALUE_REGNO_P (regno)

regno が、呼び出された関数の値が戻ってくるハードレジスタの番号なら、ゼロでない値となる C の式。
値を戻すのに使われる役割が、レジスタ対(例えば、double 型の値用)の二番目に限定されているならレジスタなら、このマクロで認識する必要はない。このため、ほとんどの機種では、以下の定義で充分である。

```
#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)
```

レジスタウィンドウを持つ機種で、呼び出し側と被呼び出し側関数が戻り値に異なるレジスタを使う場合は、このマクロは呼び出し側のレジスタ番号だけを認識すべきである。 

APPLY_RESULT_SIZE

untyped_call と untyped_return が、任意の戻り値のセーブとリストアについて FUNCTION_VALUE_REGNO_P で暗示されるよりも、多くのスペースを必要とするなら、このマクロを定義する。

##大きな値の返し方

関数値のモードが BLKmode の場合(そして他のいくつかの場合)、値は FUNCTION_VALUE にしたがっては返されない(see Scalar Return)。代わりに、呼びだし側が値を格納すべきメモリブロックのアドレスを渡す。このアドレスは、構造体値アドレス と呼ばれる。

この節では、構造体値をメモリに入れて返す方法を説明する。

RETURN_IN_MEMORY (type)

一個のCの式。この式により、戻り値の型によって、一定の関数の戻り値をレジスタで返すのを禁止することが可能である。この式の値がゼロでないと、大きな構造体を返す場合は常にそうであるように、関数の値をメモリに入れて返すことを表す。ここで type は、tree 型の C の式であり、戻り値のデータ型を表現する。

モード BLKmode の値は、このマクロで明示的に扱わなければならないことに注意。また、 -fpcc-struct-return は、このマクロに関係なく有効になる。ほとんどの機種では、このマクロを定義しなくても良い。定義しないとデフォルトの定義が使われ、その場合、このマクロの値はBLKmode の値の場合は 1 に、それ以外の場合は 0 になる。

構造体と共用体を常にメモリで返すように指示するのには、このマクロは使わないこと。そのためには、代わりに DEFAULT_PCC_STRUCT_RETURN を使うべきである。 

DEFAULT_PCC_STRUCT_RETURN

全ての構造体と共用体の戻り値をメモリに入れなくてはならない場合はこのマクロを 1 に定義する。これを定義すると生成されるコードが遅いものになるので、他のコンパイラや ABI との互換性のために必要な場合にだけ定義するようにする。このマクロを 0 に定義すると、構造体と共用体の戻り値に対する規約は、マクロ RETURN_IN_MEMORY により決定される。

このマクロが定義されない場合は、デフォルトで 1 となる。 

STRUCT_VALUE_REGNUM

構造体値のアドレスがレジスタで渡されるなら、STRUCT_VALUE_REGNUM はそのレジスタ番号とする必要がある。 

STRUCT_VALUE

構造体値のアドレスがレジスタでは渡されないなら、STRUCT_VALUE をアドレスが渡される場所を表す RTX を返す式として定義する。それが 0 を返すと、アドレスは「見えない」先頭の引数として渡される。 

STRUCT_VALUE_INCOMING_REGNUM

アーキテクチャによっては、被呼び出し関数が構造体値のアドレスを見つける場所が、呼び出し側が置いた場所と同じでないことがある。これは、レジスタ・ウィンドウのせいであったり、関数のプロローグが異なる場所へ移動するためであったりする。

入力引数の構造体値のアドレスが置かれる位置がレジスタの場合は、このマクロをレジスタ番号として定義する。 

STRUCT_VALUE_INCOMING

入力位置がレジスタでない場合は、呼び出された関数がその値を探すべき位置を表す RTX の式として STRUCT_VALUE_INCOMING を定義すべきである。その値をスタック上で探すべきなら、このマクロをフレームポインタを参照するmem を作り出すように定義する。0 と定義すると、アドレスは「不可視」の第一引数として渡されることを意味する。 

PCC_STATIC_STRUCT_RETURN

構造体や共用体を返すための、ターゲット機種でのシステムの通常の規約が呼び出された関数が構造体や共用体の値を含む静的変数のアドレスを返すというものであるなら、このマクロを定義する。

システムの通常の規約が呼び出し側がサブルーチンにアドレスを渡すものであるなら、このマクロは定義しないこと。

このマクロは -fpcc-struct-return を指定した場合に効果があるが、-freg-struct-return を指定した場合には何の効果もない。

##呼び出し側退避レジスタの割り当て

もし有効になっているなら、GNU CC は、関数呼び出しの前後でレジスタをセーブすることができる。これにより、呼び出し時破壊レジスタを関数呼び出しにまたがって生存しなければならない変数を保持するのに使えるようになる。

DEFAULT_CALLER_SAVES

ターゲット機種で関数呼び出しがどのレジスタも保存しないのであれば、このマクロを定義する。言い換えると、CALL_USED_REGISTERS が全てのレジスタで 1 の場合である。このマクロは、定義されていれば、デフォルトで全ての最適化レベルで -fcaller-saves を有効にする。最適化レベル 2 以上では、デフォルトで -fcaller-saves が有効になっているので、このオプションを指定しても効果がない。 

CALLER_SAVE_PROFITABLE (refs, calls)

C の式。この式は、疑似レジスタを呼び出し時破壊レジスタに置き、各関数呼び出しの前後でセーブ／リストアすることを考える価値があるかどうかを決定する。その価値がある場合は式の値は 1 とし、ない場合は 0 とすべきである。
このマクロを定義しない場合のデフォルトは 4 * calls < refs であり、ほとんどの機種で適切なものである。 

HARD_REGNO_CALLER_SAVE_MODE (regno, nregs)

一個の C の式。疑似レジスタ nregs を呼出し時破壊ハードレジスタregno にセーブするのに必要とされるモードを指定する。regno が呼出し側セーブに向いていなければ、VOIDmode を返さなければならない。ほとんどの機種ではこのマクロを定義する必要はない。GCC が最小の適切なモードを選ぶからである。

##関数の入口と出口

この節では、関数の入り口(プロローグ)と出口(エピローグ)コードを出力するマクロについて説明する。

FUNCTION_PROLOGUE (file, size)

関数の入り口点のアセンブラコードを出力する C の複文である。このプロローグコードは、スタックフレームの設定、フレームポインタレジスタの初期化、セーブしなければならないレジスタのセーブ、局所変数用のsize バイト分の記憶域の確保を行なう責任がある。size は整数である。file は、アセンブラコードの出力先を指定する標準入出力ストリームである。

関数の開始位置を表すラベルは、このマクロで出力する必要はない。このマクロが実行されるときに既に済んでいるはずである。

セーブすべきレジスタを決めるために、このマクロは配列 regs_ever_live を参照する。この配列の要素 r は、ハードレジスタ r がこの関数内のどこかで使われているならゼロ以外の値となる。つまり、call-used レジスタの一つでない限り、プロローグコードがレジスタ r をセーブすべきであるということになる。(FUNCTION_EPILOGUE も同様に regs_ever_live を使わなければならない。)

レジスタウィンドウを持つマシンでは、関数の入り口点コードは、レジスタウィンドウにあるレジスタのスタックへのセーブは行なわない。たとえ、そのレジスタが関数呼びだしの際に保存されるべきものであってもである。代わりに、その関数内で non-call-used なレジスタが使われている場合は、レジスタスタックに「プッシュ」するという独特の処理を行なう。

関数のフレームポインタがあってもなくても良いマシンでは、関数の入り口点コードもフレームポインタの有無に対応して変わらなければならない。要求されているのであればフレームポインタを設定しなければならず、要求されていなければ設定してはならない。フレームポインタが要求されているかどうか決めるために、このマクロから変数 frame_pointer_needed を参照することが可能である。実行時には、フレームポインタを必要とする関数の中ではこの変数の値は 1 になる。See Elimination。

関数の入り口コードには、その関数に必要とされるだけのスタックスペースを確保する責任がある。このスタックスペースは、以下に示す領域から成る。多くの場合は、これらの領域は以下の順番に確保され、最後に示した領域がスタックのトップに最も近くなる。スタックのトップは、STACK_GROWS_DOWNWARD が定義されていれば最下位アドレスになり、定義されていなければ最上位アドレスになる。より便利であったり、互換性に理由から必要とされるマシンに対しては、異なった順番を使っても良い。規格やデバッガから要求される場合を除き、あるマシンのスタック構成がGCC で使われるものと他のコンパイラで使われるものとが一致しなければならない理由はない。

* current_function_pretend_args_size バイトの非初期化スペースの領域。これは、スタック上に置かれる先頭の引数の直下にある。(これは、呼び出しシーケンスがスタックに引数をプッシュして以来、それ以外の何かをプッシュしていれば、割り当てられたスタック領域の開始点そのものではない可能性がある。) この領域は、一個の引数が一部がレジスタで一部がメモリで渡される可能性のある機種で使われたり、varargs.h と stdargs.h の機能をサポートするために使われる場合がある。
* 関数により使用される一定のレジスタをセーブするのに使われるメモリ領域。この領域の大きさは、戻りアドレスと直前のスタックフレームへのポインタ等向けのスペースも含んでおり、機種固有であり、普通は関数でどのレジスタが使われるかに依存する。レジスタウィンドウを持つ機種では、このセーブ領域を必要としないことが多い。
* 少なくとも size バイトの領域で、割当境界にまで切り上げられることもあり、関数の局所変数を含んでいる。いくつかの機種では、この領域とセーブ領域は逆の順番で発生し、セーブ領域はスタックの最上位に近くなる。
* オプションで、ACCUMULATE_OUTGOING_ARGS が定義されているとき、その関数の出力引数リストに使われるcurrent_function_outgoing_args_size バイトの領域。See Stack Arguments。

普通は、マクロ FUNCTION_PROLOGUE と FUNCTION_EPILOGUE は末端関数を特別に扱う必要がある。C の変数 current_function_is_leaf は、そういう関数についてはゼロでない値となる。 

EXIT_IGNORE_STACK

一個の C の式。リターン命令や関数のエピローグがスタックポインタの値を無視するならゼロでない値となる。言い換えると、関数から戻る前にスタックポインタの調整を行なう命令を削除しても安全な場合は、ゼロでない値となる。
このマクロの値が関係するのは、フレームポインタが維持されている関数に対してだけであることに注意。フレームポインタを持たない関数で、最後のスタック調整を削除するのは決して安全ではない。コンパイラは、EXIT_IGNORE_STACK に関わらず、このことを知っている。 

EPILOGUE_USES (regno)

C の式を定義するマクロ。この式の値は、エピローグか return パターンでレジスタが使われるなら 0 でない値とする。スタックポインタとフレームポインタレジスタは、既に必要に応じて使われていると仮定されている。 

FUNCTION_EPILOGUE (file, size)

関数の出口点のアセンブラコードを出力する C の複文である。このエピローグコードは、セーブされたレジスタとスタックポインタの値を関数が呼び出されたときの値に復帰させ、制御を呼び出し関数に戻す責任がある。引数は、マクロ FUNCTION_PROLOGUE と同じである。復帰すべきレジスタは、同様に、regs_ever_live と CALL_USED_REGISTERS から決定される。

機種によっては、一個の機械命令で関数からの復帰作業を全て行なうものがある。そういう機種では、その命令に return という名前を与え、マクロ FUNCTION_EPILOGUE は定義してはならない。

FUNCTION_EPILOGUE を使って欲しいのであれば、return という名前のパターンを定義してはならない。ターゲットスイッチで、return 命令を使うのか、あるいは、エピローグを使うのかを制御したい場合は、return パターンを、ターゲットスイッチを適切にテストする有効性を検査する条件を付けて定義すること。return パターンの有効性検査条件が偽であれば、エピローグが使われる。

関数がフレームポインタを持っても持たなくても良い機種では、関数の終了コードはそれに従って変わらなければならない。この二つの場合のコードが全く異なるということもある。フレームポインタを必要とするかどうかを決めるために、このマクロでは変数 frame_pointer_needed を参照することが出来る。この変数の値は、コンパイルしている関数がフレームポインタを必要とするなら1 となる。

通常、FUNCTION_PROLOGUE と FUNCTION_EPILOGUE は、末端関数を特別に取り扱わなくてはならない。そのような関数については、C の変数 current_function_is_leaf がゼロでない値となる。See Leaf Functions.

幾つかの機種では、関数によっては、終了時に引数をポップするものがあったり、呼び出し側にまかせたりするものがある。例えば、68020 では、-mrtd オプションを指定すると、固定数の引数を取る関数の引数はポップする。

マクロ RETURN_POPS_ARGS の定義により、どの関数がその関数自身の引数をポップするかが決まる。FUNCTION_EPILOGUE はどちらに決まったかを知る必要がある。current_function_pops_args という変数が、ある関数がポップすべき引数のバイト数を表す。See Scalar Return. 

DELAY_SLOTS_FOR_EPILOGUE

関数のエピローグに、その関数の他の部分から命令をそこに「移動」可能な遅延スロットがあるなら、このマクロを定義する。このマクロの定義は、C の式とし、その値は存在する遅延スロット数とすべきである。 

ELIGIBLE_FOR_EPILOGUE_DELAY (insn, n)

insn をエピローグコードの遅延スロット番号 n に置くことが出来る場合は 1 を返す C の式。
引数 n は、今考えている遅延スロットを特定する整数である(というのは、異なるスロットは異なる適性を持つからである。) この整数は、負になることはなく、常にエピローグにある遅延スロット数(DELAY_SLOTS_FOR_EPILOGUE が返す値である)より小さい。ある指定された遅延スロットにある特定の insn を入れることを拒否する場合は、原則的には、すぐ後ろの遅延スロットに入れられるかどうかが再考される。また、他の insn が(少なくとも)原則的には、その時点までに埋められていない遅延スロットに入るかどうかが考慮される。

エピローグコード中の遅延スロットを埋めるべく受け入れられた insn はinsn_list オブジェクトで作られた RTL リストに置かれ、変数 current_function_epilogue_delay_list に格納される。先頭の遅延スロットに入る insn は、このリストの先頭に来る。マクロ FUNCTION_EPILOGUE は、このリスト中の insn を出力することにより遅延スロットを埋めるように定義すべきである。これは、普通は final_scan_insn を呼び出すことにより行なわれる。

DELAY_SLOTS_FOR_EPILOGUE を定義しないのなら、このマクロを定義する必要はない。 

ASM_OUTPUT_MI_THUNK (file, thunk_fndecl, delta, function)

C の複文。この複文はサンク関数用のアセンブラコードを出力する。サンク関数は、C++の、多重継承を持つ仮想関数呼び出しを実装するのに使われる。サンクは、仮想関数のラッパーとして作用し、実際の関数へ制御を渡す前に暗黙のオブジェクトパラメータの調整を行なう。

まず、整数 delta を先頭の入力引数を含む位置に加算するコードを生成する。この引数はあるポインタを含んであり、C++ で this ポインタを渡すのに使われるものであると仮定する。これは、関数プロローグの前の入力引数、例えば SPARC では%o0 である。この加算は、他の全ての入力引数の値を保存しなければならない。

この加算の後、function にジャンプするコードを生成する。function は FUNCTION_DECL である。これは純粋な直接ジャンプであり、呼び出しではないので、戻りアドレスはいじらない。つまり、FUNCTION から戻ると、現在の thunk の呼び出し元に戻ることになる。

この効果は、あたかも functionが第一引数を調整したうえで直接呼び出されたかのようにならなければならない。このマクロは、サンク関数用のコードを全て生成する責任がある。FUNCTION_PROLOGUE と FUNCTION_EPILOGUE は呼び出されない。

thunk_fndecl は冗長である。(これから、delta と function が既に抽出済みである。) ターゲットによっては役に立つ可能性もあるが、多分そういうことはないだろう。

このマクロを定義しない場合は、C++ フロントエンドのターゲット非依存コードが、効率の落ちる、重量級のサンクを生成する。このサンクは、function にジャンプするのではなく、それを呼び出す。この汎用的な方法はvarargs はサポートしない。

##プロファイリング用コードの生成

以下のマクロは、プロファイル用コードの生成を助ける。

FUNCTION_PROFILER (file, labelno)

一個の C の文か複文で、file に、プロファイルサブルーチン mcount を呼び出すアセンブラコードを出力する。呼び出しの前に、このアセンブラコードはカウンタ変数のアドレスを、mcount がそのアドレスを見つけると想定しているレジスタにロードしなければならい。このカウンタ変数の名前は LP の後に、番号 labelno が付いたものなので、fprintf で LP%d とすることでこの名前を生成できる。

アドレスが mcount にどのように渡されるかの詳細は、GNU CC ではなく、ユーザのオペレーティングシステム環境により決まる。それがどういうものであるか調べるには、小さいプログラムをシステムにインストール済みの C コンパイラを使ってプロファイリング用にコンパイルし、その結果生成されるアセンブラコードを見れば良い。 

PROFILE_BEFORE_PROLOGUE

関数のプロファイリング用コードを関数のプロローグコードの前に置くべきならこのマクロを定義する。普通は、プロファイリング用コードはプロローグコードの後に来る。 

FUNCTION_BLOCK_PROFILER (file, labelno)

一個の C の文か複文で、file に、現在のオブジェクトモジュールの基本ブロックのプロファイリングを初期化するアセンブラコードを出力する。グローバルなコンパイルフラグ profile_block_flag で二つのプロファイリングのモードを区別する。

profile_block_flag != 2

オブジェクトモジュール毎にサブルーチン __bb_init_func を一度だけ呼び出すコードを出力する。このサブルーチンにはただ一つの引数として、そのオブジェクトモジュール内に割り当てられたあるブロックのアドレスを渡す。
ブロック名はローカルシンボルであり、次の文で作られる。

ASM_GENERATE_INTERNAL_LABEL (buffer, "LPBX", 0);

もちろん、このマクロの定義だけではなくて、ASM_GENERATE_INTERNAL_LABEL の定義も書くわけだから、このマクロの定義をショートカットして、生成されるとわかっている名前を使っても良い。

このブロックの先頭のワードは、そのオブジェクトモジュールが既に初期化済みであればゼロでない値となるフラグである。そのため、まずこのワードを調べ、フラグがゼロでなければ __bb_init_func を呼ばないようにする。labelno には、__bb_init_func が呼ばれないときの分岐先ラベルを生成するのに使われる一意的な番号が入る。

アセンブラ言語で書くと、出力すべきコードは以下のようになる。

```
  cmp (LPBX0),0
  bne local_label
  parameter1 <- LPBX0
  call __bb_init_func
local_label:
```

profile_block_flag == 2

サブルーチン __bb_init_trace_func を呼び出し、二つのパラメータを渡すコードを出力する。第一のパラメータは __bb_init_func と同じである。二番目のパラメータは、labelno により与えられる関数の先頭の基本ブロックの番号である。__bb_init_trace_func は、オブジェクトモジュールが既に初期化済みの場合でも、必ず呼び出されなければならないことに注意して欲しい。

アセンブラ言語で書くと、出力すべきコードは以下のようになる。

```
parameter1 <- LPBX0
parameter2 <- BLOCK_OR_LABEL
call __bb_init_trace_func
```

BLOCK_PROFILER (file, blockno)

一個の C の文か、複文。この文は file に、基本ブロック番号 blockno に付随するカウンタをインクリメントするアセンブラコードを出力する。グローバルなコンパイルフラグ profile_block_flag で、以下の二つのプロファイルモードを区別する。

profile_block_flag != 2

カウンタを直接インクリメントするコードを出力する。基本ブロックは各コンパイル毎に別々にゼロから始まる番号が付けられる。基本ブロック番号 blockno に付随するカウンタは、ワードのベクトルの添え字 blockno の要素にある。この配列の名前は、以下の文で作られるローカルシンボルである。

ASM_GENERATE_INTERNAL_LABEL (buffer, "LPBX", 2);

もちろん、このマクロの定義だけではなくて、ASM_GENERATE_INTERNAL_LABEL の定義も書くわけだから、このマクロの定義をショートカットして、生成されるとわかっている名前を使っても良い。

アセンブラ言語で書くと、出力すべきコードは以下のようになる。

inc (LPBX2+4*BLOCKNO)

profile_block_flag == 2

グローバルな構造体 __bb を初期化し、関数 __bb_trace_func を呼び出すコードを出力する。__bb_trace_func は、カウンタをインクリメントする。
__bb は二つのワードからなる。最初のワードには、blockno で与えられる、現在の基本ブロックの番号が格納されなければならない。二番目のワードには、オブジェクトモジュール中に割り当てられたブロックのアドレスが格納されなければならない。このアドレスは、以下の文で作られるラベルで与えられる。

ASM_GENERATE_INTERNAL_LABEL (buffer, "LPBX", 0);

アセンブラ言語で書くと、出力すべきコードは以下のようになる。

```
move BLOCKNO -> (__bb)
move LPBX0 -> (__bb+4)
call __bb_trace_func
```

FUNCTION_BLOCK_PROFILER_EXIT (file)

一個の C の文か、複文。この文は、file に関数 __bb_trace_ret を呼び出すアセンブラコードを出力する。このアセンブラコードは、グローバルなコンパイルフラグ profile_block_flag == 2 の場合だけ出力すべきである。このマクロは、関数から戻るためのコードが生成される全ての場所で(例えば、FUNCTION_EPILOGUE)使う必要がある。FUNCTION_EPILOGUE の定義も同様に書かなければならないが、このマクロを定義することでコンパイラに対し、__bb_trace_ret の正しい呼び出しが生成されるよう指示しなければならない。 

MACHINE_STATE_SAVE (id)

一個の C の文か、一個の複文。この文は、全レジスタをセーブする。レジスタは関数呼び出しにより破壊されるものであっても良く、条件コードを含む。この作業を扱うのに一番必要そうなのは、asm 文だろう。アセンブラコード中の局所ラベルを文字列 id と連結して、一意的なラベル名を得ることもできる。

FUNCTION_PROLOGUE か FUNCTION_EPILOGUE により破壊されるレジスタや条件コードは、マクロ FUNCTION_BLOCK_PROFILER、FUNCTION_BLOCK_PROFILER_EXIT、BLOCK_PROFILER により、それぞれ __bb_init_trace_func、__bb_trace_ret、__bb_trace_func の呼び出しに先だって、セーブしなければならない。 

MACHINE_STATE_RESTORE (id)

MACHINE_STATE_SAVE によりセーブされた、条件コードを含む、全レジスタをリストアする C の文か複文。

FUNCTION_PROLOGUE か FUNCTION_EPILOGUE により破壊されるレジスタや条件コードは、マクロ FUNCTION_BLOCK_PROFILER、FUNCTION_BLOCK_PROFILER_EXIT、BLOCK_PROFILER により、それぞれ __bb_init_trace_func、__bb_trace_ret、__bb_trace_func の呼び出しの後で、リストアしなければならない。 

BLOCK_PROFILER_CODE

ブロックプロファイリングをサポートするライブラリで必要な一つの、あるいは複数の関数。


##varargs マクロの実装

GNU CC には、varargs.h と stdarg.h のある実装が付属しており、引数をスタック上で渡す機種では変更なしで動作する。そうでない機種ではそれ自身の varargs の実装が必要になり、その場合、機種独立の二つのヘッダファイルから条件付きで実装ファイルをインクルードしなければならない。

ANSI の stdarg.h は、旧来の varargs.h とは、va_start の呼び出し規約の点で主に異なっている。旧来の実装では、va_start は引数をただ一つだけ取り、それが引数ポインタを格納する変数になっている。ANSI の va_start の実装では、引数が一つ追加されている。プログラマは、関数の引数で名前が付いている最後のものを va_start の二番目の引数に書くことを要求される。

しかし、va_start はこの二番目の引数を使うべきではない。名前付き引数の最後を見つける方法は、以下に記述する組み込み関数で行なう。

__builtin_saveregs ()

この組み込み関数を使って、引数レジスタをメモリにセーブすることで、varargs の機構がそれらをアクセス可能になる。va_start の ANSI 版も旧来版もどちらも、代わりに SETUP_INCOMING_VARARGS(以下を参照)を使うのでない限り、__builtin_saveregs を使わなければならない。

機種によっては、__builtin_saveregs はマクロEXPAND_BUILTIN_SAVEREGS の制御の元で C 言語で書かれている。その他の機種では、アセンブラ言語で書かれたルーチンを呼び出す。これは、libgcc2.c にある。

__builtin_saveregs 呼び出し用に生成されたコードは、__builtin_saveregs の呼び出しが書かれている場所とは対照的に、そのコードが何をするかには関係なく、関数の先頭に現れる。これは、レジスタは、関数がそれ自身の目的でそのレジスタを使い始める前にセーブされなければならないものだからである。 

__builtin_args_info (category)

この組み込み関数を使って、レジスタにある最初の無名引数を見つける。

一般に、一つの機種には、引数として使われるレジスタには色々なカテゴリがあり、それぞれ特定のデータ型のカテゴリに対して使われる。(例えば、ある機種では、浮動小数点レジスタは浮動小数点引数に使われる一方で、それ以外の引数は汎用レジスタで渡される。) 非 varargs 関数が正しい呼び出し規約を使用するようにするには、データ型 CUMULATIVE_ARGS を定義して、各カテゴリで何個のレジスタがこれまで使われたかを記録する必要がある。

__builtin_args_info は CUMULATIVE_ARGS 型と同
じデータ構造を、それを使った通常の引数のレイアウトが終わった後で参照する。このとき、category がどのワードを参照すべきかを指定する。つまり、この値は与えられたカテゴリのレジスタで未使用のものの先頭を指す。

普通は、va_start の実装で __builtin_args_info を使い、各カテゴリを一度だけアクセスし、値を va_list オブジェクトに格納する。これは va_list がその値を更新しなければならないためであり、__builtin_args_info によりアクセスされる値を変える方法がないためである。 

__builtin_next_arg (lastarg)

これは、スタック上の引数については、__builtin_args_info に等価である。先頭の無名スタック引数のアドレスを、void * 型で返す。

ARGS_GROW_DOWNWARD が定義されていれば、先頭の無名スタック引数の上の位置のアドレスを返す。それを va_start で使って、スタックから引数を取り出すためのポインタを初期化する。また、va_start で、第二引数 lastarg が現在の関数の名前のある引数の最後であることを検証するのにも使われる。 

__builtin_classify_type (object)

それぞれの機種には固有の規約があって、どの型のデータをどの種類のレジスタで渡すかを決めている。読者はその規約を具体化するようにva_arg を実装しなければならない。指定されたデータ型を分類する一番手っ取り早い方法は、__builtin_classify_type をsizeof や __alignof__ を組み合わせて使うことである。

__builtin_classify_type は object の値は無視し、そのデータ型だけを見る。どんな型であるか--整数、浮動小数点、ポインタ、構造体などを記述する整数を返す。

ファイル typeclass.h である列挙型を定義していて、__builtin_classify_type の値を解釈するのに使うことができる。

以下のマシン記述マクロは varargs の実装を助ける。

EXPAND_BUILTIN_SAVEREGS (args)

定義されているなら、一個の C の式であり、__builtin_saveregs を呼び出すための機種固有のコードを生成する。このコードは関数の一番先頭の、仮引数のアクセスが行なわれる前に移動される。この関数の戻り値は、__builtin_saveregs の戻り値として使う値を含む RTX とすべきである。

引数 args は、__builtin_saveregs に渡された引数を含む、ある tree_list である。

このマクロが定義されていない場合は、コンパイラは通常の、ライブラリ関数 __builtin_saveregs の呼び出しを出力する。 

SETUP_INCOMING_VARARGS (args_so_far, mode, type, pretend_args_size, second_time)

このマクロは、__builtin_saveregs の使い方とマクロEXPAND_BUILTIN_SAVEREGS の定義の仕方に別の選択肢を提供する。このマクロを使って、無名のレジスタ引数をスタックに格納し、全ての引数がスタック上に連続して渡されたように見せることができる。一旦これをやっておくと、varargs の標準の実装を使うことができる。varargs の標準の実装は、全ての引数をスタックで渡す機種に対して使うことができる。

引数 args_so_far はデータ構造 CUMULATIVE_ARGS である。このデータ構造は、名前つき引数を処理した後の値を含む。引数 mode と type は最後の名前つき引数を、そのマシンモードとデータ型をツリーノードとして記述する。

このマクロの実装では次の二つを行なう必要がある。まず第一に、名前つき引数用に使われていない全ての引数レジスタをスタックにプッシュする。次に、このようにしてプッシュされたデータの大きさを int 型の値の変数に格納する。この変数の名前は、引数 pretend_args_size で提供される。ここで格納した値は、スタックフレームの設定で使われる追加のオフセットとして機能する。

無名引数をプッシュするコードを、コンパイル時にそのデータ型を知ることなしに生成しなければならないので、SETUP_INCOMING_VARARGS は、引数レジスタのカテゴリが一個しかなく、全データ型にたいして等しくそれを使う機種でのみ、意味がある。

引数 second_time がゼロでないと、この関数の引数が二回目に解析されることを意味する。これはインライン展開関数の場合に起こり、ソースファイルの終りに達するまで実際にコンパイルされない。マクロ SETUP_INCOMING_VARARGS は、この場合何も命令を生成すべきでない。 

STRICT_ARGUMENT_NAMING

関数の引数が渡される位置が、その引数が名前付きの引数かどうかに依存するなら、このマクロをゼロでない値に定義する。

このマクロは、FUNCTION_ARG への引数 named がvarargs と stdarg 関数に対してどのようにして設定されるかを制御する。このマクロがゼロでない値を返すなら、引数 named は名前つき引数に対しては常に真になり、名無し引数では偽になる。このマクロが値ゼロを返すが、SETUP_INCOMING_VARARGS が定義されている場合は、全ての引数が名前つきとして扱われる。それ以外の場合は、全ての名前つき引数は、最後の引数を除いて、名前付きとして扱われる。

常にゼロを返すなら、このマクロを定義する必要はない。 

PRETEND_OUTGOING_VARARGS_NAMED

ABI を条件により変更して、一方は SETUP_INCOMING_VARARGS が定義されている場合に動作するようにし、もう一方は、SETUP_INCOMING_VARARGS も STRICT_ARGUMENT_NAMING も定義されていないかのように動作させる必要がある場合には、このマクロを、SETUP_INCOMING_VARARGS が使われている場合にはゼロでない値を返すように定義し、使われていない場合にはゼロを返すようにする。該当しな場合は、このマクロを定義すべきではない。

##入れ子関数のトランポリン

トランポリン(trampoline)は、小さなコード断片であり、入れ子関数のアドレスを取るコードがあると、実行時に作成される。普通はにスタックに置かれる。これは、入れ子関数を含んでいる関数のスタックフレームの中になる。以下に説明するマクロは、トランポリンを確保したり、初期化するコードを生成する方法を GNU CC に知らせる。

トランポリン中の命令群は次の二つの作業を行なう必要がある。ある定数アドレスを静的チェーンレジスタにロードすること、およびネストした関数の実際のアドレスにジャンプすることである。m68k のような CISC マシンでは、このような場合二つの命令、つまり、一個の即値の移動命令と一個のジャンプ命令が必要である。そうすると、この二つのアドレスはトランポリン中ではワード長の即値オペランドとして存在する。RISC マシンでは、各アドレスを一個のレジスタにロードするのに二つの部分に分けて行なう必要があるものが多い。各アドレスの断片は、別々の即値オペランドを形成する。

トランポリンを初期化するために生成されたコードは、可変部分を命令の即値オペランドに格納しなければならない。可変部分とは、静的チェーンと関数のアドレスである。CISC の機種では、これは単に、各アドレスをトランポリンの先頭から適切なオフセットの地点のメモリ参照へコピーするという問題になる。RISC の機種では、アドレスの各断片を取りだして、別々にストアする必要がでてくる可能性がある。

TRAMPOLINE_TEMPLATE (file)

一個の C の文。この文は、ストリーム file に、あるトランポリンの固定部分を含むデータブロック用のアセンブラコードを出力する。このコードにはラベルを含めてはならない。ラベルの面倒は自動的にみてくれる。

このマクロを定義しないということは、ターゲットがテンプレートを必要としないということを意味する。トランポリンを決められた場所にコピーするブロック移動コードの大きさが、その場でトランポリンを生成するコードの大きさよりも大きいシステムではこのマクロを定義しないこと。 

TRAMPOLINE_SECTION

サブルーチン名。このサブルーチンは、トランポリンのテンプレートを置くべきセクションへの切替えを行なう(see Sections)。デフォルトは readonly_data_section の値であり、その場合、読み出し専用データを入れるセクションにトランポリンが置かれる。 

TRAMPOLINE_SIZE

整数値を取るC の式であり、トランポリンのバイト単位での大きさを表す。 

TRAMPOLINE_ALIGNMENT

トランポリンに必要なアラインメントをビット数で表す。
このマクロが定義されていないと、BIGGEST_ALIGNMENT の値がトランポリンのアラインメントとして使われる。 

INITIALIZE_TRAMPOLINE (addr, fnaddr, static_chain)

トランポリンの可変部分を初期化する C の文。addr は、トランポリンのアドレスの RTX である。fnaddr は、ネスト関数のアドレスの RTX である。static_chain は、関数が呼ばれたときにその関数に渡すべき静的チェーン値を表す RTX である。 

ALLOCATE_TRAMPOLINE (fp)

トランポリン用の実行時スペースを確保する C の式。この式の値は、トランポリンのスペースへのメモリ参照を表す RTX とすべきである。

このマクロが定義されていない場合は、デフォルトでトランポリンはスタックスロットとして確保される。ほとんどの機種ではこのデフォルトが正しい。例外となる機種は、スタック領域にある命令を実行することが不可能な機種である。そのような機種では、別のスタックを独立に実装しなければならない可能性がある。その場合は、このマクロを FUNCTION_PROLOGUE と FUNCTION_EPILOGUE を一緒に使って行なう。

fp は、あるデータ構造、struct function を指す。この構造体は、トランポリンが必要になる関数を含む関数(包含関数)のコンパイル状況を記述する。普通(ALLOCATE_TRAMPOLINE が定義されてないとき)、トランポリン用のスタックスロットはこの包含関数のスタックフレーム内にある。その他の割当戦略を取った場合も、この情報に類似したものを行なわなければならない。

多くの機種ではトランポリンを実装するのは困難である。命令とデータで別々のキャッシュを持っているからである。スタック位置へ書き込んでも命令キャッシュにあるメモリ内容をクリアしないので、プログラムがその位置にジャンプしたとき、古い内容を実行してしまう。

二つの解決方法がある。一つは、トランポリンが設定されたら常に命令キャッシュの関係する部分をクリアすることである。もう一つは、全てのトランポリンを、ある標準のサブルーチンにジャンプさせることにより、同じものにしてしまうことである。前者の方法はトランポリンの実行が速くなり、後者は初期化が速くなる。

トランポリンが初期化されるとき命令キャッシュをクリアするには、キャッシュの形状を記述する以下のマクロを定義する。

INSN_CACHE_SIZE

キャッシュの合計サイズをバイト単位で表す。 

INSN_CACHE_LINE_WIDTH

キャッシュの各ラインの長さをバイト数で表す。キャッシュは分離したスロットである複数のキャッシュ・ラインからなる。各キャッシュ・ラインは、メモリから取り出した、ある連続なデータの塊を保持する。データがキャッシュに持ち込まれる度に、一本のライン全体が一度に読み込まれる。あるキャッシュ・ラインにロードされたデータは、常に、ラインの大きさに等しい境界に整列する。 

INSN_CACHE_DEPTH

任意の特定のメモリ位置を保持できる別のキャッシュラインの数。
あるいは、命令キャッシュを直接クリアするシステムコールまたは命令がある機種では、以下のマクロを定義することができる。

CLEAR_INSN_CACHE (BEG, END)

一個の C の式。定義されていれば、この式は、指定された間隔で命令キャッシュをクリアする。このマクロが定義されておらず、マクロ INSN_CACHE_SIZE が定義されていると、ある汎用のコードが生成され、キャッシュをクリアする。このマクロの定義は普通、一連の asm 文となるだろう。BEG と END はどちらもポインタ式である。
標準のサブルーチンを使うには、以下のマクロを定義する。さらに、トランポリンの中の命令が、あるキャッシュライン全体を全く同一の命令で埋め尽くすこと、あるいはトランポリンコードの先頭が常にそのキャッシュラインの同じ場所に整列することを保証しなければならない。m68k.h を指針として読んで欲しい。

TRANSFER_FROM_TRAMPOLINE

トランポリンがその仕事を行なうために特別なサブルーチンを必要とする時はこのマクロを定義する。このマクロは、GNU CC によりコンパイルされるasm 文の連なりに展開される必要がある。展開されると、ライブラリ関数 __transfer_from_trampoline に入る。

あるコンパイル済みの C の関数の通常のプロローグコードを、そのサブルーチンにジャンプするときには、実行するのを避ける必要がある場合は、アセンブラコードの中に特別なラベルを置くことで行なうことができる。asm 文を一個使ってアセンブララベルを生成し、もう一個の asm 文でそのラベルをグローバルにする。そうしておくと、トランポリンがそのラベルを使って、その特別なアセンブラコードに直接ジャンプすることができる。

##暗黙のライブラリルーチン呼び出し

この節では、ライブラリルーチンの暗黙的な呼び出しについて説明する。

MULSI3_LIBCALL

符号付きのワード同士の乗算の際に呼び出すべき関数名を与える C の文字列定数。このマクロを定義しない場合は、デフォルトの名前、__mulsi3 が使われる。__mulsi3 は libgcc.a で定義される。 

DIVSI3_LIBCALL

符号付きのワード同士の除算の際に呼び出すべき関数名を与える C の文字列定数。このマクロを定義しない場合は、デフォルトの名前、__divsi3 が使われる。__divsi3 は libgcc.a で定義される。 

UDIVSI3_LIBCALL

符号なしのワード同士の除算の際に呼び出すべき関数名を与える C の文字列定数。このマクロを定義しない場合は、デフォルトの名前、__udivsi3 が使われる。__udivsi3 は libgcc.a で定義される。 

MODSI3_LIBCALL

C の文字列定数。これは、符号付きの全ワードをもう一つの符号付き全ワードで割った余りを求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__modsi3 であり、libgcc.a で定義されている関数である。 

UMODSI3_LIBCALL

C の文字列定数。これは、符号なしの全ワードをもう一つの符号なし全ワードで割った余りを求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__umodsi3 であり、libgcc.a で定義されている関数である。 

MULDI3_LIBCALL

C の文字列定数。これは、符号付きの2ワードともう一つの符号付き2ワードの積を求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__muldi3 であり、libgcc.a で定義されている関数である。 

DIVDI3_LIBCALL

C の文字列定数。これは、符号付きのダブルワード同士の商を求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__divdi3 であり、libgcc.a で定義されている関数である。 

UDIVDI3_LIBCALL

C の文字列定数。これは、符号なしのダブルワード同士の商を求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__udivdi3 であり、libgcc.a で定義されている関数である。 

MODDI3_LIBCALL

C の文字列定数。これは、符号付きのダブルワード同士の剰余を求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__moddi3 であり、libgcc.a で定義されている関数である。 

UMODDI3_LIBCALL

C の文字列定数。これは、符号なしの(ダブル?)ワード同士の剰余を求めるために呼び出す関数名を与える。このマクロを定義しないと、デフォルトの名前が使われる。これは、__umoddi3 であり、libgcc.a で定義されている関数である。 

INIT_TARGET_OPTABS

一個の C の文。この文は、ライブラリルーチンの宣言を追加して、既存のものの名前を付け替える。init_optabs は、全ての通常ライブラリルーチンを初期化した後、このマクロを呼び出す。 

TARGET_EDOM

ターゲット機種の EDOM の値を、C の整数定数式として表したもの。このマクロを定義しない場合は、GNU CC は EDOM の値を errno に直接置こうとはしない。/usr/include/errno.h を見て、読者のシステムでの EDOM の値を探すこと。

TARGET_EDOM を定義しないと、コンパイルされたコードが、そのライブラリ関数を呼び出し、エラーを報告させることで、ドメインエラーを報告する。読者のシステムの数学関数がエラーがあるときに matherr を使うなら、TARGET_EDOMO を未定義とし、通常通り matherr が使われるようにすべきである。 

GEN_ERRNO_RTX

グローバル「変数」 errno を参照する RTL 式を作る C の式としてこのマクロを定義する。(システムによっては、errno は実際には変数ではない可能性がある。) このマクロを定義しない場合は、適切なデフォルトが使われる。 

TARGET_MEM_FUNCTIONS

GNU CC が、BSD の関数 bcopy と bzero ではなく、System V(と ANSI C) の関数 memcpy と memset の呼び出しを生成すべきなら、このマクロを定義する。 

LIBGCC_NEEDS_DOUBLE

float 型の引数だけがライブラリ関数に渡せない(そのためdouble に変換しなければならない)場合は、このマクロを定義する。このマクロは、ライブラリ呼び出しがどのように生成されるのかとlibgcc1.c の中のライブラリルーチンがどのように引数を受け取るのかの両方に影響する。i860 のように、浮動小数点引数と固定小数点引数では渡し方が異なる場合には役に立つマクロである。 

FLOAT_ARG_TYPE

ライブラリルーチンが float 型の引数を取り出す時に使われる型を変えたい場合はこのマクロで定義する。(デフォルトでは、float と int の共用体型を使う。)
float にすれば良いように思うだろうが、旧来の C コンパイラではうまく行かない。float として宣言されている全ての引数がdouble として渡されることを想定しているからである。この float から double の変換を避けるために、ライブラリルーチンは、その値を何か他の型として要求し、その後でfloat として扱う。

システムによっては、このために使える他の型がない場合もある。そういうシステムでは、LIBGCC_NEEDS_DOUBLE を代わりに使って、その値を渡される前に double に強制的に変換するようにしなければならない。 

FLOATIFY (passed-value)

ライブラリルーチンが float 型の引数を渡された型の代わりに float として再度指示する方法を変えたい場合はこのマクロを定義する。型を変えたい場合はこのマクロで定義する。デフォルトでは、前出の共用体の float フィールドを取る式である。 

FLOAT_VALUE_TYPE

ライブラリルーチンが、float 型を持つべき値を返すのに使われる型を変えるには、このマクロを定義する。(デフォルトでは int になる。)
float にすれば良いように思うだろうが、旧来の C コンパイラではうまく行かない。float として宣言された値を不必要に double に変換するからである。 

INTIFY (float-value)

float 型を返すライブラリルーチンの値を、それを返すためにはどのようにパッケージするべきか、その方法を変更したいときはこのマクロを定義する。これらの関数は実際に FLOAT_VALUE_TYPE(普通int になる)型を返すように宣言される。

これらの値は float 型として返すことはできない。なぜなら、旧来の C コンパイラは常にの値を double に変換してしまうからである。

intify という名前の局所変数が、マクロ INTIFY を使うときはいつでも利用可能である。これは、float 型のフィールド f とFLOAT_VALUE_TTYPE 型か int 型のフィールド i とからなる共用体である。

このマクロを定義しない場合の、デフォルトの定義の動作は、この値をその共用体を通してコピーする。 

nongcc_SI_type

このマクロは、システムの C コンパイラで SImode に対応するデータ型名を定義する。
その型が通常の long int なら、このマクロを定義する必要はない。 

nongcc_word_type

このマクロは、システムの C コンパイラで word_mode に対応するデータ型名を定義する。
その型が通常の long int なら、このマクロを定義する必要はない。 

perform_...

これらのマクロは、libgcc1.c 中のライブラリルーチン群にある、float 型と double 型についての様々な算術演算を実行する C の文を明示的に提供するように定義する。これらのマクロとその引数の完全なリストについては libgcc1.c を見ること。

ほとんどの機種では、これらのマクロはどれも定義する必要がない。何故なら、システム付属の C コンパイラが面倒を見るからである。 

NEXT_OBJC_RUNTIME

このマクロは、NeXT システムの呼び出し規約を使って Objective C のメッセージを送信するためのコードを生成するように定義する。この呼び出し規約には、オブジェクト、セレクタ、メソッド引数を全て一度にメソッド検索ライブラリ関数に渡すことが含まれる。

デフォルトの呼び出し規約は、オブジェクトと検索関数のセレクタを渡すだけである。検索関数はメソッドへのポインタを返す。


##アドレッシングモード

この節では、アドレッシングモードについて説明する。

HAVE_POST_INCREMENT
マシンがポストインクリメントのアドレッシングをサポートしている場合は、ゼロでない値を取る C の式である。 
HAVE_PRE_INCREMENT
HAVE_POST_DECREMENT
HAVE_PRE_DECREMENT
HAVE_POST_INCREMENT に同様である。 
CONSTANT_ADDRESS_P (x)
RTX x がアドレスとして有効な定数であれば、1 となる C の式を定義する。多くのマシンでは、CONSTANT_P (x) として定義すれば良いが、幾つかのマシンではアドレスとして使える定数に制限がある。
CONSTANT_P は、明示的には未知である値を持つ、整数値の式を受け付ける。そのような式としては、例えば、symbol_ref、label_ref、high といった式、const 算術式、const_int、const_double 式がある。 

MAX_REGS_PER_ADDRESS
有効なメモリアドレスに現れることができるレジスタ数の最大値を表す数である。 GO_IF_LEGITIMATE_ADDRESS が受け付ける最大数に等しい値を指定するかどうかは読者の責任であることに注意。 
GO_IF_LEGITIMATE_ADDRESS (mode, x, label)
条件付きの goto label; を含む一個の C の複文。この goto は、x(ある RTX) がターゲット機種で、モード mode のメモリオペランドとして正しいメモリアドレスである場合に実行される。
普通は、幾つかの単純なマクロを定義して、このマクロのサブルーチンとする。そうしないと、大変複雑になりがちで理解するのが難しくなるからである。

このマクロは二種類なければならない。厳密な版と厳密でない版である。厳密な版は再ロード・パスで使われる。これは、ハードレジスタが割り当てられていない疑似レジスタはすべてメモリ参照であると考えられるように定義しなければならない。なにかの種類のレジスタを必要とする文脈では、ハードレジスタが割り当てられていない疑似レジスタは拒絶しなければならない。

厳密でない版は他のパスで使われる。こちらは、なにかの種類のレジスタが必要とされる、あらゆる文脈で全ての疑似レジスタを受け付けるように定義しなければならない。

GNU CC のソースファイルで、このマクロの厳密版を使いたいところでは、マクロを REG_OK_STRICT を定義する。条件文 #ifdef REG_OK_STRICT を使って、厳密版を使いたいところでは厳密版を定義し、それ以外のところでは厳密でない版を定義するべきである。

色々な目的(ベースレジスタ向けや、インデックスレジスタ向けなど)に受付可能なレジスタを検査するサブルーチン群は、普通はGO_IF_LEGITIMAITE_ADDRESS を定義するのに使われるサブルーチン群の中にある。これらのサブルーチンマクロだけが二つの変種を必要とする。高レベルのマクロは厳密であってもなくても同じで良い。

通常、symbol_ref と整数の和である定数アドレスは、const RTX の内側に格納され、定数であるという印が付けられる。このため、このような和を正当なアドレスとして特別に認識する必要はない。普通は、単に const は全て正当であるとして認識すれば良い。

通常、PRINT_OPERAND_ADDRESS は、const が付いていない定数和を扱う準備はしていない。単体の plus があると、インデックスすることを想定している。もしそうなら、そのような単体の定数和は不正なアドレスとして拒絶して、PRINT_OPERAND_ADDRESS に渡らないようにしなければならない。

機種によっては、シンボリックなアドレスが正当かどうかはそのアドレスが参照しているセクションに依存する。そういう機種では、マクロ ENCODE_SECTION_INFO を定義して、その情報を symbol_ref に格納し、そこで検査を行なうようにする。const があった場合は、その中を見て symbol_ref を探し、セクションを決定する必要がある。See Assembler Format。

名前の文字列を修正する最善の方法は、文字列の前にテキストを追加し、さらに適当な区切り文字を付けて、曖昧さをなくすことである。ASM_OUTPUT_LABELREF を修正して、追加テキストを消去してデコードし、かつ、その名前を適切に出力し、さらに STRIP_NAME_ENCODING を定義して、元の名前の文字列を参照するようにする必要がある。

ここで symbol_ref に貯えた情報を、マクロ GO_IF_LEGITIMATE_ADDRESS と PRINT_OPERAND_ADDRESS の定義の中で検査することができる。 

REG_OK_FOR_BASE_P (x)
一個の C の式。この式は、x (reg RTX と仮定される) がベースレジスタとして使うのに適していれば、ゼロでない値となる。ハードレジスタの場合には、常に、ハードウェアが許すものは受け付けて、それ以外は拒絶すべきである。このマクロが疑似レジスタを受け付けるか拒絶するかは、上記のREG_OK_STRICT により制御されなければならない。普通、これには二種類の定義が必要になる。REG_OK_STRICT が実際に使われるものを選ぶ。 
REG_MODE_OK_FOR_BASE_P (x, mode)
一個の C の式。REG_OK_FOR_BASE_P にほとんど同じであるが、その式が mode のメモリ参照のモードを調べるという点が異なる。そのメモリ参照のモードが、あるレジスタがベースレジスタとして使えるかどうかに影響するなら、このマクロを定義すべきである。このマクロを定義すると、GNU CC は REG_OK_FOR_BASE_P の代わりにこちらを使う。 
REG_OK_FOR_INDEX_P (x)
一個の C の式で、その値は、x (reg RTX と仮定される)がインデックスレジスタとして使うのが有効なら、ゼロでない値となる。
インデックスレジスタとベースレジスタの違いは、インデックスレジスタはスケーリングされることである。あるアドレスが二つのレジスタの和を含んでいて、そのどちらもスケーリングされないのであれば、どちらか一つが「ベース」となり、他方は「インデックス」というラベルが貼られる。だが、どちらのラベル付が使われても、レジスタがそれぞれの役割を果たす、その機種の制約に収まらなければならない。コンパイラは両方のラベル付を試して、有効なものを一つ見つけ出し、どちらのラベル付も動作しない場合にのみ、一方のレジスタ、あるいは両方のレジスタを再ロードする。 

LEGITIMIZE_ADDRESS (x, oldx, mode, win)
一個の C の複文。この文は、x をモード mode のオペランドの有効なメモリアドレスで置き換えることを試みる。win は、コード中のどこか別のところにある 一個の C のラベルである。このマクロ定義は、
GO_IF_LEGITIMATE_ADDRESS (mode, x, win);
を使って、アドレスが正当なものになっている場合には、それ以上の処理を避ける。

x は、常に break_out_memory_refs の呼び出しの結果であり、oldx は、その関数に与えられて x を生成したオペランドである。

このマクロにより生成されたコードは x の下位構造を変えてはならない。このコードがx をより正しい形に変換するなら、x(これは常に、ある C の変数になる)に新しい値を割り当てるべきである。

このマクロが正しいアドレスを提示する必要はない。コンパイラには全ての場合に正しいアドレスにする標準的な方法がいくつかある。だが、機種依存の戦略を取ると生成されるコードが良くなることも多い。 

LEGITIMIZE_RELOAD_ADDRESS (x, mode, opnum, type, ind_levels, win)
C の複文。この複文は、再ロードを必要とするアドレスである x を、モード mode のオペランドに対する有効なメモリ参照で置き換えることを試みる。win はコードのどこか別の場所にある、C の文ラベルになる。このマクロを定義するのは必須ではないが、実行速度の点から有用である。
例えば、i386 では、二つの疑似レジスタの和を一個のレジスタに再ロードすることにより、二つの再ロードレジスタの代わりに一つの再ロードレジスタを使用することが可能なことがときどきある。一方、多くの RISC プロセッサのオフセットは限られているので、スタックスロットをアドレスために中間のアドレスを生成する必要があることが多い。LEGITIMIZE_RELOAD_ADDRESS を適切に定義すると、近くにまとまっている幾つかのスタックスロット用に生成される中間アドレスを同じものにする事ができるので、共有が可能にある。

注意。このマクロを使うには注意が必要である。これを効率良く使うためには再ロードの仕組みをいくらか知っている必要がある。そして、再ロードの内部についての知識をたくさん詰め込んだマクロを生成するのはきわめて簡単である。

注意。このマクロは、前回のこのマクロの呼出しにより作られたアドレスを再ロードできなければならない。そういうアドレスの取扱いに失敗すると、GCC は正しくないコードを生成したり、異常終了したりする。

このマクロの定義では、push_reload を使って、再ロードが必要な部分を示す必要がある。num、type、ind_ldevels は普通は変更無しで push_reload に渡すのに適している。

このマクロが生成したコードは、x の下位構造を変更してはならない。これが x をさらに正統な形に変換するなら、x (これは常に C の変数である)に新しい値を割り当てる必要がある。これは、push_reload を呼び出すことで間接的に変更した部分にも適用される。

このマクロは、strict_memory_address_p を使って、アドレスが正統になるかどうかを検査しても良い。

x の一部だけ変更したいときの標準的な方法の一つは、copy_rtx を使うことである。ただし、共有しないのは RTL の一つのレベルだけである。つまり、変更される部分がトップのレベルにないときは、まずトップレベルを置き換える必要がある。このマクロが正統なアドレスを出す必要はない。だが、機種依存の戦略がより良いコードを生成可能な事が多い。 

GO_IF_MODE_DEPENDENT_ADDRESS (addr, label)
一個の C の文か複文であり、条件付きの goto label; を含む。この goto は、メモリアドレス x (一個の RTX)がそれに使われるメモリ参照のマシンモードによって意味が違ったり、そのアドレスがあるモードでは有効だがその他のモードでは有効ではないという場合に実行される。
自動インクリメントと自動デクリメントのアドレスには、普通モードに依存した効果がある。なぜなら、インクリメントとデクリメントの量は対象のオペランドの大きさだからである。機種によっては、その他にモード依存のアドレスを持つものもある。多くの RISC 機種にはモード依存のアドレスがない。

addr がその機種の有効なアドレスであると仮定して良い。 

LEGITIMATE_CONSTANT_P (x)
一個の C の式。この式は、x がターゲット機種の即値オペランドとして正しい定数ならゼロでない値となる。x は CONSTANT_P を満たすと仮定して良いので、その検査は必要ない。実際、 CONSTANT_P が有効な機種では、1 がこのマクロの適切な定義になる。

##条件コードステータス

条件コードステータスについて説明する。

ファイル conditions.h で、変数 cc_status を定義している。これは、条件コードがどのように計算されるかを記述している(条件コードを設定した命令によって条件コードの解釈が異なる場合)。この変数は、条件コードが現在元にしている RTL 式と、色々な標準のフラグを含んでいる。

場合によっては、機種固有のフラグをマシン記述ヘッダファイルで追加で定義しなければならないこともある。また、機種固有の情報を CC_STATUS_MDEP を定義することで追加することができる。

CC_STATUS_MDEP

cc_status の mdep 成分を宣言するのに使われるデータ型についての C のコード。デフォルトは int になる。
このマクロは、cc0 を使用しない機種では使われない。 

CC_STATUS_MDEP_INIT

mdep フィールドを「空」に初期化する C の式。デフォルトの定義は何もしない。何故なら、ほとんどの機種ではこのフィールドは使わないからである。このフィールドを使う場合には、恐らくこのマクロを定義して初期化をすべきであろう。
このマクロは、cc0 を使用しない機種では使われない。 

NOTICE_UPDATE_CC (exp, insn)

本体が exp である insn insn に対してcc_status の成分を適切に設定する、C の複文。このマクロは、条件コードを設定する insn を認識する責任を負う。これには、明示的に (cc0) を設定するものだけでなく、他の処理の副産物として条件コードを設定するものも含まれる。
このマクロは、cc0 を使用しない機種では使われない。

条件コードは設定しないが他のマシンレジスタをいじる命令があるなら、このマクロで、条件コードがそれを反映するように記録されている式をそれらの命令が無効にするかどうかを検査しなければならない。例えば、68000 では、アドレスレジスタにストアする命令は条件コードを設定しない。これは普通 NOTICE_UPDATE_CC がそういう命令に対して cc_status を変えないままにしておくことが可能であるということを意味する。だが、直前の命令が a4@(102) という位置に基づいて条件コードを設定し、現在の命令が新しい値を a4 にストアするとしよう。条件コードはこれにより変更されないものの、それが a4@(102) の内容を反映しているというのはもはや真ではない。このため、NOTICE_UPDATE_CC は、この場合 cc_status を変更することにより、条件コード値については何もわからないということを言わなければならない。

NOTICE_UPDATE_CC は、覗き穴最適化の結果を扱う準備をするように定義しなければならない。覗き穴最適化の結果とは、そのパターンが様々な、reg や mem、あるいは単なるオペランドである定数を含む parallel RTX であるような insn 群である。これらの insn の RTL 構造は、その insn が実際に何をするのかを表すのには充分ではない。NOTICE_UPDATE_CC が、こういう insn に対してなすべきことは、単に CC_STATUS_INIT を実行することである。

NOTICE_UPDATE_CC の可能な定義の一つは、例えば cc という名前の属性(see Insn Attributes)を見る関数を呼び出すことである。これにより、パターンについての詳細な情報を二箇所、すなわちmd ファイルと NOTICE_UPDATE_CC に置くのを避けることができる。 

EXTRA_CC_MODES

レジスタにある条件コード値の追加のモードに使われる名前のリストである。このリストの名前は、enum machine_mode に追加され、その全てがクラス MODE_CC を持つ。規約により、これらの名前は CC で始まり、mode で終わるようにする。
このマクロを定義するのは、cc0 を使わない機種で、しかも追加のモードが必要な場合に限ること。 

EXTRA_CC_NAMES

EXTRA_CC_MODES に列挙したモードの名前を与える C の文字列のリスト。例えば、SPARC では、このマクロと EXTRA_CC_MODES を以下のように定義している。
#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode, CCFPEmode
#define EXTRA_CC_NAMES "CC_NOOV", "CCFP", "CCFPE"
このマクロは、EXTRA_CC_MODES が定義されていなければ必要とされない。 

SELECT_CC_MODE (op, x, y)

クラス MODE_CC のあるモードで、比較演算コード op をRTX x と y に適用したときに使われるものを返す。例えば、SPARC では、SELECT_CC_MODE は、以下のように定義されている(see Jump Patterns でこの定義の理由を説明している)。

```
#define SELECT_CC_MODE(OP,X,Y) \
  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \
   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \
   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \
       || GET_CODE (X) == NEG) \
      ? CC_NOOVmode : CCmode))
```

このマクロは、EXTRA_CC_MODES が定義されていなければ、定義する必要はない。 

CANONICALIZE_COMPARISON (code, op0, op1)

機種によっては、可能な比較が全ては定義されていないものがあるが、無効な比較を有効なものに変換することができる。例えば、Alpha には GT の比較がないが、代わりに LT の比較を使って、オペランドの順番を入れ替えることができる。

そういう機種では、このマクロを一個の C の文として定義し、必要な変換を行なうようにする。code は、最初の比較コードであり、op0 と op1 はそれぞれ比較の左オペランドと右オペランドである。必要に応じて、code と op0、op1 を更新すべきである。

GNU CC は、このマクロから生じる比較が有効であるとは仮定しないが、結果の insn が md ファイルにあるパターンにマッチするかどうかは分かる。

比較のコードやオペランドを変更することが全くないのなら、このマクロを定義する必要はない。 

REVERSIBLE_CC_MODE (mode)

モードが mode の比較を反転することが常に安全に行なえるのなら、値が 1 となる C の式である。SELECT_CC_MODE が浮動小数点の不等性の比較に対して、常に mode を返すことができるなら、REVERSIBLE_CC_MODE (mode) はゼロでなければならない。

このマクロが常にゼロを返すか浮動小数点形式が IEEE_FLOAT_FORMAT 以外なら、このマクロを定義する必要はない。例えば、以下に Sparc で使われている定義を示す。浮動小数点数の不等性の比較は常に CCFPEmode で与えられる。

```
#define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)
```

##操作の相対的コストの記述

以下のマクロ群を使って、ターゲットマシンの色々な操作の相対的な速度を記述する。

CONST_COSTS (x, code, outer_code)

C の switch 文の一部を定義する。この switch 文の断片では、定数 RTL 式の相対的なコストを記述する。式コード const_int、const、symbol_ref、label_ref、const_double にそれぞれ対応する case ラベルが含まれていなければならない。各ケースでは、最終的には return 文に達して、その種類の定数値を式の中で使うことの相対的なコストを返さなくてはならない。コストは、定数の具体的な値に依存する可能性がある。この定数はx を調べるのに使うことができる。そして、それを含む式の RTX コードはouter_code に入っている。

code は式コードである。これは冗長である。というのは、GET_CODE (x) で求めることができるからである。 

RTX_COSTS (x, code, outer_code)

CONST_COSTS とほぼ同じだが、違いは非定数 RTL 式に適用されることである。これを使って、例えば、乗算命令のコストがどれぐらいかを示すことができる。このマクロを書くときは、定数COSTS_N_INSNS (n) を使って、n 個の高速な命令に等しいコストを指定することができる。outer_code は、x が含まれている式のコードである。
このマクロはオプションであり、デフォルトのコストの想定がターゲット機種に適しているなら定義しないこと。 

DEFAULT_RTX_COSTS (x, code, outer_code)

このマクロが定義されていると、RTX_COSTS や CONST_COSTS マクロで取り扱われない場合に呼び出される。これにより、case のラベルをマクロにいれる必要がなくなるが、そのコード、あるいはそれを呼び出す関数は、x 中の RTL は既に取り扱われたことの内どんな型にでもなりうることを保証しなければならない。引数は RTX_COSTS のものと同じである。そしてこのマクロは、取扱いが可能な任意の RTL 式のコストを与える return 文を実行する必要がある。このマクロが値を返さない RTL に対しては、デフォルトのコスト計算が使われる。
このマクロはオプションである。デフォルトのコスト想定がターゲット機種にてきせつであるなら定義しないこと。 

ADDRESS_COST (address)

address を含むアドレッシングモードのコストを与える式である。定義されていないと、コストは address 式と CONST_COSTS の値から計算される。
ほとんどの CISC マシンでは、デフォルトのコストが、そのアドレッシングモードの実際のコストの良い近似になっている。だが、RISC マシンでは、普通、全ての命令が同じ命令長と実行時間になる。このため、全てのアドレスのコストが等しくなる。

アドレス形式が複数ある場合には、コストが最小の形式が使われる。複数の形式が同じ最小のコストになる場合には、最も複雑なものが使われる。

例えば、あるレジスタとある定数の和に等しいアドレスが同じ基本ブロック内で二回使われたとしよう。このマクロが定義されていないときは、このアドレスはあるレジスタで計算され、メモリ参照はそのレジスタを通した間接参照になる。この和を含むアドレッシングモードのコストが、単純な間接参照のコストより高くない機種では、これにより、命令が一個追加され、恐らく追加のレジスタも一個必要になるだろう。このマクロで適切に指定すると、こういう機種でのオーバーヘッドを消去する。

このマクロは、ループの強度削減においても似たような使い方をされる。

address はアドレスとして有効である必要はない。その場合、コストは関係ないのでどんな値にもなりうる。無効なアドレスに別のコストを割り当てる必要はない。

レジスタ一個よりも多くのものを含むアドレスの計算コストがレジスタを一個しか含まないアドレスのコストと同じである機種では、ADDRESS_COST を定義してそのことを反映させると、ADDRESS_COST がそのように定義されていなければ一つしか生存できないようなあるコードの範囲で、二つのレジスタが生存できるようになる。この効果はこのマクロを定義するときに考慮に入れる必要がある。コストが等しくなるのは、おそらく、たくさんレジスタのある機種上で、異なる数のレジスタを含むアドレスの場合だけになるはずである。

このマクロは普通は、定義しないか、定数として定義されるかのどちらかである。 

REGISTER_MOVE_COST (from, to)

クラス from のレジスタから、クラス to のレジスタへデータを移動するコストを表す式。クラスは、GENERAL_REGS のような列挙値で表される。2 という値がデフォルトである。その他の値は、2 に相対的な値として解釈される。
from が to と同じである場合、コストが常に 2 である必要はない。機種によっては、汎用レジスタでないレジスタ間での移動が高くつくものがある。

再ロードパスで二つのハードレジスタを使った一個の set からなる insn を見つけると、それらのレジスタのクラスに REGISTER_MOVE_COST を適用すると 2 という値を返すなら、再ロードパスはその insn の制約が満たされることを保証するための検査を行なわない。レジスタ移動のコストを 2 以外にすると再ロードパスは制約が満たされることを検証する。movm というパターンの制約がこのようなコピーを許さないのであれば、コストを 2 以外にすべきである。 

MEMORY_MOVE_COST (mode, class, in)

モード mode のデータをクラス class のレジスタとメモリの間で移動するコストを表す式。in は、値がメモリに書き込まれるべきものならゼロであり、読み出すべきものならゼロでない値となる。このコストは、REGISTER_MOVE_COST のコストに相対的な値である。レジスタとメモリの間の移動が、二つのレジスタ間のものより高く付くなら、このマクロが相対的なコストを表すように定義すべきである。

このマクロを定義しない場合、GCC はデフォルトのコスト 4 に、もしそれが必要であれば、第二の再ロードレジスタを経由してコピーするコストを足したものを使う。メモリと class のレジスタの間でコピーをするのに第二の再ロードレジスタを必要とするが、再ロードの機構が中間を経由してコピーするより複雑な場合は、このマクロを定義して、そういう移動の実際のコストを反映させるようにする。

GCC は、第二の再ロードレジスタが必要な場合、memory_move_secondary_cost という関数を定義する。これは、第二の再ロードレジスタ経由のコピーによるコストを計算する。読者の機種では、メモリから第二のレジスタを使って伝統的な方法でコピーを行うが、しかしデフォルトのベース値の 4 では合わないという場合は、このマクロを定義して、この関数の結果に何か他の値を加えるようにする。この関数への引数は、このマクロへの引数と同じである。 

BRANCH_COST

分岐命令のコストを表す C の式。1 という値がデフォルトである。その他の値は 1 に対しての相対値として解釈される。
以下に示すマクロは、正確な相対的コストは指定せず、ある動作が GNU CC が普通期待するよりも高くつくということだけを示す。

SLOW_BYTE_ACCESS

大きさがワードより小さなメモリをアクセスするのが、ワードをアクセスするより速くないなら、すなわち、二個以上の命令を必要とするか、バイトのロードと(整合されている)ワードのロードの間でコストに差がないなら、0 でない値を持つ C の式をこのマクロに定義する。

このマクロが定義されていない場合は、コンパイラはフィールドをアクセスするのに、それを含む最小のオブジェクトを探すことで行なう。定義されていれば、アラインメントが許せば、全ワードのロードが使われる。バイト単位のアクセスがワード単位のアクセスよりも高速でないかぎり、ワード単位のアクセスが望ましい。というのは、後続のメモリアクセスが、その構造体の同じワード内の異なるバイトにある他のフィールドをアクセスする場合は、そのメモリ参照を消去できるからである。 

SLOW_ZERO_EXTEND

char または short の int へのゼロ拡張が、デスティネーションがゼロであることがわかっているレジスタの場合には高速に行なわれるなら、このマクロを定義する。
このマクロを定義する場合は、以下のような構造の RTL を認識する命令パターンを持っていなければ成らない。

```
(set (strict_low_part (subreg:QI (reg:SI ...) 0)) ...)
```

HImode についても同様である。 

SLOW_UNALIGNED_ACCESS

整合の取れていないアクセスのコストが整合しているアクセスのコストよりも何倍も高い場合、例えばトラップハンドラでエミュレートされているような場合は、このマクロを値 1 に定義すること。

このマクロがゼロでない場合は、GNU CC は、ブロック移動用のコードを生成するとき STRICT_ALIGNMENT がゼロでないかの用に動作する。これにより、非常にたくさんの命令が生成される可能性がある。このため、整合の取れていないアクセスが、1 サイクルか 2 サイクル程度しかメモリアクセスの時間に加わらない場合は、このマクロをゼロでない値に定義しないこと。

このマクロの値が常にゼロなら、定義する必要はない。 

DONT_REDUCE_ADDR

このマクロを定義すると、メモリアドレスの強度削減が禁止される。機種によっては、そういう強度削減は百害あって一利なしである。 

MOVE_RATIO

スカラのメモリ-メモリ移動 insn の数の敷居値である。この値より小さい と、ある insn 列を、文字列移動命令やライブラリ呼出しの代わりに生成する必要がある。。この値を大きくすると必ずコードが速くなるが、いつかはコードサイズが増大することによるコストが高くなる。

メモリ-メモリ移動命令がない機種では、このマクロは対応する、メモリ-メモリ 命令列 の数を表す。

これを定義しない場合は、適切なデフォルトが使われる。 

MOVE_BY_PIECES_P (size, alignment)

一個の C の式。この式は、メモリの塊を一つコピーするのに move_by_pieces が使われるかどうか、あるいは何か他のブロック移動のための機構が使われるかどうかを決定するのに使われる。move_by_pieces_ninsns がMOVE_RATIO より小さい値を返すなら、デフォルトは 1 になる。 

MOVE_MAX_PIECES

一個の C の式。move_by_pieces で、メモリをコピーするのに使われるロードあるいはストアの最大単位を決定するのに使われる。デフォルトは MOVE_MAX になる。 

USE_LOAD_POST_INCREMENT (mode)

一個の C の式。ロード・ポストインクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_POST_INCREMENT の値になる。 

USE_LOAD_POST_DECREMENT (mode)

一個の C の式。ロード・ポストデクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_POST_DECREMENT の値になる。 

USE_LOAD_PRE_INCREMENT (mode)

一個の C の式。ロード・プリインクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_PRE_INCREMENT の値になる。 

USE_LOAD_PRE_DECREMENT (mode)

一個の C の式。ロード・プリインクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_PRE_INCREMENT の値になる。 

USE_STORE_POST_INCREMENT (mode)

一個の C の式。ストア・ポストインクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_POST_INCREMENT の値になる。 

USE_STORE_POST_DECREMENT (mode)

一個の C の式。ストア・ポストデクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_POST_DECREMENT の値になる。 

USE_STORE_PRE_INCREMENT (mode)

一個の C の式。ストア・プリインクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_PRE_INCREMENT の値になる。 

USE_STORE_PRE_DECREMENT (mode)

一個の C の式。ストア・プリデクリメントを、指定したモードに使うのが良いかどうかを決めるのに使われる。デフォルトは HAVE_PRE_DECREMENT の値になる。 

NO_FUNCTION_CSE

定数の関数アドレスを呼び出すほうが、レジスタに保持されたアドレスを呼び出すよりも効率が良いか同等なら、このマクロを定義する。 

NO_RECURSIVE_FUNCTION_CSE

関数が自分自身を呼び出すのに、明示的なアドレスを使ったほうが、レジスタに保持されているアドレスを呼び出すより効率が良いか同等なら、このマクロを定義する。 

ADJUST_COST (insn, link, dep_insn, cost)

一個の C の文(セミコロンなし)。この文は、整数変数 cost を、insn との関係に基づいて更新する。insn は、依存関係 link を通じて dep_insn に依存する。デフォルトでは、cost の調整はなんら行なわれない。これは、例えば、スケジューラに対し、出力依存や逆依存はデータ依存と同じコストは被らないことを指示するのに使うことができる。 

ADJUST_PRIORITY (insn)

一個の C の文(セミコロンなし)。この文は整数のスケジューリング優先度INSN_PRIORITY(insn) を更新する。insn を早めに実行するには優先度を下げ、遅めに実行するには優先度を上げる。insn のスケジューリング優先度を調整する必要がなければこのマクロは定義しないこと。

##出力をセクション(text, data, ...)に分割する

あるオブジェクトファイルは、異なる型のデータを含む幾つかのセクションに分けられる。最も共通のケースとして、三つのセクションがある。テキスト・セクションは、機械命令と読みだし専用のデータを含む。データ・セクションは、初期された書き込み可能なデータを含む。BSS セクション は、非初期化データを含む。システムによっては、他の種類のセクションを持つ。

コンパイラはアセンブラに対していつセクションを切り替えるかの指示を出さなくてはならない。以下のマクロ群は、アセンブラに対してこの切替えを指示するコマンドの制御を行なう。

TEXT_SECTION_ASM_OP

機械命令と読みだし専用データの直前に現れる必要があるアセンブラ命令を表す文字列を値として持つ C の式である。普通は ".text" となる。 

DATA_SECTION_ASM_OP

後続のデータが初期化済の書き込み可能なデータであることを指示するアセンブラ命令を表す文字列を値として持つ C の式である。普通は ".data" となる。 

SHARED_SECTION_ASM_OP

定義されている場合は、後続のデータが共有データであることを特定するアセンブラ命令を表す文字列を値として持つ C の式である。定義されていない場合は、DATA_SECTION_ASM_OP が使われる。 

BSS_SECTION_ASM_OP

定義されている場合は、後続のデータが非初期化データであることを指示するアセンブラ命令を表す文字列を値として持つ C の式である。これが定義されておらず、かつ ASM_OUTPUT_BSS もASM_OUTPUT_ALIGNED_BSS も定義されていない場合は、非初期化グローバルデータは -fno-common が指定されている場合は、データセクションに出力され、それ以外の場合は ASM_OUTPUT_COMMON が使われる。 

SHARED_BSS_SECTION_ASM_OP

定義されている場合は、後続のデータが非初期化共有データであることを指示するアセンブラ命令を表す文字列を値として持つ C の式である。これが定義されておらず、かつ BSS_SECTION_ASM_OP が定義されている場合は、BSS_SECTION_ASM_OP が使われる。 

INIT_SECTION_ASM_OP

定義されている場合は、後続のデータが初期化コードであることを指示するアセンブラ命令を表す文字列を値として持つ C の式である。定義されていない場合は、GNU CC はこのようなセクションは存在しないと仮定する。 

EXTRA_SECTIONS

標準の二つのセクション、in_text と in_data 以外の他のセクションの名前のリストである。(GCC が使わなければならない)他のセクションが存在しないシステムでは、このマクロを定義する必要はない。 

EXTRA_SECTION_FUNCTIONS

varasm.c で定義されるべき関数を 1 個以上ならべたもの。ここで指定した関数の仕事は、関数 text_section や data_section が行なう作業と同様な作業を追加のセクションに対して行なうことである。EXTRA_SECTIONS を定義しない場合には、このマクロは定義しないこと。 

READONLY_DATA_SECTION

多くのマシンでは、読みだし専用変数、定数、ジャンプ表はテキストセクションに置かれる。これにあてはまらないマシンの場合は、このマクロには、読みだし専用のデータに使われるセクションへの切替えを行なう関数名(data_section かEXTRA_SECTIONS で定義されている関数のどれか)を定義する必要がある。
読みだし専用のデータがテキストセクションに置かれるべきものなら、このマクロは定義するべきでない。 

SELECT_SECTION (exp, reloc)

exp を出力するのに適したセクションへの切替えを行なう C の一個の文か複数の文。exp は VAR_DECL ノードか、ある種類の定数と仮定して良い。reloc は、exp の初期値がリンク時に再配置を必要とするかどうかを指示する。text_section か、他のセクション向けの関数を呼び出すことでセクションを選択するようにする。

全ての読みだし専用変数と定数を読みだし専用セクション(普通はテキストセクション)に置く場合は、このマクロを定義しないこと。 

SELECT_RTX_SECTION (mode, rtx)

rtx をモード mode で出力するのに適したセクションへの切替えを行なう C の一個の文か複数の文。rtx は、RTL 中のある種類の定数と仮定して良い。引数 mode は、const_int rtx の場合は冗長である。text_section か、他のセクション向けの関数を呼び出すことでセクションを選択するようにする。

定数は全て、読みだし専用データセクションにおくなら、このマクロを定義しないこと。 

JUMP_TABLES_IN_TEXT_SECTION

ジャンプ表(insn tablejump 向け)は、アセンブラ命令と一緒にテキストセクションに置くべきなら、このマクロをゼロでない値を持つ式として定義する。それ以外の場合は、読みだし専用データセクションが使われる。
このマクロは、独立した読みだし専用データセクションがない場合には関係してこない。 

ENCODE_SECTION_INFO (decl)

シンボルへの参照を、そのシンボルにより指定される変数や関数についての何かの情報に依存して、取扱を変えなくてはならない場合に、このマクロを定義する。例えば、そのシンボルがどのセクションに属するかといった情報である。
このマクロは、定義されていれば、decl についての rtl が生成され、DECL_RTL (decl) に格納された直後に実行される。この rtl の値は、アドレスが symbol_ref である mem になる。

このマクロで通常行なうべきことは、SYMBOL_REF_FLAG のような、symbol_ref 内のフラグを記録したり、(1ビットでは表せない情報であれば) symbol_ref 内の修正された名前の文字列を格納することである。 

STRIP_NAME_ENCODING (var, sym_name)

セクション情報をエンコードする文字群なしで、sym_name をデコードし、var の実際の名前の部分を格納する。ENCODE_SECTION_INFO がシンボル名文字列を書き換える場合はこのマクロを定義する。 

UNIQUE_SECTION_P (decl)

ターゲット固有の理由により、decl がある一意的なセクションに置かれるべきであるなら、評価すると真になるような C の式。このマクロを定義しない場合のデフォルトは、0 である。-ffunction-sections オプションを指定することでも、関数を一意的なセクションに置かれる事に注意。 

UNIQUE_SECTION (decl, reloc)

一意的なセクション名を組み立てる C の式で、STRING_CST ノードとして表され、DECL_SECTION_NAME (decl) に代入される。reloc で、exp の初期値がリンク時の再配置を必要とするかどうかを指定する。このマクロを定義しない場合は、GNU CC はシンボル名の前に . を付けたものをセクション名として使う。

##位置独立コード

このセクションでは、位置独立コード(Position Independent Code, PIC)の生成を実装する手助けをするマクロを説明する。以下のマクロを単に定義するだけでは、正しい PIC を生成するには十分ではない。マクロ、GO_IF_LEGITIMATE_ADDRESS と PRINT_OPERAND_ADDRESS、LEGITIMIZE_ADDRESS についてもサポートを追加しなければならない。movsi の入力オペランドがシンボルで表されたアドレスを含んでいる時に適切な処理を行なうように、movsi の定義を修正しなければならない。また、switch 文の扱いを、相対アドレスを使うように書き換える必要もある。

PIC_OFFSET_TABLE_REGNUM

メモリ中の静的なデータアドレスのテーブルを参照するのに使うレジスタの番号である。場合によっては、このレジスタはプロセッサの「アプリケーションバイナリインターフェース」(ABI) で定義されることもある。このマクロが定義されていると、このレジスタの RTL は一回だけ生成される。これは、スタックポインタやフレームポインタレジスタの場合と同じである。このマクロが定義されていない場合は、必要に応じてこのようなレジスタを割り当てるのは機種依存ファイルの責任である。 

PIC_OFFSET_TABLE_REG_CALL_CLOBBERED

PIC_OFFSET_TABLE_REGNUM で定義されるレジスタが、関数呼び出しにより破壊されるならこのマクロを定義する。PIC_OFFSET_TABLE_REGNUM が定義されていない場合は、このマクロは定義しないこと。 

FINALIZE_PIC

位置独立コードを生成することにより、二つの異なったプログラム(AとB)が共通のライブラリ(libC.a) を共有するとき、ライブラリのテキスト部分は、そのライブラリがどちらのプログラムでも同じアドレスにリンクされるかどうかによらず、共有することができる。環境によっては、位置独立コードは、異なるアドレッシングモードを必要とするだけでなく、そのアドレッシングモードを機能させるために特別なコードを必要とすることがある。

マクロ FINALIZE_PIC は、一旦関数がアセンブリコードにコンパイルされれば、これらの特別なコードを生成するフックとして働く。だが、コンパイルされる前はそうでない。(コンパイルされる前に行なわれないのは、インライン関数をコンパイルする場合、インライン関数を使っている関数で PIC のプロローグが複数取り込まれてしまうことになり、その後にアセンブリ言語にコンパイルされるからである。) 

LEGITIMATE_PIC_OPERAND_P (x)

一個の C の式。この式は、x が、ターゲット機種で位置独立コードを生成するときに正しい即値オペランドであるなら、ゼロでない値となる。x は CONSTANT_P を満たしていると仮定して良いので、そのための検査は必要ない。また flag_pic が真であることも仮定して良いので、こちらも検査する必要はない。(SYMBOL_REF を含む)全ての定数が、位置独立コードを生成するときに即値オペランドになりうるのであれば、このマクロを定義する必要はない。

##出力アセンブリ言語の定義

この節では、主な目的がアセンブラ言語での命令の書き方を記述することにあるマクロを紹介する。命令が何をするかは説明しない。

* File Framework: アセンブラファイルの構造に関する情報
* Data Output: 定数(数値、文字列、アドレス)の出力
* Uninitialized Data: 非初期化変数の出力
* Label Output: ラベルの出力と生成
* Initialization: 初期化関数と終了関数についての一般的指針
* Macros for Initialization: 初期関数と終了関数の取扱いを制御する特定のマクロ
* Instruction Output: 実際の命令の出力
* Dispatch Tables: ジャンプ表の出力
* Exception Region Output: 例外領域コードの出力
* Alignment Output: データのアラインメントとスキップについての疑似命令

##アセンブラファイルの全体的枠組

この節では、アセンブラファイルについての全体的な枠組を説明する。

ASM_FILE_START (stream)

アセンブラファイルの先頭に書き出すべきテキストを、標準入出力ストリーム stream へ出力するC の式を定義する。
普通は、このマクロは #NO_APP を含む行を一行出力するように定義される。#NO_APP はコメントであり、多くのアセンブラには何の効果ももたらさないが、GNU アセンブラに対しては、ある種のアセンブラ構文に関する検査を省くことにより、時間を節約することを指示する。

SDB を使用するシステムでは、ある一定のコマンドを出力する必要がある。attasm.h を参照のこと。 

ASM_FILE_END (stream)

アセンブラファイルの末尾に追加される何か適切なテキストを、標準入出力ストリーム stream に出力する C の式。
このマクロが定義されていない場合は、デフォルトはファイルの最後に何も特別なものは出力されない。多くのシステムでは何も定義を必要としない。

SDB を使っているシステムでは、特定のコマンドを出力する必要がある。attasm.h を参照のこと。 

ASM_IDENTIFY_GCC (file)

オブジェクトファイルが GNU CC(あるいは別の GNU コンパイラ)でコンパイルされたことを特定するアセンブラコマンドを出力するC の式。
このマクロを定義しない場合は、gcc-compiled.: という文字列が出力される。この文字列は、BSD システムでは何か他の理由で定義されることが決してないようなシンボルを定義するように選ばれている。GDB は、実行形式ファイルからシンボルテーブルを読み込むときにこのシンボルが存在するかどうかを検査する。

非BSDシステムでは、GDB とのやり取りは何か別の形式で調整しなければならない。GDB が使われていないシステムでは、このマクロの本体を空に定義することができる。 

ASM_COMMENT_START

ターゲットのアセンブラ言語において、コメントを開始する方法を記述するC の文字列定数。コンパイラは、コメントは行末で終了すると仮定する。 

ASM_APP_ON

個々の asm 文、あるいは連続した一塊のasm 文の直前に出力すべきテキストを表す C の文字列定数。通常は "#APP" になる。これは、ほとんどのアセンブラには何の効果もないが、GNU アセンブラに対しては、後続の行が全て正しいアセンブラ構文をなしているかどうかを検査しなければならないことを指示する。 

ASM_APP_OFF

個々の asm 文、あるいは連続した一塊のasm 文の直後に出力すべきテキストを表す C の文字列定数。通常は "#NO_APP" になる。これは、GNU アセンブラに対しては、通常のコンパイラの出力について成り立つ時間を節約する仮定を復活させることを指示する。 

ASM_OUTPUT_SOURCE_FILENAME (stream, name)

一個の C の文。この文では、現在のソースファイル名が name であることを知らせる、COFF 形式の情報または DWARF 形式のデバッグ情報を、標準入出力ストリーム stream に出力する。

使われているファイル形式の標準的な出力形式が適切なものであるなら、このマクロを定義する必要はない。

OUTPUT_QUOTED_STRING (stream, string)

一個の C の文。この文は、文字列 string を標準入出力ストリームstream に出力する。コンフィギュレーションファイルで関数output_quoted_string を呼び出さない場合は、GNU CC はこの関数をアセンブラソースにファイル名を出力するためにしか呼び出さない。このため、この関数をこのマクロと組み合わせて使うことで、ファイル名の形式を正規化することができる。 

ASM_OUTPUT_SOURCE_LINE (stream, line)

一個の C の文。この文は、現在のソースファイルの行番号 line に対するコードの前に DBX または SDB 形式のデバッグ情報を出力する。出力先は標準入出力ストリーム stream である。

使われているデバッガ用の標準的なデバッグ情報形式が適切なものであるなら、このマクロを定義する必要はない。 

ASM_OUTPUT_IDENT (stream, string)

一個の C の文。この文は、string というテキストを含む #ident 制御子を処理するものをアセンブラファイルに出力する。このマクロが定義されていないと、#ident 制御子に対しては何も出力されない。 
ASM_OUTPUT_SECTION_NAME (stream, decl, name, reloc)

一個の C の文。この文は、FUNCTION_DECL か、VAR_DECL か、NULL_TREE であるオブジェクト decl に対して、セクションを name に切り替えるためのものをアセンブラファイルに出力する。reloc は、decl の初期値がリンク時の再配置を必要とするかどうかを指示する。ターゲットのフォーマットによっては、任意のセクションをサポートしていないものもあるので、そういう場合はこのマクロを定義しないこと。

現時点では、このマクロはセクションの属性をサポートするために使われているだけである。このマクロが定義されていないと、セクションの属性は無効になる。 

OBJC_PROLOGUE

一個の C の文。この文は、任意の Objective C のオブジェクト定義やメッセージの送出に先行することが要求されるアセンブラ文を出力する。この文は、Objective C プログラムをコンパイルするときにだけ実行される。

##データの出力

この節ではデータの出力について説明する。

ASM_OUTPUT_LONG_DOUBLE (stream, value)

ASM_OUTPUT_DOUBLE (stream, value)

ASM_OUTPUT_FLOAT (stream, value)

ASM_OUTPUT_THREE_QUARTER_FLOAT (stream, value)

ASM_OUTPUT_SHORT_FLOAT (stream, value)

ASM_OUTPUT_BYTE_FLOAT (stream, value)

標準入出力ストリーム stream に、あるアセンブラ命令を出力する C の文である。このアセンブラ命令は、それぞれ TFmode、DFmode、SFmode、TQFmode、HFmode、QFmode の、値がvalue である浮動小数点定数をアセンブルする。value は、REAL_VALUE_TYPE 型の C の式である。REAL_VALUE_TO_TARGET_DOUBLE のようなマクロを使うと、これらの定義を書く助けとなる。 

ASM_OUTPUT_QUADRUPLE_INT (stream, exp)

ASM_OUTPUT_DOUBLE_INT (stream, exp)

ASM_OUTPUT_INT (stream, exp)

ASM_OUTPUT_SHORT (stream, exp)

ASM_OUTPUT_CHAR (stream, exp)

標準入出力ストリーム stream に、あるアセンブラ命令を出力する C の文である。このアセンブラ命令は、それぞれ 16、8、4、2、1 バイトの、値が value である整数をアセンブルする。exp は、定数値を表す RTL 式である。output_addr_const (stream, exp) を使って、この値を一個のアセンブラ式として出力する。
UNITS_PER_WORD より大きなサイズについては、マクロの動作が、各ワードについて一回づつ、UNITS_PER_WORD の大きさに対応するマクロを繰り返し呼び出すのと同じであるなら、このマクロを定義する必要はない。 

ASM_OUTPUT_BYTE (stream, value)

値が value である一バイトをアセンブルするアセンブラ命令を標準入出力ストリーム stream に出力するための C の文を定義する。 

ASM_BYTE_OP

一バイトの定数列に使われる疑似命令を与える C の文字列定数。このマクロが定義されていない場合、デフォルトは "byte" になる。 

ASM_OUTPUT_ASCII (stream, ptr, len)

長さ len バイトの ptr で示される文字列定数をアセンブルするアセンブラ命令を、標準入出力ストリーム stream に出力するための C の文を定義する。ptr は、char * 型の C の式で、len は、int 型のC の式である。
アセンブラが、Berkeley Unix のアセンブラにあるような .ascii 疑似命令を備えているなら、このマクロは定義しないこと。 

CONSTANT_POOL_BEFORE_FUNCTION

このマクロは一個の C の式として定義する。この式は、GNU CC が、ある関数のコードの前にその関数の定数領域を出力すべきであるなら ゼロでない値とすべきである。定数領域を関数の後に出力すべきなら、ゼロにする。このマクロを定義しない場合は、GNU CC は定数領域を関数の前に出力する。これが普通である。 

ASM_OUTPUT_POOL_PROLOGUE (file, funname, fundecl, size)

関数の定数領域の開始を定義するアセンブラ命令を出力するためのC の文を定義する。funname は、関数名を与える文字列である。その関数の戻り値型が必須であり、その型は funcdecl から取得することができる。size は、このマクロで定義される命令が呼び出された直後に書き出される定数領域の大きさを、バイト単位であらわしたものである。
定数領域の開始を知らせる必要がない普通の場合は、このマクロは定義する必要はない。 

ASM_OUTPUT_SPECIAL_POOL_ENTRY (file, x, mode, align, labelno, jumpto)

特別な取扱いが必要なら、定数プールに一個の定数を出力するC の文。セミコロンは付けても付けなくても良い。(このマクロは、通常どおり出力可能なRTL 式については、何もする必要はない。)

引数 file は、アセンブラコードの出力先の標準入出力ストリームである。mode はマシンモード(この場合 x は、const_intである) である。align は、値 x に必要とされるアラインメントである。これだけのアラインメントを強制するアセンブラ命令を出力すべきである。

引数 labelno は、このプールエントリのアドレスを表す内部ラベルで使われる番号である。このマクロの定義は、適切な場所にラベル定義を出力する責任がある。以下にその方法を示す。

ASM_OUTPUT_INTERNAL_LABEL (file, "LC", labelno);

プールエントリを特別な方法で出力する場合は、ラベル jumpto への goto で終えるべきである。こうすることで、同じプールのエントリが、通常の方法で二回出力されることを防ぐ。

することがなければ、このマクロを定義する必要はない。 

CONSTANT_AFTER_FUNCTION_P (exp)

一個の C の式を定義するマクロ。この式は、tree 型の定数 exp を、関数のコードの後に出力すべきなら、ゼロでない値となる。コンパイラは通常は全ての定数を関数の前に出力する。それで良ければこのマクロを定義する必要はない。 

ASM_OUTPUT_POOL_EPILOGUE (file, funname, fundecl, size)

一個の C の文であり、関数の定数プールの終りに置くアセンブラコマンドを出力する。funname は、関数名を与える文字列である。関数の戻り値型が必要なら、fundecl から得ることができる。size は、GNU CC がこの呼び出しの直前に書き出す定数プールの大きさをバイト単位で表したものである。

定数プールにエピローグが必要なければ、このマクロを定義する必要はない。普通は定義する必要がない。 

IS_ASM_LOGICAL_LINE_SEPARATOR (C)

一個の C の式を定義するマクロ。この式は、C が、アセンブラにより論理的な行区切りとして使われる場合には、ゼロでない値となる。
このマクロを定義しない場合は、デフォルトでは、文字 ; だけが論理的な行区切りとして扱われる。 

ASM_OPEN_PAREN

ASM_CLOSE_PAREN

これらのマクロは C の文字列定数として定義され、算術式をグループ化するためのアセンブラの構文を記述する。ほとんどのアセンブラでは以下の定義で正しい。

```
#define ASM_OPEN_PAREN "("
#define ASM_CLOSE_PAREN ")"
```

以下のマクロは real.h で定義されており、ASM_OUTPUT_DOUBLE やその仲間の定義を書くのに使われる。

REAL_VALUE_TO_TARGET_SINGLE (x, l)

REAL_VALUE_TO_TARGET_DOUBLE (x, l)

REAL_VALUE_TO_TARGET_LONG_DOUBLE (x, l)

REAL_VALUE_TYPE 型の x を、ターゲットの浮動小数点表現に変換し、そのビットパターンをアドレスが l にある、long int 型の配列に格納する。出力される配列の用素数は、対象のターゲット浮動小数点データ型の大きさにより決まる。ビットパターンの 32 ビットずつが、long int 型の配列の各要素に入る。各要素は、たとえ long int がホストマシンの 32 ビットより広くても、変換結果のうちの 32 ビットを保持する。
配列の要素値は、fprintf を使って、ターゲット機種のメモリに現れる順序で出力できるようになっている。 

REAL_VALUE_TO_DECIMAL (x, format, string)

このマクロは、REAL_VALUE_TYPE 型の x を、10進数に変換し、それを文字列として string に格納する。string としては、結果を保持するのに充分長いスペースのメモリブロックのアドレスを渡さなければならない。

引数 format は、出力文字列をどのように整形するかを知らせるprintf と同じ指定である。

##非初期化変数の出力

この節で説明するマクロはそれぞれ、一個の非初期化変数を出力する作業を全部行なう。

ASM_OUTPUT_COMMON (stream, name, size, rounded)

C の文(セミコロンなし)であり、標準入出力ストリーム stream にname という名前でサイズが size バイトのコモンラベルのアセンブラ定義を出力する。変数 rounded は、呼びだし側が要求するアライメントまで切り上げた大きさである。

名前自身を出力するには、assemble_name (stream, name) という式を使う。その前後で、その名前を定義するために追加で必要なアセンブラ構文を出力し、最後に改行を出力する。

このマクロは、非初期化コモングローバル変数のアセンブラ定義がどのように出力されるかを制御する。 

ASM_OUTPUT_ALIGNED_COMMON (stream, name, size, alignment)

ASM_OUTPUT_COMMON とほぼ同じだが、違いは必要となるアラインメントを、独立した明示的な引数として取ることである。このマクロを定義すると、ASM_OUTPUT_COMMON の代わりに使われ、変数に要求されるアラインメントをより柔軟に扱えるようになる。アラインメントはビット数で指定する。 

ASM_OUTPUT_ALIGNED_DECL_COMMON (stream, decl, name, size, alignment)

ASM_OUTPUT_ALIGNED_COMMON とほぼ同じだが、違いは、出力すべき変数がひとつあれば、その宣言 decl を指定する点にある。対応する変数がなければ decl には NULL_TREE を指定する。このマクロを定義すると、GNU CC は ASM_OUTPUT_COMMON とASM_OUTPUT_ALIGNED_COMMON の両方の代わりに使う。何を出力するかを選択するために変数の宣言が見える必要があるときはこのマクロを定義すること。 

ASM_OUTPUT_SHARED_COMMON (stream, name, size, rounded)

定義されていれば、ASM_OUTPUT_COMMON とほぼ同じだが、違いは name が共有されるときに使われる点にある。定義されていないと、ASM_OUTPUT_COMMON が使われる。 

ASM_OUTPUT_BSS (stream, decl, name, size, rounded)

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、name という名前で、サイズが size バイトの非初期化グローバル decl のアセンブラ定義を出力する。変数 rounded は、呼び出し側が要求するアラインメントがなんであれ、そのアラインメントに切り上げられたサイズである。

このマクロを定義するときは varasm.c に定義されている関数 asm_output_bss を使うようにして欲しい。それが不可能な場合は、assemble_name (stream, name) という式を使ってその名前自身を出力する。その前後で、その名前を定義するアセンブラ構文を追加し、次に改行を出力する。

このマクロは、非初期化グローバル変数のアセンブラ定義がどのように出力されるかを制御する。このマクロは、c++ のように common データを持たない言語を適切にサポートするためにある。だが、このマクロは現時点では全てのターゲットで定義されているわけではない。このマクロと ASM_OUTPUT_ALIGNED_BSS が定義されていない場合は、ASM_OUTPUT_COMMON か ASM_OUTPUT_ALIGNED_COMMON かASM_OUTPUT_ALIGNED_DECL_COMMON が使われる。 

ASM_OUTPUT_ALIGNED_BSS (stream, decl, name, size, alignment)

ASM_OUTPUT_BSS に似ているが、違いは、必要なアラインメントを別個の明示的な引数として取ることである。このマクロを定義すると、ASM_OUTPUT_BSS の代わりに使われ、変数で必要とされるアラインメントをより柔軟に扱えるようになる。アライメントはビット数で指定する。

このマクロを定義するときは varasm.c で定義されている関数 asm_output_aligned_bss を使うようにして欲しい。 

ASM_OUTPUT_SHARED_BSS (stream, decl, name, size, rounded)

定義されていれば、ASM_OUTPUT_BSS とほぼ同様だが、違いは name が共有されるときに使われることである。定義されていない場合は、ASM_OUTPUT_BSS が使われる。 

ASM_OUTPUT_LOCAL (stream, name, size, rounded)

一個の C の文(セミコロン無し)。標準入出力ストリーム stream にサイズが size バイトで、name という名前のローカル・コモン・ラベルのアセンブラ定義を出力する。変数 rounded は、呼び出し側が要求するアラインメントに切り上げられるサイズである。

という式を使ってその名前自身を出力する。その前後で、その名前を定義するアセンブラ構文を追加し、次に改行を出力する。

このマクロは、非初期化静的変数のアセンブラ定義をどのように出力するかを制御する。 

ASM_OUTPUT_ALIGNED_LOCAL (stream, name, size, alignment)

ASM_OUTPUT_LOCAL とほぼ同じだが、違いは、必要なアラインメントを別個の明示的な引数として取ることである。このマクロを定義すると、ASM_OUTPUT_LOCAL の代わりに使われ、変数で必要とされるアラインメントをより柔軟に扱えるようになる。アライメントはビット数で指定する。 

ASM_OUTPUT_ALIGNED_DECL_LOCAL (stream, decl, name, size, alignment)

ASM_OUTPUT_ALIGNED_DECL とほぼ同じだが、違いは、出力すべき変数がひとつあれば、その宣言 decl を指定する点にある。対応する変数がなければ decl には NULL_TREE を指定する。このマクロを定義すると、GNU CC は ASM_OUTPUT_DECL とASM_OUTPUT_ALIGNED_DECL の両方の代わりに使う。何を出力するかを選択するために変数の宣言が見える必要があるときはこのマクロを定義すること。 

ASM_OUTPUT_SHARED_LOCAL (stream, name, size, rounded)

定義されていれば、ASM_OUTPUT_LOCAL とほぼ同様だが、違いは name が共有されるときに使われることである。定義されていない場合は、ASM_OUTPUT_LOCAL が使われる。

##ラベルの出力と生成

ラベルの出力について説明する。

ASM_OUTPUT_LABEL (stream, name)

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、name という名前のラベルを出力する。名前自身を出力するには、assemble_name (stream, name) を使うこと。この前後で、名前の定義するアセンブラ構文と改行を追加で出力する。 

ASM_DECLARE_FUNCTION_NAME (stream, name, decl)

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、定義しようとしている関数名 name を宣言するのに必要なテキストを出力する。このマクロはラベル定義を出力する責任がある(おそらく ASM_OUTPUT_LABEL をつかうことになるだろう)。引数 decl は、その関数を表現するFUNCTION_DECL ツリーノードである。
このマクロが定義されていないと、関数名は普通の方法で、あるラベルとして定義される(ASM_OUTPUT_LABEL が使われる)。 

ASM_DECLARE_FUNCTION_SIZE (stream, name, decl)

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、定義しようとしている関数のサイズを宣言するのに必要なテキストを出力する。引数 name は関数名である。引数 decl は、その関数を表現するFUNCTION_DECL ツリーノードである。
このマクロが定義されていないと、関数のサイズは定義されない。 

ASM_DECLARE_OBJECT_NAME (stream, name, decl)

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、定義しようとしている初期化変数の名前 name を宣言するのに必要なテキストを出力する。このマクロはラベル定義を出力しなければならない(おそらくASM_OUTPUT_LABEL を使うことになるだろう)。引数 decl は、その変数を表現する VAR_DECL ツリーノードである。

このマクロが定義されていないと、変数名は普通の方法で、あるラベルとして定義される(ASM_OUTPUT_LABEL が使われる)。 

ASM_FINISH_DECLARE_OBJECT (stream, decl, toplevel, atend)

一個の C の文(セミコロンなし)。この文は、変数名の宣言を終了させる。これは、コンパイラが一旦その初期化子を完全に処理し、その初期化子で制御される場合は配列の大きさを決定する機会があった場合に行なわれる。これは、オブジェクトの大きさについて何か宣言する必要があるシステムで使われる。

このマクロを定義しないのは、何もしないコードに定義するのと同じである。 

ASM_GLOBALIZE_LABEL (stream, name)

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、ラベル name をグローバルにするためのコマンドを出力する。グローバルにするとは、他のファイルから参照可能にすることである。式 assemble_name (stream, name) を使って、名前自体は出力する。その前後で、その名前をグローバルにするアセンブラ構文を追加し、その後に改行を続ける。
 
ASM_WEAKEN_LABEL

一個のC の文(セミコロンなし)。標準入出力ストリーム stream に、ラベル name をウィークにするためのコマンドを出力する。ウィークにするとは、他のファイルから参照可能であるが、それ以外の定義が利用可能でない場合にだけ使われるようにすることである。式 assemble_name (stream, name) を使って、名前自体は出力する。その前後で、その名前をウィークにするアセンブラ構文を追加し、その後に改行を続ける。

このマクロを定義しないと、GNU CC はウィークシンボルをサポートしないので、マクロ SUPPORTS_WEAK を定義してはいけない。 

SUPPORTS_WEAK

ターゲットがウィークシンボルをサポートしているなら、真と評価される C の式である。

このマクロを定義しない場合は defaults.h がデフォルトの定義を提供する。ASM_WEAKEN_LABEL が定義されているとデフォルトの定義は1 で、定義されていないと 0 である。ウィークシンボルのサポートを -melf のようなコンパイラフラグで制御したい場合はこのマクロを定義する。 

MAKE_DECL_ONE_ONLY

一個の C の文(セミコロン無し)。この文は、decl を、複数の翻訳単位にある余分なコピーはリンカが捨てさるようなパブリックなシンボルとして生成するように、印を付ける。オブジェクトファイル形式がこの仕組みをサポートしている場合、例えば Microsoft Windows の PE/COFF 形式のセクションフラグ COMDAT のような場合で、このサポートにより、例えば別のセクションの置くような、decl に対する変更を必要とする場合は、このマクロを定義する。 

SUPPORTS_ONE_ONLY

一個の C の式。ターゲットが「宣言は一つだけ」(one-only)という考え方をサポートしている場合は、この式を評価すると真になる。

このマクロを定義しない場合は、varasm.c がデフォルトの定義を提供する。MAKE_DECL_ONE_ONLY が定義されていると、デフォルトの定義は 1 になり、定義されていない場合は 0 になる。「一つだけ」式のシンボルサポートをコンパイラフラグで制御したい場合や、宣言を「ひとつだけ」として生成するように印をつけるには、DECL_ONE_ONLY フラグを設定すれば充分な場合は、このマクロを定義する。 

ASM_OUTPUT_EXTERNAL (stream, decl, name)

一個の C の文(セミコロン無し)。標準入出力ストリーム stream に、name という名前の外部シンボルで、このコンパイル単位では参照しているが、定義はされていないものの名前を宣言するために必要なテキストを出力する。decl の値はその宣言のツリーノードである。

何も出力する必要がなければ、このマクロは定義しなくて良い。GNU アセンブラと大部分の Unix のアセンブラはなにも必要としない。 

ASM_OUTPUT_EXTERNAL_LIBCALL (stream, symref)

一個の C の文(セミコロン無し)。stream に、ライブラリ関数名を外部名として宣言するためのアセンブラ疑似命令を出力する。このライブラリ関数名は symref で与えられる。symref は、rtx 型であり、symbol_ref である。
何も出力する必要がなければ、このマクロは定義しなくて良い。GNU アセンブラと大部分の Unix のアセンブラはなにも必要としない。 

ASM_OUTPUT_LABELREF (stream, name)

一個の C の文(セミコロン無し)。標準入出力ストリーム stream に、name という名前に対する参照をアセンブラの構文で出力する。このマクロでは、ほとんどの Berkeley Unix システムの場合のように、対象となるオペレーティングシステムでの習慣であるなら、名前の前に _ を付加しなければならない。このマクロは、assemble_name で使われる。 

ASM_OUTPUT_INTERNAL_LABEL (stream, prefix, num)

一個の C の文。この文は、標準入出力ストリーム stream に、文字列 prefix と番号 num から作られるラベルを出力する。

こうして作られるラベルが、ユーザレベルの関数や変数用に使われるラベルとは明確に区別できるということが、本当に本質的なことである。そうなっていないと、ある種のプログラムでは内部ラベルとの名前の衝突が発生してしまう。

内部ラベルは、オブジェクトファイル中のシンボルテーブルからは除外することが望ましい。多くのアセンブラには、除外すべきラベルについての名前付の規則がある。多くのシステムでは、ラベルの先頭に文字 L が付いていると除外対象になる。読者のシステムではどういう規則になっているかを調べ、それに従うこと。

このマクロの普通の定義は以下の通りである。

fprintf (stream, "L%s%d:\n", prefix, num)

ASM_GENERATE_INTERNAL_LABEL (string, prefix, num)

一個の C の文。この文は、文字列 string に、文字列 prefix と番号 num から作られる名前のラベルを格納する。

この文字列は、後で assemble_name によって出力されたときに、同じ prefix と num を与えたときにASM_OUTPUT_INTERNAL_LABEL が生成するのと同じものを、生成するようにしなければならない。

この文字列が、* で始まっていると、assemble_name は文字列の残りの部分をそのまま出力する。ASM_GENERATE_INTERNAL_LABEL が * をそのように使うと便利なことが多い。文字列が * で始まっていないと、ASM_OUTPUT_LABELREF がこの文字列の出力を行ない、変更を行なう可能性がある。(もちろん、ASM_OUTPUT_LABELREF も、マシン記述の一部であるので、対象となる機種でそれが何をしているかを知っておきべきだ。) 

ASM_FORMAT_PRIVATE_NAME (outvar, name, number)

一個の C の式。この式は、outvar (これは char * 型の変数)に、文字列 name と number から作られ、何か適切な区切り文字を加えた、新たに確保した文字列を代入する。この文字列用のスペースは、alloca で割り当てること。

この文字列は、ASM_OUTPUT_LABELREF の引数として使われ、名前が name である、内部的な静的変数用のアセンブララベルを作り出す。このため、文字列はアセンブラコードとして有効なものにならなければならない。引数 number は、マクロが実行される度に異なる。これにより、異なるスコープにある、似たような名前の内部的な静的変数同士の名前の衝突を防ぐ。

理想的には、この文字列は C の識別子としては有効でないようにして、ユーザ定義のシンボルとの衝突を防ぐようにすべきである。多くのアセンブラはアセンブラシンボルの中に、ピリオドやパーセント記号を入れるのを許している。少なくともそのどちらか一つを、名前と番号の間に入れれば充分であろう。 

ASM_OUTPUT_DEF (stream, name, value)

一個の C の文。標準入出力ストリーム stream に、シンボル name の値が value になるように定義する(同じであると見なす)アセンブラコードを出力する。

SET_ASM_OP が定義されていれば、ほとんどのシステムで正しい、デフォルトの定義が提供される。 

ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL (stream, symbol, high, low)

一個の C の文。標準入出力ストリーム stream に、シンボル symbol の値が、二つのシンボル high と low の差、すなわち high - low に等しくなるように定義する(同じであると見なす)アセンブラコードを出力する。GNU CC はシンボル high と low を既にアセンブラが知っていることを保証するので、この差は一つの定数に解決される。

SET_ASM_OP が定義されていると、デフォルトの定義が提供され、ほとんどのシステムで正しいものになっている。 

ASM_OUTPUT_WEAK_ALIAS (stream, name, value)

一個の C の文。標準入出力ストリーム stream に、ウィークシンボル name の値が、value に等しくなるように定義する(同じであると見なす)アセンブラコードを出力する。
このマクロはターゲットがウィークエイリアスしかサポートしていないときに定義すること。可能なら、代わりに ASM_OUTPUT_DEF を定義すること。 

OBJC_GEN_METHOD_LABEL (buf, is_inst, class_name, cat_name, sel_name)

このマクロを定義すると、Objectvie C のメソッドのデフォルトのアセンブラでの名前を上書きする。
デフォルトの名前は、一意的なメソッド番号の後にクラス名が続いたもの(例えば、_1_Foo)になる。カテゴリ中のメソッドについては、カテゴリ名もアセンブラでの名前に含まれる(例えば、_1_Foo_Bar)。

これらの名前はほとんどのシステムで安全だが、デバッグが困難になる。メソッドのセレクタが名前に入っていないからである。このため、幾つかの特定のシステムでは名前を生成する別の方法を定義している。

buf は char * 型の式であり、名前を格納すべきバッファを指定する。このバッファの長さは、class_name と cat_name、sel_name を足した長さに、さらに 50 文字文の余裕を見込んだものである。

引数 is_inst は、メソッドがインスタンスメソッドかクラスメソッドかを指定する。class_name は、クラス名である。cat_name はカテゴリ名である(メソッドがあるカテゴリに入っていないなら NULLである)。sel_name はセレクタ名である。

アセンブラがクォートした名前を扱えるシステムでは、このマクロを使うことで読みやすい名前を提供することができる。


