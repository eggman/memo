
## GCC と互換性

GCC の第一の目標は、品質の良い、高速なコンパイラを、 GNU システムが動作することをねらいとするクラスのマシン向けに作ることであった。そのクラスのマシンとは、32 ビットマシンで、8ビットを一バイトとするアドレッシングを持ち、汎用レジスタがたくさん持つものである。洗練されているとか、理論的な能力とか簡潔さなどは二の次である。

GCC はターゲット機種についての情報のほとんどを、機種記述から得る。機種記述はその機種の命令毎に代数式を与える。これはターゲットを記述する方法としては非常に明解な方法である。ただし、コンパイラが、この形式で表現するのが困難な情報が必要な時は、筆者は機種記述にその場しのぎのパラメータの定義をためらわずに入れる。移植性の目的はコンパイラについて必要な全作業を少なくすることにあり、それ自身には興味がない。

GCC は機種依存コードは含んでいないが、エンディアン(最上位バイトがワードの中のバイトの最上位アドレスを占めるのか、最下位アドレスを占めるのか) や自動インクリメント・アドレッシングが利用可能かなどの機種パラメータに依存するコードは含んでいる。RTL 生成パスでは、ある特定の種類の構文木に対してコード生成の戦略を複数持つ必要があることが多い。これらの戦略はパラメータの異なる組合せに対して使用可能である。著者は可能な場合全てを取り扱うことせず、共通に現れるものや、著者が出会ったものに絞っている。取り扱っていない組合せに出会ったら、GCC が abort を呼び出すので読者も気が付くだろう。幸いにも、新たな戦略を機種独立な形で追加することができ、その新たな戦略を必要とするターゲット機種にしか影響を及ぼさない。


## GCC の出力に対するインターフェース

GCC は、ターゲットシステム上で通常使われるのと同じ関数呼び出し規約を使うように、通常は構成される。これは、マシン記述マクロの記述によりなされる。

しかし、構造体と共用体の返し方は機種によって異なることがある。その結果、PCC でコンパイルしたそのような型を返す関数をGCC でコンパイルした関数から呼び出せないことがあるし、その逆もある。これはあまり問題にはならない。Unix のライブラリルーチンで構造体や共用体を返すものは滅多にないからである。

GCC は、1、2、4、8 バイト長の構造体と共用体は、int や double の戻り値に使うのと同じレジスタに入れて返す。(GCC は普通はそのような型の変数もレジスタに割り当てる。) それ以外の大きさの構造体と共用体は、呼び出し側によって渡されるアドレス(通常、レジスタで渡される)に格納することで返される。マシン記述マクロの STRUCT_VALUE と STRUCT_INCOMING_VALUE により、GCC に、このアドレスをどこに渡すかを指定する。

対照的に、多くのターゲット機種上の PCC は、どの大きさの構造体と共用体でも静的な領域にデータをコピーし、その領域のアドレスをポインタ値であるかのように返すことで、返す。呼び出し側は、そのメモリ領域からその値が必要とされる場所にデータをコピーしなければならない。この方法は、GCC の方法よりも遅く、また再入可能でない。

ターゲット機種によっては、RISC マシンや 80386 のように、システム標準の規約が、サブルーチンに、戻り値を置くアドレスを渡すようになっている。こういう機種では、この方法が使われている場合は、GCC は標準のコンパイラと互換になるようにコンフィギュレーションされる。1,2,4,8バイトの構造体については互換でない可能性がある。

GCC は、引数渡しについてはシステム標準の規約を使う。機種によっては、最初の幾つかの引数はレジスタで渡し、その他は全てスタックで渡される。どの機種でも引数を渡すのにレジスタを使うようにすることができる。それにより、おそらく、非常に速度が速くなるだろう。だが、その結果、標準の規約に従っているコードとの互換性が全く無くなってしまう。このため、この変更は GCC をシステムに取っての唯一の C コンパイラとして切り替えた場合にのみ意味がある。完全な GNU システムができた暁には、ある種の機種ではレジスタによる引数渡しを実装し、ライブラリを GCC でコンパイルできるようにする予定である。

機種によっては(特に SPARC)、特定の型の引数は「不可視の参照」により渡される。これは、渡すべき値がメモリに置かれ、そのメモリ位置のアドレスがサブルーチンに渡されることを意味する。

longjmp を使う場合には、自動変数に注意しなければならない。ANSI C によれば、volatile 宣言されていない自動変数の値は、longjmp 呼び出しの後、未定義になる。そしてこれは GCC が行なうと約束する全てでもある。なぜなら、レジスタ変数を正しくリストアするのは非常に困難であり、GCC の目玉の一つが、特に指定しなくても、変数をレジスタに置くことができる点にあるからである。

変数の値を longjmp によって変えられたくないが、古い C コンパイラが受け付けないので volatile も使いたくないという場合は、単にその変数のアドレスを取れば良い。変数のアドレスが一度でも取られると、それがアドレスの値を単に計算するだけでその値を使わなくても、その変数はレジスタに置かれなくなる。

```
{
  int careful;
  &careful;
  ...
}
```

GCC でコンパイルしたコードは、特定のライブラリルーチンを呼び出す可能性がある。その大部分は、算術演算を行なう命令がない場合に、代わりに算術演算を取り扱う。これは、ある機種では乗算と除算が含まれ、また、任意の機種で浮動小数点サポートが -msoft-float により無効になっている場合の浮動小数点演算が含まれる。C 標準ライブラリの一部、例えば bcopy や memcpy 等もまた、自動的に呼び出される。通常の関数呼びだし方法が、これらのライブラリルーチン呼び出しに使われる。

これらのライブラリルーチンはライブラリ libgcc.a で定義されるべきであり、GCC はプログラムをリンクするときに自動的にこれを探す。乗算命令と除算命令のある機種では、ハードウェア浮動小数点が使われていれば、普通は libgcc.a は必要ないが、その場合でも検索される。

各算術演算関数は libgcc1.c で定義されており、対応するC の算術演算子を使っている。このファイルが何か別の C コンパイラでコンパイルする限り、そのコンパイラは全ての C の算術演算子をサポートしているので、このファイルは正しく動作するはずである。だが、GCC でコンパイルすると libgcc1.c は動作しない。なぜなら、各算術関数がそれ自身への呼び出しにコンパイルされてしまうからである。

##コンパイラの各パスとソースファイル

コンパイラ全体の制御構造は、toplev.c に記述されている。このファイルは、初期化、引数の解析、ファイルのオープン／クローズ、各パスの順次実行を受け持つ。

構文解析パスは一度だけ起動され、入力全体を構文解析する。関数が文単位で構文解析されるにつれ、その関数に対する RTL 中間コードが、生成される。各文は、構文木として読み込まれ、その後 RTL に変換される。その後、その文の構文木用のメモリ領域が再利用される。型(とその大きさを表す式)、宣言、結合の概略と何重に入れ子になっているかの表現は、関数のコンパイルが完了するまで残っている。これは、全てデバッグ情報を出力するのに必要である。

構文解析パスが、完全な関数定義か最上位の宣言を読み込む度に、関数 rest_of_compilation か rest_of_decl_compilation を呼び出す。これらの関数は toplev.c にあり、アセンブラ言語の出力で終わる、以後必要な全ての処理に責任がある。コンパイラの他の全てのパスは、順番に、rest_of_compilation の中で実行される。この関数がある関数定義をコンパイルする処理から戻ると、その関数定義のコンパイルに使われた記憶領域はインライン関数でない限り完全に解放される(see An Inline Function is As Fast As a Macro)。

以下にコンパイラの全パスとそのソースファイルの一覧を示す。また、-d で始まるオプションで要求されるデバッグダンプについての解説も含めた。

###構文解析

このパスは、一個の関数定義の全テキストを読み込み、部分的な構文木を構成する。このパスと RTL 生成パスはもはや実際には別々のパスではない(以前は別々であった)が、独立したパスと考えると考えやすい。
木表現は完全には C の文法にしたがっていない。他の言語も同様にサポートすることを意図しているからである。

言語固有のデータ型解析もこのパスで行なわれ、式を表現するあらゆる木ノードには、あるデータ型が付いている。変数は宣言ノードとして表現される。

定数フォールディングといくつかの演算の単純化もこのパスで行なわれる。

言語独立のパース部のソースファイルは、stor-layout.c、fold-const.c、tree.c である。また、tree.h と tree.def というヘッダファイルで、木構造の表現形式で定義している。

C 言語のパース部のソースファイルは、c-parse.in、c-decl.c、c-typeck.c、c-aux-info.c、c-convert.c、c-lang.c であり、関連するヘッダファイルはc-lex.h と c-tree.h である。

C++ 言語のパース部のソースファイルは、cp-parse.y、cp-class.c、
cp-cvt.c、cp-decl.c、cp-decl2.c、cp-dem.c、cp-except.c、
cp-expr.c、cp-init.c、cp-lex.c、cp-method.c、cp-ptree.c、
cp-search.c、cp-tree.c、cp-type2.c、cp-typeck.c、であり、関連するヘッダファイルは cp-tree.def、cp-tree.h、cp-decl.h である。

Objective C をパースする特別なソースファイルは、objc-parse.y、objc-actions.c、objc-tree.def、それにobjc-actions.hである。C 言語固有のファイルの幾つかも使われる。

ファイル c-common.c は、上記の全ての言語で使われる。

###RTL 生成

構文木を RTL コードに変換する。実際には構文解析のパスで一文毎に変換されるのだが、別のパスとして考えておくと色々便利である。

この部分には、ターゲットのパラメータに依存するコードが大量にある。これは、ある種の標準的な命令が利用可能な場合にのみ適用する必要がある戦略が多いためである。名前付き命令パターンの目的は、この情報を RTL 生成パスに提供することにある。

このパスでは、比較や真偽値演算、三項演算子式である if 節の条件に対する最適化が行なわれる。末尾再帰もこのときに検出される。ループをどのように編成するのが最適か、それに switch 文をどのように出力するかの決定が行なわれる。

RTL 生成に関係するソースファイルは、stmt.c、calls.c、expr.c、explow.c、expmed.c、function.c、optabs.c、emit-rtl.c である。また、ファイル insn-emit.c が、genemit プログラムによりマシン記述から生成され、このパスで使われる。ヘッダファイル expr.h がこのパス内の通信に使われる。

ヘッダファイル insn-flags.h と insn-codes.h は、マシン記述から genflags プログラムと gencodes プログラムにより生成される。これらのファイルにより、このパスで利用可能な標準パターン名とそれに対応するパターンが分かる。

デバッグ情報の出力を別として、これ以降のパスでは関数の木構造表現(これは部分的にしかセーブされない)を参照しない。

後続の呼び出しにおいて、関数がインライン展開可能か、そしてインライ展開すべきかは、RTL 生成の終了時に決定される。インライン展開される関数は幾つかの規準を満たさなければならない。この規準は現在は、関数の大きさと仮引数の型と数に関係する。これを満たす関数は、ループや自分自身の再帰呼び出し(末尾再帰関数もインライン展開可能!)、goto 等、つまるところ、GCC がサポートしている全ての構文を含んでいて良いことに注意して欲しい。ファイル integrate.c には、後のインライン展開に備えて関数の RTL をセーブし、その関数が呼び出されたときにその RTL をインライン展開するコードが含まれている。ヘッダファイル integrate.h もまたこの目的に使われる。

-dr オプションを指定すると、このパス後の RTL コードのデバッグ出力が行なわれる。デバッグ出力のファイル名は入力ファイル名に .rtl を付けたものになる。

###ジャンプ最適化

このパスでは、ジャンプを越えるジャンプ、ジャンプへのジャンプといった命令へのジャンプを単純化する。未参照のラベルと到達不能コードを削除する。ただし、このパスでは到達不能と認識されないループを含む到達不能コードは削除されない。(そのようなループは、後の基本ブロック解析で削除される。) また、もともとはジャンプで書かれていたコードを、比較の結果から直接値を設定する命令の列に変換する。これは、その機種がそのような命令を持っている場合に行われる。

ジャンプ最適化は二回か三回実行される。最初は、RTL 生成の直後である。二回目は、CSE の後だが、ただし CSE がジャンプ最適化を繰り返す必要があると判断した場合だけである。最後は、最終パスの直前に行なわれる。このとき、クロスジャンプと no-op 移動命令の削除が、上記の最適化と合わせて行なわれる。

このパスのソースファイルは jump.c である。

-dj オプションを指定すると、このパス後の RTL コードのデバッグ出力が行なわれる。デバッグ出力のファイル名は入力ファイル名に .jump を付けたものになる。

###レジスタ走査
このパスでは、各レジスタの最初と最後に使われているところを探し、共通部分式削除の指針とする。ソースは regclass.c である。

###ジャンプの一本化
このパスは、全く同一の、あるいはその逆のテストへ分岐する条件ジャンプを検出する。このようなジャンプは、二番目の条件のテストに「一本化」できる。このパスのソースコードは jump.c である。この最適化は、-fthread-jumps が有効になっているときだけ実行される。

###共通部分式削除
このパスでは、定数伝搬も行なう。この部分のソースファイルは、cse.c である。定数伝搬により、条件ジャンプが無条件ジャンプまたは NOP に変わる場合は、ジャンプ最適化が CSE が終わった後に再度実行される。

-ds オプションを指定すると、このパス後の RTL コードのデバッグ出力が行なわれる。デバッグ出力のファイル名は入力ファイル名に .cse を付けたものになる。

###グローバル共通部分式削除
このパスは、Morel-Renvoise の部分冗長性削除を使って GCSE を行う。ただし、ループ不変の移動は行わない。これはループ最適化パスに任せている。このパスは、グローバル定数とコピーの伝播も行う。

このパスのソースファイルは gcse.c である。

-dG オプションを指定すると、このパス後の RTL コードのデバッグ出力が行われる。デバッグ出力のファイル名は入力ファイル名に .gcse を付けたものになる。

###ループ最適化
定数式をループの外側に移動し、強度削減やループ展開も必要に応じて行なう。関連するソースファイルは、loop.c と unroll.c であり、それに加えてヘッダファイル loop.h が情報交換用に使われる。

コマンド行オプション -dL を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.loop を付けたものである。

-frerun-cse-after-loop オプションが指定されていると、二回目の共通部分式の削除がループ最適化の後に行なわれる。指定されていれば、ジャンプ最適化ももう一度行なわれる。

コマンド行オプション -dt を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.cse2 を付けたものである。

最適化を行なわないコンパイルの場合は、ここで単純レジスタ割当が行なわれる。また、ちょっとしたデータ流解析も行なう。単純レジスタ割当が使われる場合は、次に実行されるパスはリロードパスである。この二つのパスの間にある他のパスは飛ばされる。

###データフロー解析
このパスではプログラムを基本ブロックに分解し(その処理中に到達不能なループを削除する)、どの疑似レジスタがプログラムの各点で生きているかを計算し、ある値を最初に使う命令がその値を計算した命令を指すようにする。

このパスでは、また、決して使われることのない結果を出す計算を削除し、メモリ参照を加算または減算命令と組み合わせて、自動インクリメントあるいは自動デクリメントのアドレッシングを作り出す。

コマンド行オプション -df を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.flow を付けたものである。単純な(stupid)レジスタ割当が使われているなら、このダンプファイルは、その割当に関する全ての結果も含める。

###命令組合せ
(combine.c)。このパスでは、データフローにより関係付けられた二、または三個の命令から成るグループを組み合わせて、一つの命令にすることを試みる。命令に対する RTL 式を置き換えることで組合せ、その結果を代数を使って簡素化し、最後にその結果をマシン記述と照合することを試みる。

コマンド行オプション -dc を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.combine を付けたものである。

###レジスタ移動
(regmove.c)。このパスは、照合制約により、強制的に命令が再ロードを必要とするようにし、その再ロードがレジスタからレジスタへの移動になるような場合を探す。次に、その命令が使用するレジスタを変更して、移動命令を回避することを試みる。

コマンド行オプション -dN を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.regmove を付けたものである。

###命令スケジューリング
(sched.c)。このパスでは、後続の命令が使用する時点でその出力が利用可能にならない命令を捜し出す。(RISC 機種では、メモリのロードと浮動小数点命令がこの動作をすることが多い)。基本ブロック内で命令の順序を変えて、定義とその使用を分離して、パイプラインのストールを避けるようにする。

命令スケジューリングは二回行なわれる。一回目は命令組合せの直後で、二回目はリロードの直後である。

コマンド行オプション -dS を指定すると、このパス終了後の RTL コードのデバッグダンプを出力する。ダンプのファイル名は、入力ファイル名に.sched を付けたものである。

###レジスタクラスの選択
RTL コードが操作され、各疑似レジスタに最適なレジスタクラスを見つける。関連ソースファイルは regclass.c である。

###居所レジスタ割り当て
(local-alloc.c)。このパスでは、基本ブロック内でのみ使用されている疑似レジスタにハードレジスタを割り当てる。基本ブロックは線形なので、高速で強力な技術を使って非常に良い仕事をすることが可能である。

オプション -dl を指定すると、このパスを終了した後のRTL コードのデバッグダンプを行なう。出力されるダンプファイル名は、入力ファイル名に .lreg を付けたものになる。

###大局的なレジスタ割当(global.c)。
このパスは、残る疑似レジスタ(ライフスパンが基本ブロックに収まらないもの)に対しハードレジスタを割り当てる。

###再ロード
このパスは、疑似レジスタの番号を、割り当てられたハードウェアレジスタ番号に付け替える。ハードレジスタが割り当てられなかった疑似レジスタはスタックスロットに置き換えられる。その後、値が最終的にレジスタに入らなかったり、正しくない種類のレジスタに入ったりしたために、不正になった命令を探す。こういう不正な命令を、問題となる値を一時的にレジスタに再ロードすることで修正を行なう。そのために必要になるコピーを行なう命令が追加で生成される。

再ロードパスでは、オプションで、フレームポインタの削除と、呼出しの前後で呼出し時破壊レジスタのセーブ／リストアを行なう命令の挿入も行なう。

関係するソースファイルは reload.c と reload1.c で、さらに、この両者の通信用にヘッダファイル reload.h が使われる。

-dg オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .greg を付けたものになる。

###2回目の命令スケジューリング
命令スケジューリングがここで繰り返され、溢れた疑似レジスタ用に生成されるメモリロードによるパイプラインのストールを回避することを試みる。

-dR オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .sched2 を付けたものになる。

###２回目のジャンプ最適化
ジャンプ最適化が繰り返される。今度は、交差ジャンプと、なんの効果もない移動命令の削除が含まれる。

-dJ オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .jump2 を付けたものになる。

###遅延分岐スケジューリング
これはオプションのパスであり、普通はジャンプやコール命令等の他の命令の遅延スロットに入りうる命令を探す。ソースファイル名は、reorg.c である。

-dd オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .dbr を付けたものになる。

###レジスタ変換
幾つかのハードレジスタの使用方法からレジスタ使用方法への変換がこの時点で行われる。現在、これは Intel 80387 コプロセッサの浮動小数点レジスタにたいしてだけサポートされている。ソースファイル名は reg-stack.c である。

-dk オプションを指定すると、このパス後の RTL コードのデバッグ出力を行なう。デバッグ出力ファイル名は、入力ファイル名に .stack を付けたものになる。

###最終パス
このパスでは、関数に対するアセンブラコードを出力する。このパスには、見せかけのテスト命令や比較命令を特定する責任もある。機種固有の覗き穴最適化も同時に行なわれる。関数の入り口点と終了点コードもこのパスで直接アセンブラコードで生成される。入り口点と終了点コードが、RTL として存在することはありえない。

関連ソースファイルは、final.c と insn-output.c である。後者は、マシン記述から genoutput プログラムにより自動的に生成される。ヘッダファイル conditions.h を使って、この二つのファイルの間で情報交換を行なう。

###デバッグ情報出力
これは最終パスの後に行なわれる。何故なら、ハードレジスタに割り当てられなかった疑似レジスタに対するスタックスロットのオフセットを出力しなければならないからである。

### その他
さらに幾つかのファイルが、全ての、あるいは多くのパスで使われる。

どのパスも、マシンモードを定義する、machmode.def と machmode.h を使用する。

多くのパスで real.h を使用する。このファイルは、浮動小数点定数のデフォルトの表現とそれらの操作方法を定義する。

RTL を使う全てのパスで、ヘッダファイル rtl.h と rtl.def、それに rtl.c 中のサブルーチンを使う。gen* のツール群もこれらのファイルを使って、マシン記述 RTL を読んで処理を行なう。

多くのパスで、ヘッダファイル insn-config.h を参照している。このファイルは、マシン記述 RTL から genconfig により自動的に生成されるパラメータ(C のマクロ定義)を数個含んでいる。

多くのパスが命令認識器を使用する。命令認識器は recog.c とrecog.h、それに、マシン記述から genrecog と genextract というツールにより生成されるファイル insn-recog.c とinsn-extract.c から成る。

多くのパスで、ヘッダファイル regs.h と basic-block.h を使っている。regs.h は、疑似レジスタの使用状況について記録される情報を定義している。basic-block.h は基本ブロックについて記録される情報を定義している。

hard-reg-set.h は、HARD_REG_SET 型とこれを取り扱うマクロをいくつかを定義している。HARD_REG_SET 型は、各ハードレジスタにつき 1 ビットのビットベクトルである。この型は、ハードレジスタ数が充分少なければ、単なる int になる。多い場合は、int の配列になり、マクロのうち幾つかはループに展開される。

多くのパスで命令属性を使っている。特定の機種用に定義される属性の定義は、ファイル insn-attr.h にある。このファイルは、マシン記述から genattr プログラムにより生成される。ファイル insn-attrtab.c には、insn の属性値を得るためのサブルーチンが含まれている。このファイルは、マシン記述からプログラム genattrtab により生成される。


##RTL表現
GCC の仕事の大半は、レジスタ転送言語(RTL)と呼ばれる中間表現に対してなされる。このレジスタ転送言語では、出力すべき命令を一つづつ、その命令が行う操作を代数的な形式で記述する。

RTL は、Lisp 言語のリストにヒントを得たものである。RTL は、他の構造体を指す構造体からなる内部形式と、マシン記述とデバッグ用ダンプ出力で用いられるテキスト形式の二種類の形式を持つ。テキスト形式では、内部形式でのポインタを示すのに多重の括弧を使う。

* RTL Objects: 式、ベクトル、文字列、整数
* RTL Classes: RTL 式オブジェクトのカテゴリとその構造
* Accessors: 式オペランドやベクトルの要素へのアクセスマクロ群
* Flags: RTL 式中のフラグ
* Machine Modes: データの大きさと形式の記述
* Constants: 定数値を持つ式
* Regs and Memory: レジスタの内容やメモリを表現する式
* Arithmetic: 算術演算を表す式
* Comparisons: 比較演算式を表す式
* Bit Fields: メモリまたはレジスタ中のビットフィールドを表す式
* Conversions: 拡張、打切、浮動小数点／固定小数点への変換
* RTL Declarations: RTL 宣言
* Side Effects: 副作用のある式
* Incdec: 自動インクリメントアドレッシングに含まれる副作用
* Assembler: オペランドを伴う asm の表現
* Insns: insn 全体の式タイプ
* Calls: 関数呼び出し insn の RTL 表現
* Sharing: 式の共有
* Reading RTL: ファイルからのRTLテキスト形式の読み込み 

##RTL オブジェクト型
RTL は5種類のオブジェクトを使う。式、整数、幅広整数、文字列、ベクトルである。式が最も重要である。ある RTL 式(省略形は"RTX") は、C 言語の構造体だが、普通はポインタで参照される。RTL 式の型は typedef 名rtx で与えられる。

整数は、単に int である。10進数を使って表記する。幅広整数は、整数型のオブジェクトのうちで、その型が HOST_WIDE_INT のものである(see Config)。やはり、10進数を使って表記する。

文字列は文字の連なりである。メモリ中では、通常の C 言語の形式である、char * で表現され、C 言語と同じ文法にしたがって表記する。ただし、RTL での文字列は決してヌルにはならない。マシン記述中で空文字列を書いた場合、メモリ中ではヌルポインタではなく、ヌル文字へのポインタとして表現される。文脈によっては、文字列の代わりにヌルポインタを使っても有効である。RTL のコード内では、文字列は symbol_ref 式の中で最も良く使われる。しかし、マシン記述を構成する RTL 式の他の文脈にも現れる。

ベクトルは、式を指す任意個数のポインタから成る。ベクトルの要素数はベクトルの中で明示的に表現される。ベクトルは、空白で区切られた要素を順番に並べたものを、鍵括弧([...])で囲んで表記する。長さ 0 のベクトルは作成されない。代わりにヌルポインタが使われる。

式は式コード(または RTX コードと呼ばれる) で分類される。式コードは rtl.def で定義される名前であり、大文字で記述したC の列挙型定数でもある。許される式コードとその意味は機種には依存しない。ある RTX のコードはマクロ GET_CODE (x) によって取り出すことができ、また、マクロ PUT_CODE (x, newcode) で変更することができる。

式コードは、式の中にオペランドが幾つあるか、およびオペランドがどんな種類のオブジェクトかを決定する。Lisp と違って RTL では、オペランドを見てもどんな種類のオブジェクトか知ることはできない。代わりに、文脈から知る必要がある。つまり、オペランドを含む式の式コードから知る必要がある。例えば、式コードが subreg である式の中では、最初のオペランドが式と見なされ、二番目のオペランドが整数とみなされる。式コード plus の式では、二つのオペランドがあり、どちらも式としてみなされる。式コード symbol_ref の式では、オペランドは一つであり、文字列としてみなされる。

式は、式のタイプ名と、そのフラグとあればマシンモード、式のオペランドを空白で区切り、括弧で囲んで表記する。

式コード名は、md ファイル中では小文字で書くが、C のコードとしては大文字となって現れる。このマニュアルでは、const_int のように書くことにする。

通常、式が要求される場合でも、ヌルポインタが有効なコンテキストが二、三存在する。その場合には、(nil) と表記する。

##RTL クラスとフォーマット
様々な式コードは幾つかのクラスに分類される。そのクラスは一文字で表現される。ある RTX コードのクラスは、マクロGET_RTX_CLASS (code) を使って知ることができる。現在、rtx.def では以下のクラスを定義している。

o 実際のオブジェクト、例えば、レジスタ(REG)やメモリ位置(MEM、SYMBOL_REF)等の実際のオブジェクトを表すRTX コードである。定数やオブジェクトに基本的な変換を施したもの(ADDRESSOF、HIGH、LO_SUM)も含まれる。SUBREG や STRICT_LOW_PART はこのクラスには含まれず、クラス x に含まれることに注意。 

< NE や LT 等の比較用の RTX コードである。 

1 NEG や NOT、ABS 等の単項算術演算用のRTX コードである。このカテゴリには、値の拡張(符号付きも符号無しも)や整数と浮動小数点の間の変換も含まれる。 

c PLUS や AND 等の交換可能な二項演算の RTX コードである。NE と EQ は比較なので、< クラスになる。 

2 MINUS や DIV、ASHIFTRT 等の交換可能でない二項演算の RTX コードである。 

b ビットフィールド演算の RTX コードである。現時点では、ZERO_EXTRACT と SIGN_EXTRACT だけである。これらは入力が三つあり、左辺値である(そのため、挿入にも同じように使える)。See Bit Fields。 

3 その他の3入力演算の RTX コードである。現時点では、IF_THEN_ELSE のみでる。 

i 命令全体を表す RTX コードである。INSN、JUMP_INSN、CALL_INSN がある。See Insns。 

m MATCH_DUP 等の、insn にマッチする何かを表す RTX コードである。マシン記述にのみ現れる。 

x その他の全ての RTX コードである。このカテゴリには、マシン記述でしか使われない(DEFINE_* 等)残りのコードが含まれる。副作用を記述する全てのコードと insn の連鎖に現れる、NOTE、BARRIER、CODE_LABEL 等の非 insn が含まれる。

rtl.def には、式のタイプ毎に、その式が含むオブジェクトの数とその種類が記述されている。オブジェクトの種類の書き方としては次の四つ(五つのtypo?)がある。式(実際には式へのポインタ)の場合は e、整数は i、幅広整数は w、文字列は s、式のベクトルはE と書く。式コードを表す文字の連なりを フォーマットと呼ぶ。例えば、subreg のフォーマットは ei となる。

その他に以下のフォーマット指定文字が使われる。


u u は、デバッグ用ダンプで異なった表示がなされる以外はe に同じである。insn へのポインタで使われる。 

n n は、デバッグ用ダンプで異なった表示がなされる以外は i に同じである。note insn で行番号やコード番号のために使われる。 

S S は省略可能な文字列を示す。メモリ中での RTL オブジェクトでは、S は s に同じであるが、md ファイルからオブジェクトを読み込む場合には、このオペランドの文字列値は省かれる。省かれた文字列はヌル文字列であるとして扱われる。 

V V は省略可能なベクトルを示す。メモリ中での RTL オブジェクトでは、V は E に同じであるが、md ファイルからオブジェクトを読み込む場合には、このオペランドのベクトル値は省かれる。省かれたベクトルは、実質的には要素が一つもないベクトルと同じである。 

0 0 は、通常のカテゴリには収まらないものを入れるためのスロットであることを意味する。0 のスロットは、どのダンプにも表示されず、gcc の極く一部で特別な使われ方をする。

以下は、オペランド数、式コードのフォーマットを得るためのマクロである。

GET_RTX_LENGTH (code)
コードが code である RTX のオペランド数。 

GET_RTX_FORMAT (code)
コードが code である RTX のフォーマットを C の文字列で表したもの。

RTX コードの幾つかのクラスは常に同じフォーマットである。例えば、全ての比較演算のフォーマットは ee であると想定しても安全である。


1 このクラスのコードのフォーマットは全て e である。 

< c 2 このクラスのコードのフォーマットは全て ee である。 

b 3 このクラスのコードのフォーマットは全て eee である。 

i このクラスのコードのフォーマットは全て iuueiee で始まる。ある insn の連鎖にリンクされた RTL オブジェクトのクラスが全てi ではないことに注意。 

o m x これらのコードのフォーマットについては何ら想定を置くことはできない。

##オペランドへのアクセス
式中のオペランドは、XEXP や XINT、XWINT、それにXSTR というマクロを使って参照することができる。これらのマクロはそれぞれ引数を二つ取る。RTL式のポインタ(RTX) とオペランドの番号である。オペランドの番号は 0 からはじまる。例えば、

```
XEXP (x, 2)
```
とあれば、式 x の二番目のオペランドを式として参照する。

```
XINT (x, 2)
```
こちらは、同じオペランドを整数として参照する。同様に、XSTR を使うと文字列として参照する。

どんなオペランドも整数として、あるいは式として、また文字列として参照できる。ユーザは、オペランドに実際貯えられている値の種類に応じて、正しい参照方法を選ばなければならない。これは、オペランドを含んでいる式の式コードを見て判断するのが良い。また、オペランド数を調べるのも式コードで調べることができる。

例えば、x が subreg 式なら、オペランドは二つあり、それぞれ XEXP (x, 0) と XINT (x, 0) として正しく参照できる。XINT (x, 0) とすると、オペランド 0 の式のアドレスを整数にキャストしたものが得られる。こういう参照の仕方が有効な場合は滅多にないと思うが、もし書くなら(int) XEXP (x, 0) としたほうがきれいである。また XEXP (x, 1) という書き方もエラー無しでコンパイルできて、二番目の整数オペランドを式のポインタにキャストした結果を返す。しかし、それを参照したときに恐らくプログラムが落ちてしまう。さらには、XEXP (x, 28) のように書くこともできるが、式の終りを越えたメモリをアクセスし、予期できない結果に終わるだろう。

オペランドがベクトルの場合の参照方法はもっと複雑である。マクロ XVEC を使うとベクトルへのポインタそのものが得られ、XVECEXP と XVECLEN を使うとそれぞれ、ベクトルの要素と長さを得ることができる。

```
XVEC (exp, idx)
```
式 exp の idx 番目のオペランドをベクトルへのポインタとして参照する。 

```
XVECLEN (exp, idx)
```
式 exp の idx 番目のオペランドであるベクトルの長さを返す。この値は int 型である。 

```
XVECEXP (exp, idx, eltnum)
```
式 exp の idx 番目のオペランドであるベクトルの eltnum 番目の要素を参照する。この値は RTX である。

eltnum が負でないことおよび XVECLEN (exp, idx) より小さいことを保証するのはユーザの責任である。

このセクションで定義したマクロは全て左辺値として展開されるので、単に参照するだけでなく、オペランドや長さやベクトルの要素を代入することができる。

##RTL 式中のフラグ

RTL 式は、ある種の型の式で使われる色々なフラグ(一ビットのビットフィールド)とその他の値を含んでいる。ほとんどの場合、フラグは以下のマクロで参照される。


MEM_VOLATILE_P (x)
mem 式において、揮発性のメモリ参照の場合に非 0 となる。volatil フィールドに格納され、/v と出力される。 

MEM_IN_STRUCT_P (x)
mem 式において、構造体や共用体、配列全体かそれらの成分を参照するときに非0となる。スカラ変数への、あるいはポインタを通してのスカラ変数への参照の場合は 0 となる。in_struct フィールドに格納され、/s と出力される。このフラグと MEM_SCALAR_P がどちらもクリアされていると、この MEM が構造体の中にあるのかどうかがわからない。両方のフラグが同時に設定されることがあってはならない。 

MEM_SCALAR_P (x)
mem 式において、構造体や共用体、配列のメンバでないことが知られているスカラに対する参照の場合はゼロでない値となる。構造体や共用体、配列のメンバに対する参照や、ポインタを経由しての間接参照に対しては、たとえそのポインタがスカラ型を指していてもゼロとなる。このフラグと MEM_STRUCT_P が両方ともクリアされていると、この MEM が構造体の中にあるのかどうか分からない。両方のフラグを同時にセットしてはならない。 

MEM_ALIAS_SET (x)
mem 式において、x が属する別名のセットを表す。これがゼロであれば、x どの別名のセットにも入っておらず、任意のものの別名になりうる。ゼロでない場合は、x は、同じ別名セットに入っているオブジェとの別名にしかならない。この値は、言語フロントエンドにより(言語固有の方法で)設定される。このフィールドはビットフィールドではない。整数であり、mem の第二引数に現れるものである。 

REG_LOOP_TEST_P
reg 式において、レジスタの生存期間がループの脱出条件のテストに含まれるなら、非0となる。in_struct フィールドに格納され、/s と出力される。 

REG_USERVAR_P (x)
reg 式において、ユーザのソースコード中に存在する変数に対応するなら非0となる。コンパイラ内部で一時的に生成されたものなら0となる。volatil フィールドに格納され、/v と出力される。 

REG_FUNCTION_VALUE_P (x)
reg 式において、このレジスタに現在の関数の戻り値が置かれるなら非 0 である。(これは物理レジスタの場合にのみ発生する。) integrated フィールドに格納され、/i と出力される。
同じ物理レジスタが現在の関数が呼び出した関数の戻り値を置くのに使われても良いが、そういう使い方の場合には REG_FUNCTION_VALUE_P は 0 である。 

SUBREG_PROMOTED_VAR_P
subreg 式において、それが、マシン記述マクロ PROMOTED_MODE (see Storage Layout)に従って、より幅の広いモードに拡張されたオブジェクトを参照した際に作られたものなら、非ゼロである。この場合、subreg のモードはそのオブジェクトの宣言されたモードであり、SUBREG_REG のモードはそのオブジェクトを保持するレジスタのモードである。拡張された変数は、それぞれの代入の際に、常に、より幅の広いモードへ符号拡張またゼロ拡張される。in_struct フィールドに格納され、/s として出力される。 

SUBREG_PROMOTED_UNSIGNED_P
SUBREG_PROMOTED_VAR_P が、参照されているオブジェクトがゼロ拡張され続ける場合はゼロでなく、符号拡張され続ける場合はゼロとなるような、subreg の中では、非ゼロである。unchanging フィールドに格納され、/u と出力される。 

RTX_UNCHANGING_P (x)
reg または mem では、その値が変化しないのであれば、非 0 である。(このフラグは、ポインタを経由しての定数へのメモリ参照では設定されない。そういうポインタは、現在の関数ではオブジェクトは明示的には変化しないということを保証するだけである。オブジェクトは、他の関数やエイリアシングにより変化し得るのである。) unchanging フィールドに格納され、/u と出力される。 

RTX_INTEGRATED_P (insn)
インライン関数呼び出しの結果生じる insn 中では非 0 である。integrated フィールドに格納され、/i と出力される。 
RTX_FRAME_RELATED_P (x)
一個の insn また式で、関数プロローグの一部であり、かつ、スタックポインタを設定しているか、フレームポインタを設定しているか、レジスタをセーブしているものの中であれば、ゼロでない値となる。このフラグは、RTL プロローグを持つターゲットで例外処理をサポートするのに必要となる。 

SYMBOL_REF_USED (x)
symbol_ref 中で、x が使われていることを指示する。通常は、x が external として一度だけ宣言されていることを保証するのに使われるだけである。used フィールドに格納される。 

SYMBOL_REF_FLAG (x)
symbol_ref 中で、機種に固有な目的のためのフラグとして使われる。volatil フィールドに格納され、/v として出力される。 

LABEL_OUTSIDE_LOOP_P
label_ref 式の中で、ラベルへの参照がある場合、そのラベルが、ラベルへの参照を含む最も内側のループの外側にあるなら、非ゼロとなる。in_struct フィールドに格納され、/s として出力される。 

INSN_DELETED_P (insn)
insn の中で、その insn が削除済であれば非 0 である。volatil フィールドに格納され、/v と出力される。 
INSN_ANNULLED_BRANCH_P (insn)
分岐 insn の遅延スロットにある insn の中で、無効化分岐を使うべきかどうかを指示する。以下の sequence の議論を参照のこと。unchanging フィールドに格納され、/u と出力される。 

INSN_FROM_TARGET_P (insn)
分岐命令の遅延スロット中の insn の中で、その insn が分岐命令のターゲットから来たものであることを示す。分岐 insn の INSN_ANNULLED_BRANCH_P ビットが立っていれば、この insn は、分岐が成立したときにのみ実行される。INSN_FROM_TARGET_Pビットが立っていない無効化された分岐命令の場合は、insn は、分岐が成立しなかったときにのみ実行される。INSN_ANNULLED_BRANCH_P が設定されていない場合は、この insn は常に実行される。in_struct フィールドに格納され、/s と出力される。 

CONSTANT_POOL_ADDRESS_P (x)
symbol_ref の中で、現在の関数の「定数プール」の一部を参照しているなら、非ゼロとなる。これらは、関数の先頭に近いアドレスであり、GNU CC は、直接的にアクセスが可能であると仮定する(恐らく、ベースレジスタの助けを借りて)。unchanging フィールドに格納され、/u と出力される。 

CONST_CALL_P (x)
call_insn の中で、insn が定数関数への呼び出しを表しているかどうかを示す。unchanging フィールドに格納され、/u と出力される。 

LABEL_PRESERVE_P (x)
code_label の中で、そのラベルが削除不可であることを示す。非局所的 goto によるラベルの参照でこのビットがセットされる。in_struct フィールドに格納され、/s と出力される。 

SCHED_GROUP_P (insn)
命令スケジューリング中、ある insn において、直前の insn はこの insn と同時にスケジューリングされなければならないことを示す。これを使って、ある命令のグループが命令スケジューリングのパスによって、分割されないことを保証する。例えば、call_insn の直前のuse insn は、call_insn から分離されることはない。in_struct フィールドに格納され、/s として出力される。

以下に、上述のマクロが参照するフィールドを挙げる。

used

通常は、このフラグは、関数の RTL 生成の最後で、ある式が insn の中に何回現れたかを数えるために、一時的に使われるだけである。二回以上現れた式は、共有構造の規則に従ってコピーされる(see Sharing)。

symbol_ref では、そのシンボルに対する外部宣言が既に書き込み済であることを意味する。

reg では、リーフレジスタの番号付け替えのコード部分で、各レジスタの番号付け替えが一回だけ行われることを保証するのに使われる。 

volatil

このフラグは、mem式、symbol_ref式、reg式およびinsn の中で使われる。RTL ダンプファイルでは、/v と表記される。

mem 式の中では、メモリ参照が揮発性(volatile)であれば 1 である。揮発性メモリ参照は、削除や並べかえや結合は出来ない。

symbol_ref 式の中では、機種固有の目的で使われる。

reg 式の中では、その値がユーザレベルの変数であれば、1 である。0 であれば、コンパイラが内部的に使う一時的なものであること示す。

insn の中では、1 であればその insn が既に削除された事を意味する。 

in_struct

mem式の中では、その式が参照するメモリデータが、構造体または配列の全体あるいは一部であれば、1 となる。スカラ変数であれば、0 になる。C 言語のポインタを通しての参照は 0 となる。ポインタはスカラ変数を指すからである。この情報により、GCC が、エイリアシングが起こる場合について何らかの決定を下すことができるようになる。

分岐命令の遅延スロットの insn の中では、1 であれば、この insn が分岐先から来たものであることを意味する。

命令のスケジューリングの間では、insn の中では、1 であれば、この insn は、直前の insn と共に構成するグループの一部としてスケジュールされなければならないことを意味する。

reg 式の中では、その式が示すレジスタの生存範囲が、あるループの条件式の中に完全に収まるのであれば、1 である。

subreg 式の中では、1 であれば、その subreg が、より広いモードから格上げされたモードを持っていたオブジェクトを参照していることを示す。

label_ref 式の中では、1 であれば、参照しているラベルが、その label_ref 式のある insn を含む最も内側のループの外にあることを示す。

code_label 式の中では、そのラベルが削除されることが決してありえないのなら、1 である。これは、非局所的な goto の目的先であるラベルで使われる。

RTL ダンプの中では、このフラグは /s と表記される。 

unchanging

reg 式と mem 式の中では、1 であれば、その式の値が決して変化しないことを意味する。

subreg 式の中では、その subreg 式が、より広いモードへ格上げされたモードを持つ符号無しのオブジェクトを参照しているのであれば、1 である。

insn の中では、1 であれば、無効化付きの分岐であることを意味する。

symbol_ref 式の中では、1 であれば、このシンボルが、関数毎の定数プール中の何かを参照していることを示す。

call_insn の中では、1 であれば、この命令が定数関数への呼び出しであることを意味する。

RTL ダンプ中では、このフラグは /u と表示される。 

integrated

insnを含む、ある種の式の中では、このフラグは、この RTL が手続き統合(procedure integration)により生成されたことを意味する。

reg 式の中では、このフラグは、このレジスタが、現在の関数により返されるはずの値を含んでいることを示す。引数をレジスタで渡す機種では、同じ番号のレジスタが引数としても使われるが、その様に使用される場合にはこのフラグはセットされない。


##マシンモード
マシンモードは、データオブジェクトの大きさ、その表現方法を記述する。C のコード中では、マシンモードは列挙型 enum machine_mode で表現される。この列挙型は、machmode.def で定義されている。各 RTL 式にはマシンモードを格納する場所があり、そのため、ある種のツリー式(正確には、宣言と型である)を格納する場所も持っている。

デバッグダンプとマシン記述のなかでは、RTL 式のマシンモードは、式コードの後ろにコロンで区切って書く。各マシンモード名に付くmodeは、省略される。例えば、(reg:SI 38) は、reg 式で、マシンモードはSImode である。モードが VOIDmode の場合は、モードとしては何も出力されない。

以下にマシンモードの表を示す。以下では、「バイト」とは、BITS_PER_UNIT ビットのオブジェクトを指す(see Storage Layout)。

QImode
「1/4 精度整数」(Quarter-Integer)モードは、整数として扱われる1バイトを表現する。 

HImode
「1/2 精度整数」(Half-Integer)モードは、2バイト整数を表す。 

PSImode
「部分単精度整数」(Partial Single Integer)モードは、4バイトを占有するが、実際に4バイト全てを使うことはないような整数を表す。マシンによっては、これがポインタ用の正しいモードになる。 

SImode
「単精度整数」(Single Integer)モードは、四バイト整数を表す。
 
PDImode
「部分倍精度整数」(Partial Double Integer)モードは、8バイトを占有するが、実際に8バイト全てを使うことはないような整数を表す。マシンによっては、これがある種のポインタ用の正しいモードになる。 

DImode
「倍精度整数」モードは八バイト整数を表す。 

TImode
「4倍精度整数」(Tetra Integer)モードは、16バイト整数を表す。 

SFmode
「単精度浮動小数点数」(Single Floating)モードは、単精度(四バイト)浮動小数点数を表す。 

DFmode
「倍精度浮動小数点数」(Double Floating)モードは、倍精度(八バイト)浮動小数点数を表す。 

XFmode
「拡張精度浮動小数点数」(Extended Floating)モードは、3倍精度(12バイト) 浮動小数点数を表す。このモードは、IEEE 拡張浮動小数点数に使う。システムによっては、12バイトの中には実際に使われないビットがある。 

TFmode
「4倍精度浮動小数点数」(Tetra Floating)モードは、4倍精度(16バイト) 浮動小数点数を表す。 

CCmode
「条件コード」(Condition Code)モードは、条件コードの値を表す。条件コードは、機種に固有のビットの一群で、比較演算の結果を表す。これ以外の機種固有のモードが条件コードに対して使われることもある。これらのモードは、cc0 を使う機種では使われない。(see Condition Code。) 

BLKmode
「ブロック」(Block)モードは、他のどのモードも適用できないような集合体の値を表す。RTL では、メモリへの参照のみがこのモードを取りうる。しかも、それが文字列移動またはベクトル命令中に現れたときだけに限られる。このような命令を持たない機種では、BLKmode が RTL に現れることはない。 

VOIDmode
「ボイド」(Void)モードは、モードがないこと、あるいはモードを指定しないことを意味する。例えば、コードが const_int である RTL 式はVOIDmode になる。何故なら、文脈が要求するどんなモードとしても取ることが出来るからである。RTL のデバッグダンプ中では、VOIDmode は、モードが一切無いことにより表現される。 

SCmode, DCmode, XCmode, TCmode
これらのモードは、浮動小数点数値の対として表現された複素数を表す。浮動小数点数値は、それぞれ、SFmode, DFmode, XFmode, TFmode になる。 

CQImode, CHImode, CSImode, CDImode, CTImode, COImode
これらのモードは、整数値の対として表現された複素数を表す。整数値は、それぞれ、QImode, HImode, SImode, DImode, TImode, OImode である。

マシン記述では、Pmode を C のマクロとして定義し、このマクロはアドレス向けのマシンモードに展開される。普通は、これは BITS_PER_WORD の大きさのモードであり、32ビットのマシンでは SImode になる。

マシン記述に必ず記述が必要なのは、QImode と、それぞれBITS_PER_WORD、FLOAT_TYPE_SIZE、DOUBLE_TYPE_SIZE に対応するモードである。GCC は、8バイトの構造体と共用体に対して DImode を使うことを試みるが、MAX_FIXED_MODE_SIZE の定義を書き換えることにより、抑止することができる。また、16バイトの構造体と共用体向けに TImode を使わせることも可能である。同様に、C の short int 型に、HImode を使うのを避けるように設定することも可能である。

現在では、GCC の中でマシンモードを明示的に参照しているコードはほとんどなく、あっても早々に削除してしまう予定である。その代わり、マシンモードをモードのクラスに分割している。マシンモードのクラスは、列挙型enum mode_class で表される。この列挙型は machmode.h で定義されている。取りうるモードクラスは以下の通りである。

MODE_INT
整数モード。デフォルトでは、QImode, HImode, 
SImode, DImode, TImode が該当する。 

MODE_PARTIAL_INT
「部分整数モード」を表す。PSImode と PDImode が該当する。 

MODE_FLOAT
浮動小数点モード。デフォルトでは、SFmode, DFmode, XFmode, TFmode である。 

MODE_COMPLEX_INT
整数複素数モード。(現時点では実装されていない。) 

MODE_COMPLEX_FLOAT
浮動小数点複素数モード。デフォルトでは、SCmode、DCmode, XCmode, and TCmode である。 

MODE_FUNCTION
静的チェーンを含む、Algol や Pascal の関数変数である。(現時点では実装されていない。) 

MODE_CC
条件コード値を表すモード。これには、CCmode と、EXTRA_CC_MODES マクロに示された全てのモードが含まれる。See Jump Patterns、Condition Code を参照のこと。 

MODE_RANDOM
これは、上記のどのクラスにも当てはまらないモードのための受皿モードである。現時点では、VOIDmode と BLKmode が MODE_RANDOM に該当する。

以下にマシンモード関連の C マクロを示す。

GET_MODE (x)
RTX x のマシンモードを返す。 

PUT_MODE (x, newmode)
RTX x のマシンモードを newmode にする。 

NUM_MACHINE_MODES
ターゲット機種で利用可能なマシンモードの数を表す。これは、マシンモード値のうち最大のものに 1 を足したものになる。 

GET_MODE_NAME (m)
モード m の名前を文字列で返す。 

GET_MODE_CLASS (m)
モード m のモードクラスを返す。 

GET_MODE_WIDER_MODE (m)
指定したモードの次に広い自然なモードを返す。例えば、GET_MODE_WIDER_MODE (QImode) という式は、HImode を返す。 

GET_MODE_SIZE (m)
モード m のデータの大きさをバイト数で返す。 

GET_MODE_BITSIZE (m)
モード m のデータの大きさをビット数で返す。 

GET_MODE_MASK (m)
一語中のビットのうち、モード m の範囲内に収まる全てのビットを表すビットマスクを返す。このマクロは、ビット数が HOST_BITS_PER_INT 以下であるモードに対してのみ使うことができる。 

GET_MODE_ALIGNMENT (m)
モード m のオブジェクトに必要なアラインメントをビット数で返す。 

GET_MODE_UNIT_SIZE (m)
モード m のデータの部分単位の大きさをバイト数で返す。これは、複素数のモードの場合以外は、GET_MODE_SIZE と同じである。複素数のモードの場合は、部分単位の大きさは、実数部また虚数部の大きさである。 

GET_MODE_NUNITS (m)
あるモードに含まれる単位の数を返す。すなわち、GET_MODE_SIZE を GET_MODE_UNIT_SIZE で割ったものを返す。 

GET_CLASS_NARROWEST_MODE (c)
モードクラス c の中で最も幅の狭いモードを返す。

グローバル変数 byte_mode と word_mode は、モードクラスが MODE_INT であり、ビット数がそれぞれ BITS_PER_UNIT と BITS_PER_WORD のモードを保持している。32ビットマシンでは、それぞれ QImode と SImode になる。

##定数式型
最も簡単な RTL 式は、定数値を表すものである。

(const_int i)

この型の式は、整数値 i を表す。i は、マクロ INTVAL を使って INTVAL (exp) のように参照するのが良く行われる。これは、XWINT (exp, 0) と書くのと同じである。

整数値 0 を表す式オブジェクトは唯一つしかなく、変数 const0_rtx の値だけである。同じく、整数値 1 に対する式は、const1_rtx だけであり、整数値 2 に対する式は、const2_rtx だけである。さらに、整数値 -1 に対する式は constm1_rtx だけである。コードが const_int で、値が 0, 1, 2, -1 のどれかの式を作ろうとすると、それぞれ、const0_rtx、const1_rtx、const2_rtx、constm1_rtx が返される。

同様に、値が STORE_FLAG_VALUE である整数に対するオブジェクトは唯一つだけで、const_true_rtx になる。STORE_FLAG_VALUE が1 であれば、const_true_rtx と const1_rtx は同じオブジェクトを指す。STORE_FLAG_VALUE が -1 なら、const_true_rtx とconstm1_rtx は同じオブジェクトを指すことになる。 

(const_double:m addr i0 i1 ...)

モード m の浮動小数点定数か、HOST_BITS_PER_WIDE_INT ビットには収まらないが HOST_BITS_PER_WIDE_INT の二倍のビット数になら収まるような整数定数を表す(GNU CC は、それ以上に大きい定数を表現する機能は提供していない)。後者の場合は、m は VOIDmode になる。

addr は、定数が置かれているメモリ上の位置に対応する mem 式を保持する。メモリ上の位置は確保されていないが、現在のコンパイル(表示されないフィールドを使い維持されている)の全ての const_double 式の連鎖上には存在するなら、addr は const0_rtx を含む。その連鎖に存在しなければ、addr は cc0_rtx を含む。addr は、マクロ CONST_DOUBLE_MEM とCONST_DOUBLE_CHAIN を経由した連鎖フィールドを使ってアクセスするようになっている。

m が VOIDmode なら、値を表すビット群は i0 と i1 に格納される。i0 はマクロ CONST_DOUBLE_LOW で、i1 はCONST_DOUBLE_HIGH で参照するのが通例となっている。

定数が浮動小数点数なら(精度に関わらず)、その値を格納するのに必要な整数の個数は、REAL_VALUE_TYPE に依存する(see Cross-compilation)。その整数群は浮動小数点数を表現するが、厳密にはターゲットマシンまたホストマシンの浮動小数点数形式ではない。ターゲットマシンで使われる正確なビットパターンに変換するには、マクロ REAL_VALUE_TO_TARGET_DOUBLE と関連マクロを使用すること(see Data Output)。

マクロ CONST0_RTX (mode) は、値が 0 でモードが mode の式を参照する。モード mode が、MODE_INT のクラスのモードであれば、const0_rtx を返す。そうでなければ、モード mode のCONST_DOUBLE 式を返す。同様に、マクロ CONST1_RTX (mode) は、値が 1 でモード mode の式を参照する。CONST2_RTX についても同様である。 

(const_string str)

値が str である文字列定数を表す。現時点では、この式は insn の属性(see Insn Attributes)についてのみ使われている。というのは、C 言語の文字列定数はメモリ中に置かれるからである。 

(symbol_ref:mode symbol)

アセンブラのデータに対するラベルの値を表現する。symbol は、アセンブララベル名を記述する文字列である。この文字列が * で始まるなら、ラベル名は、symbol から* を除いたものになる。それ以外の場合は、symbol そのものがラベル名となり、通常は _ というプレフィックスが付く。

symbol_ref にはモードがあり、普通は Pmode になる。普通は、このモードがシンボルに対して直接有効になる唯一のモードである。 

(label_ref label)

コードに対するアセンブラ・ラベルの値を表現する。オペランドは一つであり、それは式となる。この式は、ラベルの置かれるべき位置を特定するための命令列に現れる code_label でなければならない。

コードラベルの参照に異なる式のタイプを使用するのは、ジャンプ最適化で区別できるようにするためである。 

(const:m exp)

アセンブル時の代数計算の結果として生じる定数を表現する。オペランド exp は、定数(const_int、symbol_ref、label_ref 式)に plus と minus を組み合わせたもののみからなる式である。ただし、全ての組合せが有効とは限らない。アセンブラは、再配置可能なシンボルについては勝手な計算は出来ないからである。

m は Pmode でなければならない。 

(high:m exp)

exp、普通は symbol_ref の上位ビット群を表現する。ビット数は機種依存であり、通常はレジスタの上位ビットを初期化する命令で指定されるビット数になる。lo_sum と共に使って、RISC で良く使われる、グローバルなメモリ位置を参照する典型的な二命令の列を表現する。

m は Pmode でなければならない。

###レジスタとメモリ

以下に、レジスタとメモリへのアクセスを記述する、RTL 式のタイプを示す。

(reg:m n)

小さな整数 n (FIRST_PSEUDO_REGISTER より小さい)に対して、マシンのレジスタ番号 n、すなわちハードレジスタの参照であることを意味する。n が大きな値の場合は、一時的な値か 仮想レジスタを表す。GCC の戦略としては、まず、このような仮想レジスタが無限個あると仮定してコード生成を行ない、後で、ハードレジスタかメモリ参照への置き換えを行なう。

m は、この参照のマシンモードである。モードの指定が必要なのは、一般に複数のモードで各レジスタを参照することが可能だからである。例えば、レジスタを一つ取ってみると、そこには全語を入れることができるが、それを半語やバイトとして参照する命令や、色々な精度の浮動小数点数として参照する命令もありうるのである。

レジスタをアクセスするモードが一つしかないマシンの場合でも、モードは常に指定しなければならない。

FIRST_PSEUDO_REGISTER というシンボルはマシン記述により定義される。というのは、あるマシンのハードレジスタの数はそのマシンの不変の特徴だからである。ただ、マシンのレジスタが全て汎用レジスタである必要はない。データの格納に使える全てのマシンレジスタは、ハードレジスタ番号が与えられる。たとえ、それらのレジスタが特定の命令でしか使えなかったり、特定の型のデータしか保持できなくても。

ハードレジスタは一つの関数の中でも色々なモードでアクセスされる。しかし、疑似レジスタにはそれぞれ自然なモードが与えられており、そのモードでしかアクセスされない。疑似レジスタを自然なモード以外のモードでアクセスするのを記述する必要があるときは、subreg 式が使われる。

1ワードより多くのデータを指定するマシンモードを持つ reg 式は、実際には幾つかの連続するレジスタを表す事がある。そのレジスタ番号が、ある一個のハードウェアレジスタを指定するだけでなく、実際には、その指定されたレジスタから始まる、幾つかの連続したハードウェアレジスタ群を表している。

関数 RTL コードで使われている疑似レジスタ番号はそれぞれ、一意的な reg 式で表現される。

FIRST_VIRTUAL_REGISTER から LAST_VIRTUAL_REGISTER までの範囲の疑似レジスタ番号のうちいくつかは、RTL 生成過程にしか現れず、最適化過程の前に削除される。こういう疑似レジスタ番号は、それを含む関数についての RTL 生成が完了するまでは決定できないスタックフレーム中の位置を表す。以下の仮想レジスタ番号が定義されている。

VIRTUAL_INCOMING_ARGS_REGNUM

スタック渡しされた入力引数の先頭のワードを指し示す。通常、これらの引数は呼びだし側によって置かれるが、呼び出された側が、以前にレジスタで渡された引数の幾つかをプッシュすることもありうる。

RTL が完了した時点で、この仮想レジスタは、 ARG_POINTER_REGNUM で指定されるレジスタと FIRST_PARM_OFFSET の値の和に置き換えられる。 

VIRTUAL_STACK_VARS_REGNUM

FRAME_GROWS_DOWNWARD が定義されていれば、このマクロはスタック上の先頭の変数のすぐ上を指す。FRAME_GROWS_DOWNWARD が定義されていない場合は、スタック上の先頭の変数そのものを指す。
VIRTUAL_STACK_VARS_REGNUM は、FRAME_POINTER_REGNUM で指定されるレジスタと STARTING_FRAME_OFFSET の値の和で置き換えられる。 

VIRTUAL_STACK_DYNAMIC_REGNUM

これは、必要とするメモリ量の分だけスタックポインタの調整が行なわれた直後の、スタック上に動的に確保されたメモリの位置を指す。
この仮想レジスタは、STACK_POINTER_REGNUM で指定されるレジスタとSTACK_DYNAMIC_OFFSET の値の和に置き換えられる。 

VIRTUAL_OUTGOING_ARGS_REGNUM

スタックが前もってプッシュされたときに、出力引数が書き込まれるべきスタック上の位置を指す。(push insn を使ってプッシュされる引数は常に STACK_POINTER_REGNUM を使うべきである。)
この仮想レジスタは、STACK_POINTER_REGNUM で指定されるレジスタとSTACK_POINTER_OFFSET の値の和に置き換えられる。


(subreg:m reg wordnum)

subreg 式は、マシンに取って自然なモード以外のモードにあるレジスタ、あるいは実際には複数のレジスタを参照する複数ワードの reg のうちの一つのレジスタを参照するのに使われる。

疑似レジスタにはそれぞれ自然なモードがある。その自然なモードとは異なるモードでの操作が必要な場合、例えば、一個のバイトを保持している疑似レジスタに対してフルワードの移動命令を行なう場合は、その疑似レジスタは subreg の中に収まっていなければならない。この例の場合は、wordnum は 0 である。

m は普通は少なくとも reg のモードの幅しかなく、その場合、reg のビットのうち m に入っているものだけを考えれば良い。

場合によっては、m は reg のモードよりも広い。そういう subreg 式は、病的と呼ばれることがある。このような式は、より広いモードのオブジェクトを参照したいが、付加的なビットがどういう値を持っているかは気にしないという場合に使われる。再ロードパスは、病的な参照はハードレジスタに対してのみ作られることを保証する。

subreg の別の使い方は、複数のレジスタからなる値から個々のレジスタを取り出すことである。DImode や TImode の様なマシンモードは、一語より長い値、つまり通常二つ以上のレジスタを必要とする値である可能性がある。こういうレジスタの一つを参照するには、subreg をモードSImode で使い、wordnum でどのレジスタかを指定する。

病的でない subreg に格納すると、subreg と同じワードに属するビットに予期できない結果を生ずる。この手抜きにより、そういう命令に対して効率の良いコードを生成するのが用意になる。subreg の外側の全ビットを保存する命令を表現するには、subreg を strict_low_part で囲めば良い。

コンパイル時のパラメータである WORDS_BIG_ENDIAN が 1 に設定されていれば、ワード番号 0 が最上位部であることを指示する。1 でなければ、ワード番号 0 は最下位部を指示する。

ターゲットによっては、FLOAT_WORDS_BIG_ENDIAN とWORDS_BIG_ENDIAN が一致しないものが 2、3ある。だが、GCC のほとんどの部分は、浮動小数点値を、整数値と同じエンディアンであるとして取り扱っている。これがうまく働くのは、単に、それらを整数値の集まりとして扱っているからである。real.c と実行時ライブラリだけが、FLOAT_WORDS_BIG_ENDIAN に注意している。

結合パスと再ロードパスの間で、第一引数が reg ではなくmem になっている、病的な subreg が発生する可能性がある。また、再ロードパスの後では、mem を含む病的な subreg が発生する可能性があり、通常、mem が疑似レジスタを置き換えたスタックスロットである場合に起きる。

DFmode の値を subreg を使って SFmode で参照するのは正しくないことに注意。マシンによっては、DFmode の値の上位部分が単精度浮動小数点数値と同じフォーマットでない場合がある。

また、一個のハードレジスタにある複数ワードの値のうちの一ワードをアクセスすることは、その値が大きさから期待されるよりも少ないレジスタで保持できるときは、正しくない。例えば、32ビットマシンでは、浮動小数点レジスタは一個の DFmode の値全体を保持できる。レジスタ 10 がそのようなレジスタなら、(subreg:SI (reg:DF 10) 1) は正しくない。なぜなら、そのような参照を一個のマシンレジスタに変換する方法がないからである。再ロードパスは、subreg 式がこのような形式になるのを抑止する。

subreg 式の先頭のオペランドは SUBREG_REG マクロで、第二オペランドは SUBREG_WORD マクロで参照する。 

(scratch:m)

一個の命令の実行に必要とされ、それ以降は使われないスクラッチレジスタを表す。局所レジスタ確保か再ロードパスのどちらかにより、reg に変換される。

scratch は、普通は clobber 演算中に存在する(see Side Effects)。 


(cc0)

条件コードレジスタを参照する。オペランドは無く、マシンモードも持たない。使い方は以下の二通りがある。

条件コードフラグの完全なセットを表すために使う。ほとんどのマシンでは、それぞれの比較が一連のフラグ全体を設定するので、これが最善である。

このテクニックを使うと、(cc0) が正しく使える文脈は二つだけである。代入における代入先(テストおよび比較命令において)として、および 0 (値がゼロの const_int、すなわち const0_rtx である) との比較を行なう比較演算においてである。

一個の条件の結果である一個のフラグを表すために使う。これは、一個のフラグビットしか持たないマシン上で、そして比較命令がテストすべき条件を指定しなければならない場合に役にたつ。

この手法を使う場合、(cc0) が有効なのは次の二つの文脈だけである。ソースオペランドが比較演算子である(テストと比較命令では) 代入の目的オペランドとして、もう一つは(条件分岐の) if_then_else の最初のオペランドとしてである。

コード cc0 の式オブジェクトはただ一つだけ存在する。変数 cc0_rtx の値である。コード cc0 の式を作りだそうとすると必ず cc0_rtx が返ってくる。

命令が暗黙のうちに条件コードを設定する可能性がある。多くのマシンでは、ほぼ全ての命令が計算したり、格納した値に基づいて条件コードを設定する。こういう動作を RTL に明示的に記録する必要はない。というのは、マシン記述に、その命令が条件コードを設定することを認識するための指示が含まれているからである(マクロ NOTICE_UPDATE_CC を使う)。See Condition Code。条件コードを設定することだけを目的とする命令、そして条件コードを使用する命令だけが、(cc0) を書く必要がある。

マシンによっては、条件コードレジスタにレジスタ番号が与えられ、reg が (cc0) の代わりに使われる。条件コードを書き換える命令がほんの一部の命令に限られるなら、このアプローチが望ましい。また別のマシンでは、条件コードを汎用レジスタに格納する。その場合は疑似レジスタを使うべきである。

Sparc や RS/6000 のようなマシンでは、二種類の算術演算命令のセットがある。一つのセットは条件コードを設定し、もう一つは設定しない。このような場合を扱う最も良い方法は、通常は、条件コードを設定しない命令を生成し、算術演算の実行と条件コードレジスタ(この場合は(cc0) ではない)の設定の両方を行なうパターンを作ることである。例としては、sparc.md で addcc や andcc を探してみて欲しい。 

(pc)

プログラムカウンタを表す。オペランドは取らず、マシンモードも持たなくて良い。(pc) が使えるのは、分岐命令の特定の文脈においてだけである。

コードが pc である式オブジェクトはただ一つである。変数 pc_rtx の値である。コードが pc の式を作ろうとすると返ってくるのはpc_rtx になる。

分岐を行なわない命令は全て、プログラムカウンタをインクリメントすることにより暗黙のうちに変更する。しかし、このことを RTL に記述する必要はない。 

(mem:m addr)

この RTX は、式 addr で表されるアドレスの主記憶への参照を表す。m はメモリの、アクセスされる単位の大きさを表す。 
(addressof:m reg)

この RTX はレジスタ reg のアドレスを要求することを表す。モードは常に Pmode である。CSE のフェーズの後で関数内に addressof 式がどんなものであれ残っていれば、reg は強制的にスタックに置かれ、addressof 式は、そのスタックスロットのアドレスを表す plus 式で置き換えられる。

##算術演算用 RTL 式
指定されない限り、代数演算式の全てのオペランドはモード m に対して有効でなければならない。あるオペランドがモード m に対して有効なのは、オペランド自身のモードが m の場合か、オペランドが const_int または const_double で m が MODE_INT クラスのモードの時である。

交換可能な二項演算の場合には、定数は二番目のオペランドに置くべきである。

(plus:m x y)

マシンモード m で実行される、x と y で表される値の加算を表す。 

(lo_sum:m x y)

plus にほぼ同じだが、x と、y の下位ビットの和を表す点が異なる。下位ビット数は機種により異なるが、一般には、Pmode のビット数から、コード high によってセットされるビット数を引いたものになる(see Constants)。
m は、Pmode でなければならない。 

(minus:m x y)

減算を表す以外は plus と同じである。 

(compare:m x y)

比較目的の y から x を引く減算の結果を表す。無限の精度があるかのように、計算は桁溢れなしで行われる。
当然のことだが、実際に無限の精度で引き算を行える機械は存在しない。だが、引き算の結果の符号だけが使われる場合は、無限の精度で引き算ができるような振りをすることができる。その場合、引き算の結果は条件コードに格納される。そして、この種類の式が正しく使えるのはこういう場合、すなわち、条件コードに格納される値としてだけである。

モード m は、x や y のモードには関係なく、条件コードの値のモードになる。(cc0) が使われるのなら、VOIDmode になる。それ以外の場合は、MODE_CC クラスの中のあるモードになる。良く使われるのは CCmode である。See Condition Code.

普通は、x と y は同じモードでなければならない。それ以外で compare が有効なのは、x のモードが、MODE_INT のクラスに属し、かつ、y が VOIDmode モードの const_int か const_double の場合のみである。x のモードによって、比較が行われるモードが決まるので、x のモードは VOIDmode であってはならない。

オペランドの一方が定数であるなら、それは第二オペランドに置くべきであり、そうすることによって比較のためのコードが適切に調整される。

compare で、VOIDmode の定数を二つ指定するのは無効である。というのは、どのモードで比較を実行すべきか知りようがないからである。比較は、コンパイル中に畳み込まれるか、先頭のオペランドがそのモードがわかっているレジスタにロードされるかしなければならない。 

(neg:m x)

x で表現される値の符号を反転した(0 から引いた)値を表現する。m のモードで演算が行われる。 

(mult:m x y)

x と y で表される値の符号付きの積を表現する。積は、モード m で行われる。
機種によっては、オペランドよりも大きな積を生成する乗算をサポートしている。その場合には、次のようにパターンを書くこと。

(mult:m (sign_extend:m x) (sign_extend:m y))

ここで、m は、x と y のモードよりも大きいモードである。x と y のモードは同じでなくても良い。

符号無しの、大きな積を生じる乗算の場合には、zero_extend を使って同じように書けば良い。 

(div:m x y)

マシンモード m で x を y で割った、符号付きの商を表す。m が浮動小数点モードなら、厳密な商を表す。そうでなければ、整数化した商を表す。

マシンによっては、オペランドと商の幅が全部同じではない場合の除算命令を持っていることがある。そういう命令を表現するには、以下のように、truncate と sign_extend を使う。

(truncate:m1 (div:m2 x (sign_extend:m2 y)))

(udiv:m x y)

div とほぼ同じだが、符号無しの除算を表す。 

(mod:m x y)

(umod:m x y)

div や udiv と似ているが、商の代わりに剰余を表す。 

(smin:m x y)

(smax:m x y)

x と y の小さいほう(sminの場合)または大きいほう(smax の場合)を表す。この場合、モード m の符号付き整数として解釈が行なわれる。 

(umin:m x y)

(umax:m x y)

smin や smax とほぼ同じだが、符号無しの整数として解釈が行なわれる。 

(not:m x)

x で表される値のビット毎の補数を表現する。この演算はモード m で行なわれる。m は、固定小数点モードでなければならない。 

(and:m x y)

x と y で表される値のビット毎の論理積を表現する。ビット毎の論理積はモード m で実行される。このモードは、固定少数点数のモードでなければならない。 

(ior:m x y)

x と y で表される値のビット毎の論理和を表現する。ビット毎の論理和はモード m で実行される。このモードは、固定少数点数のモードでなければならない。 

(xor:m x y)
x と y で表される値のビット毎の排他的論理和を表現する。ビット毎の排他的論理和はモード m で実行される。このモードは、固定少数点数のモードでなければならない。 

(ashift:m x c)

x を左に c 回算術シフトした結果を表現する。x のモードは m であり、固定少数点数のモードである。c は、固定小数点数モードか、モードが VOIDmode の定数である。c のモードがどちらになるかは、マシン記述中の左シフト命令のエントリに対して呼び出されるモードにより決定される。例えば、Vax では、c のモードは、m に関わらず、QImode である。 

(lshiftrt:m x c)

(ashiftrt:m x c)

右シフトである点を除いて、ashift と同じである。左シフトの場合と違って、この二つの演算は異なる物である。 

(rotate:m x c)

(rotatert:m x c)

同様に、左右のローテーションを表す。c が定数なら、rotate の方を使うこと。 

(abs:m x)

モード m で計算した、xの絶対値を表現する。 

(sqrt:m x)

モード m で計算した、x の平方根を表現する。ほとんどの場合、m は浮動小数点モードになる。 

(ffs:m x)

x の、 1 であるビットのうちの最下位のビットの位置に 1 を足したものを、モード m の整数として表現する。(x がゼロであれば、この値は0 になる。) x のモードは m でなくても良い。ターゲットの機種により、色々なモードの組合せが有効である。

##比較演算

比較演算子は、二つのオペランドについてある関係が成り立つかどうかを調べ、その関係が成り立つなら 0 でない値、成り立たないなら 0 を表す。0 でない値の方は、機種依存であり、 STORE_FLAG_VALUE (see Misc)で記述されるが、この値に等しくなる必要はない。比較演算のモードは、比較対象のデータのモードには関係ない。比較演算が、条件判定に使われる(例えば、if_then_else の第一オペランドとして使われる)場合は、モードは VOIDmode でなければならない。あるいは、比較演算の結果、変数に格納すべきなんらかのデータを生じるなら、モードは MODE_INT のクラスに入っていなければならない。データを生成する全ての比較演算は同じモードを使わなければならない。どのモードになるかは機種依存である。

比較演算の使われ方には二通りある。比較演算子を使って、条件コード (cc0) をゼロと比較することができる。例えば、(eq (cc0) (const_int 0)) のようにである。こういう構文では、条件コードを設定する先行命令の結果を実際に参照している。条件コードを設定する命令は、条件コードを使用する命令の直前になければならない。これらの命令の間に置いて良いのは、note insn だけである。

あるいは、比較演算は二つのデータオブジェクトを直接比較しても良い。比較のモードはオペランドにより決定される。どちらのオペランドもある共通のマシンモードに対して有効でなければならない。両方のオペランドが定数である比較は、モードを決めることができないので無効である。しかし、そのような比較は、定数畳み込みにより、RTL 中には決して存在しないはずである。

上の例だと、(cc0) が直前で (compare x y) に設定されているなら、比較演算は (eq x y) に等価である。普通は、ある特定のマシンでは、どちらか一方の形式のだけの比較がサポートされている。しかし、組合せパスは演算をマージして、特定の insn が含まれている文脈に存在するなら、このような eq 式を生成することを試みる。

不等比較は、符号付きと符号なしの二種類がある。このため、符号付きと符号なしの「大なり」に対応して、gt と gtu の異なる式コードがある。これらは、同じ整数値の組合せに対して異なる結果を生じることもある。例えば、1 は符号付きでは -1 より「大なり」であるが、符号なしでは「大なり」ではない。-1 は符号なしとして扱われると、実際には 0xffffffff となり、 1 より大きいからである。

符号付き比較はまた浮動小数点値にも使われる。浮動小数点比較は、オペランドのマシンモードにより区別される。

(eq:m x y)

x と y で表現される値が等しければ 1 で、等しくなければ 0 である。 

(ne:m x y)

x と y で表現される値が等しくなければ 1 で、等しければ 0 である。 

(gt:m x y)

x が y より大きければ 1 である。両者とも固定小数点であれば、符号付きで比較が行なわれる。 

(gtu:m x y)

符号無しで比較が行なわれ、そのため固定小数点数についてのみ使われるという点を除いて、gt と同じである。 

(lt:m x y)

(ltu:m x y)

gt や gtu と同様だが、「より小さい」かどうかを判定する。 

(ge:m x y)

(geu:m x y)

gt や gtu と同様だが、「以上」かどうかを判定する。 

(le:m x y)

(leu:m x y)

gt や gtu と同様だが、「以下」かどうかを判定する。 
(if_then_else cond then else)
これは、比較演算ではないが、ここで挙げておく。というのは、必ず比較演算と関連して使われるからである。正確に言うと、cond は比較式である。if_then_else 式は、cond により、then で表される値とelse で表される値のどちらかの選択肢を表す。
ほとんどの機種では、if_then_else 式は条件ジャンプを表す場合にのみ有効である。 

(cond [test1 value1 test2 value2 ...] default)

if_then_else と同様だが、もっと一般的である。test1、test2、... がそれぞれ順番に実行される。cond 式の結果は、最初に非 0 となったテストに対応する value となる。あるいは、非 0 となったテストがなければ、default になる。

この式は、現時点では命令パターンに対しては使用できない。insn の属性にたいしてのみ使用できる。See Insn Attributes.

##ビットフィールド

特別な式コードがあり、ビットフィールド命令を表現することができる。この型の式は、RTL 中で左辺値となる。代入式の左辺に置くことが可能で、その式で指定されたビットフィールドにある値を代入することを指示する。

(sign_extract:m loc size pos)

これは、loc(メモリかレジスタの参照)に含まれるか、そこで始まっている符号拡張されたビットフィールドへの参照を表す。このビットフィールドは幅が size ビットで、ビット位置 pos から始まっている。コンパイル時の選択により、BITS_BIG_ENDIAN が、メモリ単位のどちらの端から pos を数えるかを指定する。

loc がメモリ中に置かれているなら、そのモードは一バイト整数のモードでなければならない。loc がレジスタに置かれているなら、使うべきモードは、パターン insv または extv (see Standard Names) のオペランドとして指定されたものになり、通常は全語の整数モードである。何も指定がないときのデフォルトは全語の整数モードになる。

pos のモードはマシン固有であり、パターン insv またはextv でも指定される。

モード m は、loc がレジスタなら、それに使われるモードと同じである。 

(zero_extract:m loc size pos)

sign_extract と同様だが、符号なし、あるいはゼロ拡張されたビットフィールドを参照する。同じビット列が抽出されるが、符号拡張ではなくゼロで埋め尽くされる。

##変換

マシンモード間の変換は全て、明示的な変換演算で表す必要がある。例えば、あるバイトとある全語の和を表す式を、(plus:SI (reg:QI 34) (reg:SI 80)) と書くことはできない。なぜなら、plus という演算では、二つのオペランドは同じマシンモードを持つ必要があるからである。このため、バイトの大きさのオペランドを変換演算で以下のように包む必要がある。

(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))

変換演算は単なるプレースホルダーではない。というのは、指定された変換前のモードから変換後のモードへ変換する方法はひとつだけではないからである。変換演算のコードで、変換方法を指定するのである。

以下のどの変換演算でも、x は VOIDmode であってはならない。変換を行なうべきがモードが判らないからである。変換は、コンパイル時に行なうか、x をレジスタに保持するかのどちらかでなければならない。

(sign_extend:m x)

値 x をマシンモード m へ符号拡張した結果を表現する。m は固定小数点モードでなければならず、x は、m より幅の狭いモードの固定小数点値でなければならない。 

(zero_extend:m x)

値 x をマシンモード m へゼロ拡張した結果を表現する。m は固定小数点モードでなければならず、x は、m より幅の狭いモードの固定小数点値でなければならない。 

(float_extend:m x)

値 x をマシンモード m に拡張した結果を表現する。m は浮動小数点モードでなければならず、x は、m より幅の狭いモードの浮動小数点数値でなければならない。 

(truncate:m x)

値 x をマシンモード m に打切った結果を表現する。m は固定小数点モードでなければならず、x はm より幅の広いモードの固定少数点値でなければならない。 

(float_truncate:m x)

値 x をマシンモード m に打切った結果を表現する。m は浮動小数点モードでなければならず、x はm より幅の広いモードの浮動少数点値でなければならない。 

(float:m x)

固定小数点値 x を符号付きとみなし、浮動小数点モード m に変換した結果を表す。 

(unsigned_float:m x)

固定小数点値 x を符号無しとみなし、浮動小数点モード m に変換した結果を表す。 

(fix:m x)

m が固定小数点モードの場合、浮動小数点値 x をモード m の符号付き整数に変換した結果を表現する。丸めをどのように行なうかは規定されないので、C プログラムをコンパイルするときにこの演算が正しく使えるのは、オペランドが整数値を持つ時だけである。 

(unsigned_fix:m x)

浮動小数点値 x をモード m の符号なし整数に変換した結果を表現する。丸めをどのように行なうかは規定されない。 

(fix:m x)

m が浮動小数点モードの場合、浮動小数点値 x(モードm で有効) を整数に変換した結果を表現する。この結果は浮動小数点モード m で表現される。丸めは 0 に向かって行なわれる。

##宣言

宣言式コードは、算術演算を表すのではなく、オペランドの状態に関する表明を表す。

(strict_low_part (subreg:m (reg:n r) 0))
この式コードはただ一つの文脈でのみ使われる。set 式の目的オペランドとしてだけ使われる。さらに、この式のオペランドは矛盾のない subreg 式でなければならない。
strict_low_part があると、モード n では意味があるが、モード m の一部ではないようなレジスタの一部が、変更すべきでないことを示す。通常、m の幅がワードより狭いときは、このようなサブレジスタに代入を行なうと、そのレジスタの他の部分に予期しない影響を与える。

##副作用式

ここまで説明してきた式コードは値を表すものであり、動作を表すものではなかった。しかし機械命令というものは決して値を生み出すものではない。機械命令は、マシンの状態に副作用を与えるという点でのみ意味を持つ。特別な式コードを使って、副作用を表現する。

命令の本体は、必ず以下の副作用を表すコードの一つである。これまで説明してきた、値を表現するコードは、これらのオペランドとしてのみ現れるのである。

(set lval x)

x の値を lval で表される場所に格納する動作を表現する。lval は、その中に格納可能であるような場所を表す式である。すなわち、reg(あるいは subreg、または strict_low_part)、mem、pc、cc0 のどれかである。
lval が、reg、subreg、mem のどれかなら、マシンモードを持つ必要がある。その場合、x は、そのモードで有効でなければならない。

lval が、マシンモードがそのレジスタの全幅より小さいようなreg であれば、そのマシンモードにより指定されたレジスタの部分には指定された値が与えられ、レジスタのその他の部分は未定義値となる。同様に、lval が、レジスタのモードより狭いモードの subreg なら、レジスタのその他の部分がどのように変更されるかは不定である。

lval が、subreg の strict_low_part なら、subreg のマシンモードで指定されたレジスタの部分は、値 x が与えられ、その他の部分は変更されない。

lval が (cc0) なら、マシンモードがないので、x は compare 式か、任意のモードを持つ値で良い。後者の場合は、"test" 命令を表現する。(set (cc0) (reg:m n)) という式は、(set (cc0) (compare (reg:m n) (const_int 0))) という式に等価である。前者の式を使ったほうが、コンパイル中のメモリを節約できる。

lval が (pc) なら、それはジャンプ命令であり、x の取りうる値は非常に限られてくる。x は、label_ref 式とすることができる(無条件ジャンプ)。if_then_else (条件ジャンプ)とすることもでき、その場合、第二オペランドか第三オペランドのどちらかが (pc) (ジャンプしない場合に使われる)でなければならず、またもう一方は label_ref (ジャンプする場合に使われる)でなければならない。また、x は mem または (plus:SI (pc) y) でも良い。ここで、y は reg か mem である。この最後のパターンは分岐テーブル経由のジャンプを表現するのに使われる。

lval が (cc0) でも (pc) でもなければ、lval のモードは VOIDmode としてはならず、x のモードはlval のモードとして有効でなければならない。

lval は SET_DEST マクロで、x は SET_SRC マクロでアクセスするようにするのが良い。 

(return)

パターン中に単独の式として書くことで、現在の関数から戻ることを表す。ただし、VAX のように一命令で戻ることができるマシンに限られる。関数から戻るためには、複数の命令からなる「エピローグ」を実行する必要があるマシンでは、関数からの復帰は、エピローグの直前に置かれるラベルへジャンプすることで行なわれるので、return 式コードが使われることはない。
if_then_else 式の中に置いた場合は、呼び出し元に戻るための pc に置かれる値を表す。

(return) というパターンは、論理的には (set (pc) (return)) と等価であるが、後者の形式が使われることはない。 

(call function nargs)

関数呼び出しを表現する。function は mem 式であり、この式のアドレスは、呼び出される関数のアドレスである。nargs は二つの目的で使われる式である。あるマシンでは、スタックに積まれた引数のバイト数を表現する。あるいは、引数レジスタの数を表現する。
どのマシンも function が持たなければならない標準的なマシンモードを持っている。マシン記述では、FUNCTION_MODE というマクロを、その不可欠のモード名に展開されるように定義している。このモードの目的は、どの種類のアドレッシングが許されるかがアドレスの対象となるマシンモードに依存するマシンにおいて、どの種類のアドレッシングが許されているかを指定することである。 

(clobber x)

予期できない値を x に格納すること、または格納する可能性があることを表す。x は、reg 式か、scratch 式か、mem 式のどれかでなければならない。
これが使われるのは一つは、標準的な値を特定のハードレジスタに格納する文字列命令においてである。格納される値を記述する手間をかける必要はないが、文字列命令を越えてその値を保持しようとしないように、コンパイラにレジスタの値が変更されることを知らせるのが本質的な事である。

もし x が (mem:BLK (const_int 0)) なら、全メモリ位置が上書きされると見なされなければならないことを意味する。

マシン記述では、ある種類のハードレジスタを「呼びだし時破壊」("call-clobbered") として分類していることに注意。全ての関数の呼びだし命令は、デフォルトでこれらのレジスタを破壊すると仮定されているので、この事実を示すために clobber 式を使う必要はない。また、各関数呼び出しは、その関数が const と宣言されていない限り、任意のメモリ位置を変更する可能性があると仮定されている。

parallel の最後の組の式が、それぞれ reg かmatch_scratch 式 (see RTL Template)を引数とするclobber 式なら、組合せフェーズは、そうすることでパターンがマッチするようになるなら、適切な clobber 式を、構築されたばかりのinsn に追加する。

この機能は、例えば、乗算命令と加算命令は MQ レジスタを使わないが、アキュムレータへの加算命令が MQ レジスタを上書きするようなマシンで使うことができる。一個の組み合わされた命令(? combined instruction)は一時レジスタを必要とするが、一方、それを構成する命令は一時レジスタを必要としない場合も同様である。

あるレジスタに対する clobber 式が、他に副作用のある parallel の中に現れた場合は、レジスタ確保部が、そのレジスタがその insn の前後どちらにおいても占有されることがないことを保証する。しかし、選ばれた選択肢に対して制約 & が指定されていない限り、再ロードパスが入力の一つとして使われたレジスタを確保する場合がある(see Modifiers)。特定のハードレジスタ、または疑似レジスタ、あるいは scratch 式のどれかを上書きすることができる。後の二つの場合には、GNU CC は、その時点で一時的に使用可能なハードレジスタを確保する。

一時レジスタを必要とする命令については、疑似レジスタの代わりにscratch を使うべきである。そうしておくと、組合せフェーズが必要なときに clobber を追加することを許すからである。このためには (clobber (match_scratch ...)) と書けば良い。疑似レジスタを上書きするなら、他のどこにも現れていないものを使うこと。つまり、そのたびに新しいものを生成して使うこと。そうしないと、CSE のフェーズが混乱する。

parallel 中で疑似レジスタを上書きすることのもう一つの使い道がある。insn の入力オペランドの一つがやりその insn により上書きされる場合である。この場合、insn 中の clobber の中と、別のところとに同じ疑似レジスタを使うと期待どおりの結果が得られる。 

(use x)

x の値が使われるということを表す。プログラムのこの時点での x の値が必要であることを示す。たとえ、なぜ必要であるかがはっきりしていなくてもである。このため、GCC は、x に値を格納するという効果しか持たない命令が直前にあっても、その命令を削除しない。x は、reg 式でなければならない。
再ロードフェーズの間、パターンとして use がある insn は、reg_equal ノートを保持することが可能である。このような use insn は、再ロードフェーズが終了する前に削除される。

遅延分岐スケジューリングのフェーズの間は、x は insn でも良い。これは、x が以前にコード中のこの場所にあって、そのデータ依存関係を考慮する必要があるということを意味する。このような use insn は、遅延分岐スケジューリングのフェーズの終了前に削除される。

並列に実行される様々な副作用を表す。大カッコはベクトルを表す。parallel のオペランドは式を要素とする一個のベクトルである。x0、x1 等は個々の副作用を表す式である。これらの式のコードは、setや call、return、clobber、use のどれかである。

「並列に」という意味は、最初に個々の副作用で使われる全ての値が計算され、次に全ての副作用が実行されることを表す。

(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])

例えば、上の式はハードレジスタ 1 の値と、ハードレジスタ 1 により指定されるメモリ位置の値を交換するということを曖昧さなしに表している。(reg:SI 1) がメモリアドレスとして現れているところでは、どちらも、insn を実行する前のレジスタ 1 の値を参照している。

このため、parallel を使ったときに、ある一つの set の結果が次の set で使えると考えるのは間違いということになる。例えば、人は良く、条件が 0 なら分岐する命令を以下のように表そうとする。

(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref ...)
                        (pc)))])

しかし、この書き方は間違いである。何故なら、これだと分岐条件はこの命令の前の条件コードの値に依存しており、この命令により設定される新しい値を使っていないからである。

のぞき穴最適化は、最終フェーズのアセンブリコード出力と一緒に行なわれる。この最適化により、一個の parallel からなるパターンの insn を生成することができる。この場合、parallel の各要素は、結果となるアセンブラコードを出力するのに必要なオペランド--多くの場合、reg あるいは mem、定数式である。これは、他のどのコンパイル過程でも適切な形式の RTL ではないが、その後には、もはや実行すべき最適化過程が残っていないので、問題ないのである。ただし、マクロ NOTICE_UPDATE_CC をもし定義するなら、その定義では、なんらかののぞき穴最適化を定義するなら上記のような insn を取り扱わなければならない。 

(sequence [insns ...])

ある insn の列を表す。ベクトル中に現れる insns のそれぞれは、insn の連鎖に現れるのに適したものであるために、insn、jump_insn、call_insn、code_labe、barrier、note のどれかでなければならない。
sequence RTX は、RTL 生成の間は実際の insn には決して置かれることがない。この RTX は define_expand から生ずる insn の列を表しており、それは、insn が emit_insn に渡され、insn の連鎖に挿入されるまえに行なわれる。実際に挿入された時点で、個々のサブ insn が分離し、sequence が捨てられる。

遅延スロットスケジューリングが完了した後、ある insn とその遅延スロットに置かれている全ての insn は一まとめにされて、一個の sequence に収められる。遅延スロットを必要とする insn は、ベクトル中の先頭のinsn である。その後ろに続く insn は遅延スロットに置かれる。

遅延スロット中の insn には INSN_ANNULLED_BRANCH_P が設定され、遅延スロット中の insn の効果を条件により無効化するような分岐 insn を使うべきであることを指示する。

以下の式コードは副作用の代わりに、insn の本体として現れる。だが、厳密に言えばいつでも副作用を表すわけではない。

(asm_input s)

文字列 s で表されるアセンブラコードそのものを表す。 

(unspec [operands ...] index)

(unspec_volatile [operands ...] index)

operands についてのマシン固有の演算を表す。index で、複数のマシン固有演算の一つを選び出す。unspec_volatile を使って、揮発性の演算とトラップを起こす可能性のある演算を表す。その他の演算には unspec が使われる。
これらのコードは insn の pattern の内側、parallel の内側、式の内側に現れる可能性がある。 

(addr_vec:m [lr0 lr1 ...])

ジャンプ先アドレスのテーブルを表す。ベクトルの要素 lr0... 等は label_ref 式である。モード m で各アドレスにどれだけのメモリを与えるかを指定する。普通は m は Pmode になる。 

(addr_diff_vec:m base [lr0 lr1 ...] min max flags)

ジャンプ先アドレスを base からのオフセットで表したテーブルを表す。ベクトルの要素 lr0... 等は、label_ref 式であり、base も label_ref 式である。モード m で各アドレスの差分にどれだけのメモリを与えるかを指定する。min と max は分岐の近距離化により設定され、それぞれ最小と最大のアドレスを持つラベルを保持する。flags は、それを保持する insn に対する base、min、max と、base に対する min、max の相対的な位置を表す。詳細については rtl.def を参照のこと。

##アドレスの埋め込み副作用

メモリアドレスとして現れる、特別な副作用式コードが 6 つある。

(pre_dec:m x)

x を標準量だけデクリメントする副作用を表す。また、x がデクリンメントされた後の値も表す。x は reg か mem でなければならず、ほとんどのマシンでは reg しか許していない。m はそのマシンのポインタ用のマシンモードでなければならない。x のデクリメントされる量は、アドレスとして振る舞う式のメモリ参照を含むマシンモードの長さをバイト数で表したものである。以下に使い方の例を示す。
(mem:DF (pre_dec:SI (reg:SI 39)))
これは、疑似レジスタ 39 を DFmode の値の長さだけデクリメントし、その結果を DFmode の値のアドレスとして使う事を示している。 

(pre_inc:m x)

同様だが、デクリンメントではなく x のインクリメントを指定する。 

(post_dec:m x)

pre_dec と同じ副作用を表すが、異なる値になる。これにより表される値は、デクリメントされる前の x の値である。 

(post_inc:m x)

同様だが、デクリンメントではなく x のインクリメントを指定する。 
(post_modify:m x y)
x を y に設定する副作用を表現し、かつ x が修正を受ける前のx を表現する。x は reg か mem でなければならない。だが、多くの機種では reg しか許していない。m は使われている機種でのポインタのマシンモードでなければならない。x がデクリメントされる量は、この式がアドレスの役割をするメモリ参照のマシンモードの長さをバイトで表したものである。これは、現在実装されていないことに注意。
式 y は次の三つの形式のうちの一つでなければならない。

(plus:m x z) (minus:m x z) (plus:m x i)

ここで z はインデックス・レジスタで、i は定数である。
使い方の例を示す。

(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42) (reg:SI 48))))

これは、疑似レジスタ 42 を、疑似レジスタ 48 の内容をそれに加算する形で変更することを示している。ただし、42 が指し示していた内容が使われた後で行われる。 

(pre_modify:m x expr)

同様に、x の内容を使う前に副作用が発生する。

これらの組み込み副作用式は注意して使わなければならない。命令パターンでは使わない。コンパイラの flow パスに至るまでは、スタックへのプッシュを表現するのに使われるだけである。flow パスは、レジスタが一個の命令でインクリメントまたはデクリメントされ、かつ、その直前または直後でアドレスとして使われている場合を探す。そのような場合は、プリ／ポスト・インクリメント／デクリメントを使うように変換する。

これらの式のオペランドとして使われているレジスタが、ある insn の別のアドレス中で使われていると、そのレジスタの元の値が使われる。レジスタをアドレス以外に使うことは、同一 insn 内で埋め込み副作用式として使うのは許されない。なぜなら、そういう式は、異なる機種では異なる振る舞いをし、そのため、取扱いが曖昧になるので許されない。

組み込み副作用式で表現可能な命令は、また、アドレスレジスタがどのように変更されるかを記述する追加の set を含む parallel を使って表現することもできる。だが、これは行なわれない。何故ならこのような操作をともかく許す機種では、典型的には、メモリアドレスが要求される場所ならどこでもそういう操作を許すからである。これらの操作を付加的な並列格納として記述すると、マシン記述のエントリ数が二倍必要になる。

##式としてのアセンブラ命令

RTX コード asm_operands は、ユーザが指定したアセンブラ命令により生成される値を表現する。引数付きの asm 文を表現するのに使われる。出力オペランドが一つの asm 文は以下のようになる。

asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));

この asm 文は、値が outputvar に格納されることを表現する、一個の asm_operands RTX を使って以下のように表現される。

(set rtx-for-outputvar
     (asm_operands "foo %1,%2,%0" "a" 0
                   [rtx-for-addition-result rtx-for-*z]
                   [(asm_input:m1 "g")
                    (asm_input:m2 "di")]))
                    
ここで、asm_operands RTX のオペランドは、アセンブラテンプレート文字列、出力オペランドについての制限子、指定されたオペランドの中での出力オペランドの番号、入力オペランド RTX のベクトル、それに、入力オペランドのモードと制約のベクトルからなる。モード m1 は、和 x+y のモードであり、m2 は、*z のモードである。

asm 文に複数の出力値がある場合は、その insn は parallel の内側に幾つかの set RTX を持つ。setはそれぞれ asm_operands を含んでいる。これらの set は全て、同じアセンブラテンプレートとベクトルを共有しているが、それぞれ出力オペランドに応じた制約を保持している。

#Insns

関数のコードの RTL 表現は、insn と呼ばれるオブジェクトの二重線形リストである。insn は他に用途のない特別なコードを持つ式である。insn の一部は実際の命令である。switch 文のための分岐テーブルを表現するものもある。その他、分岐先ラベルや様々な宣言的な情報を表現するものもある。

各 insn は、それ自身固有のデータを持つほか、現在の関数内の他の insn と区別するための一意的な識別番号(遅延分岐スケジューリングの後で、同じ識別番号を持つ insn のコピーが一つの関数内で複数存在することがあるが、これらのコピーは全く同じであり、sequence の中にしか現れない)、それに直前と直後の insn を指すポインタを持っている。この三つのフィールドはどの insn においても、insn の式コードによらずに、同じ位置にある。この三つのフィールドは XEXP と XINT を使ってアクセスしても良いが、以下のような特別なマクロが三つあり、いつでも使うことができる。

INSN_UID (i)

insn i に一意的な識別番号をアクセスする。 

PREV_INSN (i)

i の直前の insn へのポインタをアクセスする。i が先頭の insn なら、ヌルポインタになる。 

NEXT_INSN (i)

i の直後の insn へのポインタをアクセスする。i が末尾の insn なら、ヌルポインタになる。

insn のリストの先頭の insn は、get_insns で得ることができる。末尾の insn は、get_last_insn を使って得ることができる。先頭の insn から末尾の insn の範囲内では、NEXT_INSN とPREV_INSN のポインタは常に対応している必要がある。つまり、insn が先頭の insn でなければ、

NEXT_INSN (PREV_INSN (insn)) == insn

上の式は常に真であり、また、insn が末尾の insn でなければ、

PREV_INSN (NEXT_INSN (insn)) == insn
は常に真である。

遅延分岐スケジューリング後、リスト中の insn の幾つかはsequence 式である可能性がある。sequence は、insn のベクトルを含んでいる。このベクトルの中の insn の NEXT_INSN の値は、最後の insn を除いて、ベクトルの中での次の insn を指す。ベクトルの最後の insn の NEXT_INSN の値は、その insn を含むsequence に対する NEXT_INSN の値と同じである。PREV_INSN についても同様である。

つまり、先に述べた恒等式は、sequence の中の insn については必ずしも真ではないのである。特に、insn が sequence の先頭の insn なら、NEXT_INSN (PREV_INSN (insn)) は、sequence 式を含む insn になり、同様に、PREV_INSN (NEXT_INSN (insn)) は、sequence 式の最後の insn になる。これらの式を使って sequence 式を含む insn を取り出すことができる。

どの insn も以下のような6個の式コードの一つを持っている。

insn

式コード insn は、ジャンプも関数呼び出しも行わない命令に対して使う。sequence 式は、その中の insn の一つがジャンプや関数呼び出しを行なっても、常にコード が insn である insn に含まれる。
コードが insn である insn は、上記の三つの必須フィールドの他に、四つのフィールドを持つ。この四つのフィールドについては後出の表で説明する。 

jump_insn

式コード jump_insn はジャンプを行なう可能性のある命令(あるいは、もっと一般的に言うと、label_ref 式を含む命令)で使われる。現在の関数から復帰する命令があるなら、やはり jump_insn になる。
jump_insn の insn には、コード insn の insn と同じ追加のフィールドがあり、同じようにしてアクセスされ、さらにジャンプ最適化が完了したときに一度だけ定義される JUMP_LABLE というフィールドも保持している。

単純な、条件ジャンプと無条件ジャンプの場合は、このフィールドはcode_label を保持しており、ここに insn が(条件分岐の場合もある) 分岐していく。もっと複雑なジャンプでは、JUMP_LABEL が insn が参照しているラベルの一つを記録している。その他のラベルを探すには insn の本体全体を走査するしかない。

関数から復帰する insn はジャンプ insn として数えるが、何もラベルを参照していないので、JUMP_LABLE フィールドは 0 になる。 

call_insn

式コード call_insn は、関数呼びだしを行なう可能性のある命令に対して使われる。これらの命令を区別するのは重要である。なぜなら、特定のレジスタやメモリ位置の値を、予測できない形で変えてしまう可能性があるからである。
call_insn insn は insn insn と同じ追加のフィールドを持ち、同じ方法で参照する。さらに付け加えて、CALL_INSN_FUNCTION_USAGE というフィールドを持っており、このフィールドは一つのリスト(expr_list 式の連鎖である)を保持している。このリストは、被呼びだし関数により使われたか、あるいは上書きされたハードレジスタを示す use 式とclobber 式を含んでいる。このリストの clobber に指定されたレジスタは、call_insn の実行の後、変更される。一方、call_insn の本体の clobber で指定されたレジスタは、insn の実行が完了する前に上書きされる。このリストの clobber 式は CALL_USED_REGISTERS で指定されたレジスタを増やす。(see Register Basics)。 

code_label

code_labe insn は、分岐命令の分岐先となりうるラベルを表す。標準の三つのフィールドに加えて二つの特別なフィールドがある。CODE_LABEL_NUMBER を使って ラベル番号、すなわち、コンパイル単位(現在の関数の中だけではない)の全てのラベルの中から、このラベルを一意的に特定する番号を保持する。最終的には、このラベルはアセンブラ出力ではアセンブララベルとして表現される。これは、通常は Ln という形式になる。ここで n はラベル番号である。
code_label が RTL 式に現れるときは、普通はそのラベルのアドレスを表す label_ref の中に、番号として現れる。

フィールド LABEL_NUSES は、ジャンプ最適化フェーズが完了した時に一度だけ定義され、現在の関数の中でこのラベルが参照された回数を保持する。 

barrier

バリアは、命令ストリームの、制御の流れが越えることのできない地点に置かれる。無条件ジャンプ命令の後ろに置かれ、ジャンプが無条件であることを知らせる。また、volatile 関数呼び出しの後ろにも置かれる。これらの関数が戻る事はない(例えば exit である)。これらは、三つの標準フィールド以外の情報は持っていない。 

note

note insn は、付加的な、デバッグ情報および宣言に関する情報を表すのに使われる。この insn には、非標準のフィールドが二つある。一つは整数で、マクロ NOTE_LINE_NUMBER で参照され、もう一つは文字列で、マクロ NOTE_SOURCE_FILE で参照される。

NOTE_LINE_NUMBER が正なら、そのノートはソース行の位置を表し、NOTE_SOURCE_FILE は、その行が含まれるソースファイル名を表す。このノートは、アセンブラ出力に行番号データを生成するの使われる。

NOTE_LINE_NUMBER が正でないなら、実際の行番号ではなくては、以下の値の一つを持つコードである。この場合、NOTE_SOURCE_FILE はヌルポインタでなければならない。

NOTE_INSN_DELETED

このノートは完全に無視できる。幾つかのフェーズでは、insn を削除するのを、それらの insn をこの種類のノートに変えてしまうことで行なっている。 

NOTE_INSN_BLOCK_BEG

NOTE_INSN_BLOCK_END

この型のノートは、変数名のスコープレベルの開始位置と終了位置を表す。デバッグ情報の出力を制御する。 

NOTE_INSN_EH_REGION_BEG

NOTE_INSN_EH_REGION_END

この型のノートは、例外処理のスコープレベルの開始位置と終了位置を表す。NOTE_BLOCK_NUBMER で、どの CODE_LABEL が指定された領域に付属するかを特定する。 

NOTE_INSN_LOOP_BEG

NOTE_INSN_LOOP_END

この型のノートは、while または for ループの開始位置と終了位置を表す。これらにより、ループ最適化部が素早くループを見つけられるようになる。 

NOTE_INSN_LOOP_CONT

ループの中の、continue 文の飛び先位置に現れる。 

NOTE_INSN_LOOP_VTOP

このノートは、終了テストが複製されるようなループにおいて、終了テストが始まる位置を示す。この位置は、ループ不変量を考えるときのもう一つの仮想的なループの開始位置となる。 
NOTE_INSN_FUNCTION_END
関数本体の終り近く、(一個の命令では関数から戻れないマシンでは) return 文の飛び先ラベルの直前に現れるノートである。 

NOTE_INSN_SETJMP

setjmp や関係する関数の呼び出し毎に、その直後に現れる。
これらのコードは、デバッギングダンプにはシンボルで表示される。

insn のマシンモードは普通は VOIDmode だが、フェーズによってはモードを色々な目的で使用する。

共通部分式削除パスでは、処理済みのブロックの先頭の insn の場合、その insn のモードを QImode に設定する。

二回目の Haifa スケジューリングパスでは、複数命令の同時発行が可能なターゲットに対しては、insn が同時に発行される命令のグループの始まりの命令であると思われる場合は、その insn のモードを TImode に設定する。つまり、その命令は直前の命令と同時に発行できないものである。以降のパス、特に機種依存の命令並べ替えではこれはに頼っている。

以下は、insn、jump_insn、call_insn insn の追加フィールドの表である。

PATTERN (i)

この insn により発生する副作用を表す式。これは次のコードのどれか一つでなければならない。set、 call、 use、clobber、 return、 asm_input、 asm_output、addr_vec、 addr_diff_vec、 trap_if、 unspec、unspec_volatile、 parallel、sequence。もし parallel なら、parallel の各要素もこれらのコードでなければならない。ただし、parallel 式はネストできないこと、addr_vec と addr_diff_vec は parallel 式の内側では許されないという例外がある。 

INSN_CODE (i)

マシン記述中のどのパターンがこの insn にマッチするかを特定する整数である。照合がまだ行なわれていないなら -1 を返す。
use、clobber、asm_input、addr_vec、addr_diff_vec のどれか一個を使った式からなるパターンを持つ insn については、照合は行なわれず、このフィールドは -1 のまま変わらない。

asm 文から生じる insn の場合も照合は行なわれない。これらの insn は少なくとも一個の asm_operands 式を含む。このような insn に対して、関数 asm_noperands は非負の値を返す。

デバッグ出力では、このフィールドは数字の後に記号名表現が出力される。この記号名表現は、md ファイル中のパターンの位置を、名前付きパターンからの小さな正または負のオフセットとして示す。 

LOG_LINKS (i)

基本ブロック内の命令間の依存関係についての情報を与えるリスト(insn_list 式の連鎖)。ジャンプやラベルは、関係のある insn の間には入らない。 

REG_NOTES (i)

insn について種々雑多な情報を与えるリスト(expr_list 式とinsn_list 式の連鎖)。その insn で使われているレジスタに関係する情報であることが多い。
insn の LOG_LINKS フィールドは、insn_list 式の連鎖である。それぞれの insn_list 式はオペランドを二つ取る。一番目はある insn であり、二番目は別の insn_list 式(連鎖の次のもの) である。連鎖の最後の insn_list では、二番目のオペランドはヌルポインタとなる。連鎖について重要なことは、どの insn が(insn_list 式の一番目のオペランドとして)その中に現れるかということである。順序は重要ではない。

このリストは最初、フロー解析パスにより設定される。それまではヌルポインタになっている。フロー解析パスは、命令組合せで使用可能なデータ依存関係についてのリンクを追加するだけである。フロー解析パスは、insn 毎に、この insn で始めて使われる値をレジスタに格納する insn へのリンクを追加する。命令スケジューリングパスは、余分のリンクを追加して、あらゆる依存関係が表現されるようにする。リンクは、データ依存関係、逆依存関係、出力依存関係を表す。リンクのマシンモードがこの三つの型を区別する。逆依存関係のモードは REG_DEP_ANTI であり、出力依存関係のモードは REG_DEP_OUTPUT であり、データ依存関係のモードは VOIDmode である。

insn の REG_NOTES フィールドは、LOG_LINKS と同様の一個の連鎖であるが、insn_list 式に加えて expr_list 式も含んでいる。色々な種類のレジスタノートがあり、それらはマシンモードにより区別され、あるレジスタノート中では、実際に enum reg_note であると理解される。このノートの第一オペランド op は、ノートの種類によって意味の異なるデータである。

マクロ REG_NOTE_KIND (x) は、レジスタノートの種類を返す。これと対をなすマクロ PUT_REG_NOTE_KIND(x, newkind) は、x のレジスタノートのタイプを newkind に設定する。

レジスタノートには三つのクラスがある。何か insn への入力に関するもの、何か insn の出力に関するもの、それに、二つの insn の間のリンケージを作るものである。また、LOG_LINKS でしか使われない値が一セットある。

以下のレジスタノートは、insn への入力についての注釈である。

REG_DEAD

op の中の値がこの insn で死ぬ。つまり、この insn の直後でこの値を書き換えても、プログラムの以後の動作には影響を与えない。
これは、必ずしも、レジスタ op がこの insn 以後意味のある値を持たないということを意味しない。この insn の出力にもなることがあるからである。しかし、その場合、REG_DEAD ノートは冗長であり、普通は再ロードパス迄は存在しない。だが、このことを前提としているコードはない。 

REG_INC

レジスタ op は、この insn 内に埋め込まれた副作用によりインクリメント(あるいは、デクリメント。このレベルでは違いはない) される。すなわち、これは post_inc 式、または pre_inc式、post_dec 式、pre_dec 式に現れる。 

REG_NONNEG

この insn に到達したとき、レジスタ op は非負の値を持つことが知られている。これを使って、例えば m68k の dbra のような、デクリメントして 0 でない間は分岐する(decrement and branch until zero) 命令がマッチすることが可能になる。
REG_NONNEG ノートが insn に付加されるのは、マシン記述に decrement_and_branch_until_zero というパターンがある場合のみである。 

REG_NO_CONFLICT

この insn は、たとえ衝突を引き起こすように見えても、op とこの insn により設定されるアイテムとの間の衝突を引き起こさない。言い換えると、そうなっていないと代入先レジスタと op が同じレジスタに割り当てられる場合でも、この insn はその割当を妨げない。

このノートがある insn は、通常、あるブロックの一部である。このブロックは複数ワードの疑似レジスタを指定する一個の clobber insn で始まり、それぞれが一ワードの値を設定し、REG_NO_CONFLICT が付随している insn のグループが一つ、最後に、計算される式を与えるREG_EQUAL ノートをつけて、出力をそれ自身にコピーする insn が来る。このブロックは、先頭と末尾の insn について、それぞれ REG_LIBCALL ノートと REG_RETVAL ノートで包み込まれている。 

REG_LABEL

この insn は op、code_label を使うが、jump_insn ではない。このノートにより、op が実際に使われることをジャンプ最適化に対して知らせる。
以下のノートは、insn の出力の属性を記述する。

REG_EQUIV

REG_EQUAL

このノートは、一個のレジスタだけを設定する insn についてのみ有効であり、そのレジスタが実行時には op に等しいことを示す。これが等しくなる範囲は、二つのノートのタイプで異なる。この insn が明示的にそのレジスタにコピーする値は op とは違って見えるかもしれないが、実行時には等しくなる。一個の set の出力が strict_low_part 式なら、このノートは subreg 式の SUBREG_REG に含まれているレジスタを参照している。

REG_EQUIV の場合は、レジスタは関数全体を通して op に等価であり、全て op で正当に置き換えることができる。(ここで「正当に」はプログラムのデータ流を指す。単純な置き換えは幾つかの insn を不正にする。) 例えば、ある定数が、他の値が決して代入されることのない、あるレジスタにロードされるとき、この種類のノートが使われる。

ある仮引数が関数の入り口点で疑似レジスタにコピーされるとき、この種類のノートが仮引数が渡されたスタックスロットに等価なレジスタを記録する。この場合、レジスタは他の insn により設定されることもあるが、その関数内でそのレジスタをスタックスロットに置き換えることはなお有効である。

REG_EQUIV は、仮引数を格納可能なスタックスロットがある場合、ある関数の入り口でレジスタ仮引数を疑似レジスタにコピーする命令で使われる。他の insn がその疑似レジスタを設定する可能性もあるが、コンパイラにとっては、関数全体で疑似レジスタをそのスタックスロットに置き換えるのは正当である。ただし、コンパイラは、そのスタックスロットが、最初のコピー命令での同じように置き換えを行なうことで適切に初期化されていることを保証されている場合である。これは、呼び出し規約でレジスタ仮引数についてスタックスペースを割り当てるようになっている機種で使われる。Stack Arguments の REG_PARM_STACK_SPACE を参照のこと。

REG_EQUAL の場合は、この insn により設定されるレジスタは、この insn の最後では実行時に op に等価になるが、関数内の他の場所では必ずしも等価ではない。この場合、op は算術式であることが多い。例えば、ライブラリ呼び出しのような insn 列が、ある算術演算を実行するのに使われるとき、この種類のノートが最終的な値を生成したりコピーする insn に付随する。

これらの二つのノートは、コンパイラのパス群により異なる方法で使われる。REG_EQUAL は、レジスタ割当に先立つパス(例えば、共通部分式削除とループ最適化)により使われ、その値をどう考えれば良いかをそのパスに知らせる。REG_EQUIV ノートは、レジスタ割当により使われ、利用可能なレジスタが足りなければ、レジスタの代わりに使われる代入式(定数か、スタック上の仮引数の位置を表す mem 式) が利用可能であることを示す。

仮引数のスタックのホームとそのライフタイムを通じてメモリ位置に等かな疑似レジスタを除いて、全ての等価なものは、付随する REG_EQUAL ノートにより最初に示される。ここで、仮引数のスタックホームは、REG_EQUIV ノートにより指示され、最適化の最初の方のパスでは役に立たない。また、メモリ位置に等価な疑似レジスタは、コンパイルの後の段階になるまで検出されない。op が定数であり、その insn がその代入先レジスタの組を一つしか表現しないのであれば、レジスタ割当の初期の段階で、REG_EQUAL ノートは REG_EQUIV ノートに変えられる。

こうして、レジスタ割当より前のコンパイラのパスでは、REG_EQUAL ノートだけを検査する必要があり、レジスタ割当の後のパスではREG_EQUIV ノートだけを検査すれば良い。 

REG_UNUSED

この insn により設定されるレジスタ op は、次の insn では使われない。REG_DEAD ノートとの違いは、REG_DEAD の方は、入力中の値が後で使われることがないことを示す点にある。この二つのノートは独立であり、同じレジスタに対して両方とも存在してもかまわない。 

REG_WAS_0

この insn の一個の出力は、この insn の前にゼロを含んでいた。op が、ゼロに設定した insn である。このノートが存在し、かつ op が削除されていたり、note に変換されたりしていなければ、このノートを信頼することができる。このノートが存在しない場合は、何も意味しない。
以下のノートは、insn 間のリンケージを記述する。これらは、対で現れる。一個の insn には、ノートの対があり、それらは二番目の insn を指す。二番目の insn には、最初のinsn を指す逆のノートがある。

REG_RETVAL

この insn は、複数の insn から成る列(例えば、ライブラリ呼び出し)の値をコピーする。op は、列の先頭の insn である(ライブラリ呼び出しの場合は、ライブラリ呼び出しの引数を設定するように生成された先頭の insn である)。
ループ最適化はこのノートを使って、コードの移動の目的のために、このような列を一個の演算として取り扱う。また、フロー解析ではこのノートを使って、このような列で結果が死んでいるものを削除する。

通常、REG_EQUAL ノートもこの insn に付属し、この列により計算される式を提供する。

これらのノートは再ロード後に削除される。もはや不正確だったり役に立たなかったりするからである。 

REG_LIBCALL

これは、REG_RETVAL の逆である。これは複数 insn の列の先頭の insn に置かれ、最後の insn を指す。
これらのノートは再ロード後に削除される。もはや不正確だったり役に立たなかったりするからである。 

REG_CC_SETTER

REG_CC_USER

cc0 を使う機種では、cc0 を設定したり使ったりするinsn はお互いに近くにある。だが、遅延分岐スロットを埋める処理が行なわれると、もはや近くにあるとは言えなくなる可能性がある。その場合、REG_CC_USER ノートが、cc0 を設定する insn に置かれて、cc0 を使う insn を指し、REG_CC_SETTER ノートがcc0 を使う insn に置かれて、cc0 を設定する insn を指すようになる。

以下の値は、LOG_LINKS フィールドでのみ使われ、各リンクが表現する依存関係の型を指し示す。データ依存関係(書き込み後の読み込み依存関係, read after write dependence) を指し示すリンクはどのコードも使わず、単にモードが VOIDmode であり、何の説明文もなく出力される。

REG_DEP_ANTI

これは逆依存関係(WAR、読み込み後の書き込み依存) を示す。 

REG_DEP_OUTPUT

これは出力依存関係(WAW、書き込み後の書き込み依存)を示す。
これらのノートは gcov によるプロファイルデータから収集した情報を記述する。insn の REG_NOTES フィールドに expr_list として格納される。

REG_EXEC_COUNT

プロファイルデータに基づく、基本ブロックの実行回数を示す。このノートは、基本ブロックの先頭の insn に付加される。 

REG_BR_PROB

プロファイルデータに基づく、ある分岐 insn の、分岐が行なわれた回数と行なわれなかった回数の比を示す。0 と REG_BR_PROB_BASE の間の値として格納される。値が大きくなると、分岐が成立する確率がより高くなることを示す。 

REG_BR_PRED

このノートは、遅延分岐スケジューリングが起きた後のジャンプ insn に現れる。これらは、ジャンプの方向と可能性を示す。フォーマットは、ATTR_FLAG_* 値のビットマスクである。 

REG_FRAME_RELATED_EXPR

これは、RTX_FRAME_RELATED_P insn で使われる。この insn では、付属した式が、実際の insn パターンの代わりに使われる。これは、パターンが複雑か間違っている場合に行われる。
便宜上、insn_list や expr_list 中のマシンモードは、デバッグダンプでは、これらのシンボリックコードで出力される。

式コード insn_list と expr_list の唯一の相違点は、insn_list の先頭のオペランドは insn であると仮定され、デバッグダンプ中では insn の一意的な ID として出力されること、expr_list の先頭のオペランドは式として通常の方法で出力される点にある。

##関数呼び出し insn の RTL 表現
サブルーチンを呼び出す insn は、RTL 式コードが call_insn になる。サブルーチン呼び出し insn は特別な規則に従う必要があり、本体部分で特別な RTL 式コード call を使わなければならない。

call 式は、以下のようにオペランドを二つ取る。

(call (mem:fm addr) nbytes)
ここで、nbytes は、サブルーチンに渡される引数データのバイト数を表すオペランドである。fm はマシンモードであり、addr はサブルーチンのアドレスを表す。fm は、マシン記述の FUNCTION_MODE マクロの定義と同じでなければならない。

値を返さないサブルーチンについては、上に示した call 式そのものがinsn の全体になる。ただし、use 式か clobber 式をその他に含んでいる必要がある。

戻り値があり、そのモードが BLKmode でないサブルーチンについては、戻り値はハードレジスタに置かれる。このレジスタの番号が r なら、call insn の本体は以下のようになる。

(set (reg:m r)
     (call (mem:fm addr) nbytes))

この RTL 式は、この insn で、適切なレジスタに有効な値が置かれることを(最適化パスに対して)はっきりさせる。

サブルーチンが BLKmode の値を返すなら、その値を格納すべき位置のアドレスをサブルーチンに渡すという処理が行なわれる。このため、call insn 自身はどんな値も返さないので、値を返さない呼び出しと同じ形式の RTL になる。

マシンによっては、call 命令自身が幾つかのレジスタを、例えば戻り先アドレスを保持するために、破壊する。そういうマシンでの call_insn insn の本体は、call 式と clobber 式の両方を持つ、一個の parallel とすべきである。この clobber 式は、どのレジスタが破壊されるかを示す。同様に、call 命令が、スタックポインタ以外に、RTL で明示的に指定されていないレジスタを必要とするときは、use 副式がそのレジスタについて言及すべきである。

呼び出される関数は、コンフィギュレーションマクロ CALL_USED_REGISTERS (see Register Basics)に列挙されている全てのレジスタを修正し、const 関数とライブラリ呼びだしを例外として、全メモリを修正すると仮定される。

単に use 式を含む insn は、どのレジスタが関数への入力を保持しているかを示す call_insn の直前に位置する。同様に、CALL_USED_REGISTERS で指定されている以外のレジスタが呼び出された関数により上書きされるなら、単独の clobber を含む insn は、それがどのレジスタかを示すために、その呼び出しの直後に置かれる。

###構造の共有の前提
GNU CC は、ある種類の RTL 式は一意的であることを仮定している。すなわち、同じ値を表す二つの異なるオブジェクトは存在しないと仮定しているのである。一方、それとは逆の、ある種類の RTL 式オブジェクトは、それを含む構造の中では 2 回以上現れることはないという仮定をしている場合もある。

これらの仮定は一個の関数に関するものである。グローバル変数や外部関数を記述する RTL オブジェクト、それに小さな整数定数のような2,3の基本的なオブジェクトを除いて、二つの関数に共通の RTL オブジェクトは存在しない。

* 各疑似レジスタは、それを表現する reg オブジェクトは一個しか持たず、そのため、マシンモードも一個しかない。
* 記号名ラベルはどれも、それを参照する symbol_ref オブジェクトは一個しかない。
* 値が 0、1、-1 の const_int 式はそれぞれ一個だけである。それ以外の幾つかの整数値も一意的に格納される。
* pc 式は一個しかない。
* cc0 式は一個しかない。
* それぞれの浮動小数点モードで、値 0 の const_double 式はそれぞれ一個しかない。値が 1 と 2 についても同様である。
* label_ref や scratch は、RTL 構造体の中で二箇所以上は現れない。言い換えると、関数の中の全 insn をツリーウォークしたときに、label_ref や scratch が見つかるたびに、すでに見た他の全てとは違ったものであると仮定しても良い。
* 各静的変数やスタックスロットについては、普通はただ一個の mem オブジェクトが作られる。このため、これらのオブジェクトはそれが現れる全ての場所で共用されることが多い。しかし、これらの変数に対して、等価であるが別の独立したオブジェクトが作られることがたまにある。
* 一個の asm 文に複数の出力オペランドがあると、出力オペランド毎に別々の asm_operands 式が作られる。しかし、これらの式は全て、入力オペランドの列を含むベクトルを共有する。この共有は後で、二つの asm_operands 式が同じ文に由来するものかどうかを調べるのに使われる。このため、全ての最適化で、ベクトルを全部コピーした場合には注意深く共有を維持しなくてはならない。
* 上で説明したものを除いて、RTL 構造体に RTL オブジェクトが二箇所以上に現れることはない。コンパイラのパスの多くが、このことに依存しており、他の insn に不要な副作用を与えることなく RTL オブジェクトを直接修正可能であるということを仮定している。
* 最初の RTL 生成の間は、共有される構造体が自由に導入される。ある関数についての 全 RTL 生成が完了した後で、全ての共有される構造体が emit-rtl.c の unshare_all_rtl 関数によりコピーされる。その後で上記のルールが成り立つことが保証される。
* 組合せパスの間、ある insn 中の共有構造体が一時的に存在できる。しかし、共有構造体は、組合せパスがその insn についての処理を終了する前に、コピーされる。これは copy_rtx_if_shared を呼び出すことにより行なわれる。この関数は unshare_all_rtl のサブルーチンである。

##RTL の読み込み

ファイルから RTL オブジェクトを読み込むには、read_rtx 関数を使う。引数は、標準入力ストリーム一つであり、一個の RTL オブジェクトを返す。

ファイルから RTL を読む処理は非常に遅い。現時点ではこれは問題ではない。RTL の読み込みは、コンパイラを構築するときにのみ行われるからである。

RTL をテキストとしてファイルにセーブして、GNU CC の言語フロントエンドとその他の部分とのインターフェースとして使おうと考える人が良くいるが、これは実現不可能である。

GNU CC は、RTL を内部表現として使うようにしか設計されていない。ある与えられたプログラムに対する正しい RTL は、特定のターゲットマシンに著しく依存する。しかも、RTL は、そのプログラムについての情報を全部は含んでいないのである。

GNU CC と新しい言語フロントエンドのインターフェースを取る正しい方法は、「tree」データ構造を使う事である。このデータ構造について書いたマニュアルはないが、tree.h と tree.def で説明されている。

#機械記述
マシン記述は二つの部分からなる。機械命令のパターンを記述するファイル(.md ファイル) と C のマクロ定義を記述するヘッダファイルである。

あるターゲットマシン向けの .md ファイルは、そのマシンがサポートしている各機械命令(あるいは、少なくとも、GCC が知っていたほうが良い機械命令) のパターンを記述する。このファイルにはコメントを書くことができる。コメントはセミコロンから始まり行末までとなる。ただし、セミコロンが引用符つき文字列中にある場合を除く。

C のヘッダファイルについては、次章を見ていただきたい。

* Patterns: 命令パターンの書き方
* Example: define_insn の例
* RTL Template: RTL テンプレート
* Output Template: アセンブラコードの出力方法を指定する出力テンプレート
* Output Statement: アセンブラコードの出力を行なう C のコード
* Constraints: オペランド制約
* Standard Names: コード生成で使われるパターン名
* Pattern Ordering: パターンの順序が意味を持つ時
* Dependent Patterns: 一つのパターンが別のパターンを必要とするとき
* Jump Patterns: ジャンプ命令のパターンに関する特別な注意
* Insn Canonicalizations: 命令の正規化
* Peephole Definitions: 機種固有のピープホール最適化の定義方法
* Expander Definitions: 標準の演算向けの各種 RTL  insn 列の生成
* Insn Splitting: 複数命令への分割
* Insn Attributes: 生成された insn の属性値を指定する

##命令パターンの全て

各命令パターンには、後で埋められる部分を持つ不完全な RTL 式と、各部分がどのように埋められるかを限定するオペランド制約、それに、出力パターンまたはアセンブラ出力を生成する C コードが含まれており、全て define_insn 式中に記述される。

define_insn は一つの RTL 式で、四つか五つのオペランドを持つ。それぞれのオペランドは以下の通りである。

1

名前。無くても良い。名前があると、その命令パターンが、GCC の RTL生成パスにおいてある決まった仕事を成しうるということを意味する。RTL生成パスは一定のパターン名を知っていて、マシン記述に定義されている名前であれば、その名前の命令パターンを使おうとする。

名前を書くべき位置に空文字列を書くと名前がないということになる。名無しの命令パターンは RTL コードの生成に使われることはありえない。しかし、名無しの命令パターンを使うと、様々なより単純な insn を後で結合させることが出来る。

つまり、RTL生成時に知られていない、あるいは使われもしない名前は何の効果ももたらさない。名無しと全く同じである。

2

RTL テンプレート (see RTL Template) は、不完全な RTL 式を要素とするベクトルであり、命令がどのように見えるかを示す。不完全というのは、その命令のオペランドの代理である、match_operand や match_operator、match_dup 等の式を含むからである。

RTL テンプレート・ベクトルに要素が一つしかなければ、その要素は命令パターンのテンプレートである。ベクトルに要素が複数あれば、その命令パターンは列挙された要素を含む parallel 式である。

3

条件。これは文字列であり、insn 本体がパターンにマッチするかどうかを最終的に決定するための条件を C 言語の式で表したものである。

名前を持つパターンについては、条件は(もしあれば)、マッチする insn 中のデータには依存せず、ターゲット機種の型のフラグにのみ依存する。GCC は、初期化時にこの条件を調べて、どういう名前の命令が一回毎の実行時に利用できるのかを厳密に調べる必要がある。

名無しのパターンについては、条件は個々の insn とのマッチングを行なう時と、insn が、そのパターンの評価テンプレートにマッチした後にのみ適用される。insn のオペランドは、ベクトル operands に入っている。

4

出力テンプレート。 マッチした insn をどのようにアセンブラコードとして出力するかを指示する文字列である。文字列中の % は、オペランドの値をどこに代入するかを指示する。See Output Template.

単なる置き換えでは充分でないときは、C コードの断片を指定して、計算を行なったうえで出力させることも出来る。See Output Statement.

5

このパターンにマッチする insn の属性値を含むベクトル。省略可能である。 See Insn Attributes.

##define_insn の例

以下は、命令パターンの実例である。68000/68020 向けである。

```
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
  "*
{ if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return \"tstl %0\";
  return \"cmpl #0,%0\"; }")
```

これは、汎用レジスタの値に基づいて条件コードをセットする命令である。条件の指定がないので、RTL 記述が指定された形を持つ任意の命令が、このパターンに従って扱われる。tstsi という名前は、"test a SImode value"(SImode の値をテストする)という意味で、RTL 生成パスに対して、SImode の値をテストする必要があるときは、それを行う命令はこのパターンを使って構成せよということを指示する。

出力制御文字列は、C コードの断片であり、どの出力テンプレートを返すかを、オペランドの種類とコードを生成しようとしている CPU の特定の型に基づいて選択する。

"rm" は、オペランド制約(constraint)である。この意味は以下で説明する。

##RTL テンプレート

RTL テンプレートを使い、どの insn が特定のパターンにマッチするのか、および、そのオペランドの見つけ方を定義する。名前付きパターンの場合は、RTL テンプレートは、指定されたオペランドからどのように insn を構築するかについても指示する。

構築するということには、指定されたオペランドをテンプレートのコピーに代入することも含まれる。照合することには、一致しようとしている insn のオペランドの役割を果たす値を決定することも含まれる。どちらの動作も、照合とオペランドの代入を指示する特別な式の型により制御される。

(match_operand:m n predicate constraint)

この式は、insn の n 番目のオペランドのプレースホルダーである。insn の構築時に、n番目のオペランドがここに挿入される。insn の照合時には、insn のこの位置に現れるものは何であれ、n 番目のオペランドとして扱われる。ただし、その場合 predicate を満たしている必要があり、さもなければこの命令パターンは全くマッチしない。

オペランド番号は、各命令パターンにおいて 0 から始まる数字にならなければならない。各オペランド番号について、パターンにはmatch_operand 式が一個だけ存在し得る。普通は、オペランドは match_operand 式群に現れた順に番号が付く。define_expand の場合には、match_dup 式でのみ使用されるオペランド番号はどれも、他のどのオペランド番号よりも大きな値になる。

predicate は、ある C の関数名を表す文字列でり、その関数は二つの引数、すなわち一個の式と一個のマシンモードを受け付ける。照合が行なわれる間に、式として仮想的なオペランド、モード引数として m を使ってその関数が呼び出される。(m が指定されない場合は、VOIDmode が使われ、predicate は任意のモードを受け付けることになる。) この関数が 0 を返した場合は、この命令パターンの照合に失敗することになる。predicate は空の文字列であっても良い。その場合、オペランドについては何のテストも行なわれず、この位置に現れるものは何でも有効になる。

ほとんどの場合、predicate は m 以外のモードを受け付けない。ただし、いつでも受け付けないわけではない。例えば、述語(predicate) address_operand は、m を、そのアドレスが有効なメモリ参照のモードとして使う。多くの述語は、それらのモードが VOIDmode であっても const_int ノードを受け付ける。

constraint は再ロードとある値に最適なレジスタクラスの選択を制御する。これについては後で説明する (see Constraints)。

制約と述語の違いが良く判らないという人が多い。述語は、ある与えられた insn がパターンにマッチするかどうかを判断する手助けをする。一方、制約は、この判断には関与しない。代わりに、insn がパターンにマッチした場合の色々な判断を制御するのである。

CISC では、最も良く出てくる述語は、"general_operand" である。これは、仮想オペランドが、定数であるのか、レジスタなのか、メモリ参照なのかを調べ、それがモード m で有効なのものかどうかを確かめる。

レジスタでなければならないオペランドの場合は、述語としては"register_operand" を使うべきである。再ロード過程で"general_operand" を使っても、任意の非レジスタオペランドをレジスタにコピーするという処理を行うので大丈夫だが、そうすると GCC に余計な仕事をさせることになるし、ループからの不変オペランド(例えば定数)の除去や最適なレジスタ割り付けの妨げにもなる。RISC の場合には、述語としては、制約が許す範囲のオブジェクトのみを受け付けるようにするのが一般には最も効率が良い。

定数であるはずのオペランドの場合には、述語として "immediate_operand" を使うか、命令パターンの付加条件が定数を要求するようにするか、あるいは両方を行うようにする必要がある。制約を使えば同じことが出来るだろうと考えてはいけない。制約の方が定数のみを許すようになっていても、述語がそれ以外のものを許しているなら、実際にそのケースが発生したときにGCC は落ちてしまうのである。 

(match_scratch:m n constraint)

この式もオペランド番号 n のプレースホルダであり、オペランドはscratch 式か reg 式でなければならないことを指定する。

パターン照合の際には、これは、以下の式と等価である。

(match_operand:m n "scratch_operand" pred)

しかし、RTL 生成フェーズでは、これは (scratch:m) という式を生成する。

parallel の中の最後の幾つかの式が clobber 式であり、その clobber 式のオペランドがハードレジスタか match_scratch なら、結合器(combiner) は必要なときにそういうオペランドを追加したり、削除したりすることができる。 

(match_dup n)

この式もオペランド番号 n のプレースホルダーである。オペランドが insn の二箇所以上に現れる必要があるときに使われる。

構築の際には、match_dup はちょうど match_operand と同様に動作する。オペランドは、構築されつつある insn に代入される。しかし、マッチングでは、match_dup の動作は異なる。オペランド番号 n は認識テンプレートに先に現れる match_operand により既に決まっており、見た目が同一の式にしかマッチしないということを想定している。 

(match_operator:m n predicate [operands...])

このパターンは、可変な RTL 式コードの一種のプレースホルダーである。

insn 構築の際には、ある RTL 式を表す。この RTL 式の式コードは、オペランド n から取られ、オペランドはパターンの operands から構築される。

式と照合する際は、関数 predicate がその式についてゼロでない値を返し、かつ パターンの operands がその式のオペランドにマッチしたときに、その式にマッチする。

関数 commutative_operator が以下のように定義されているとする。演算子が RTL の交換可能な算術演算子の一つで、モードが mode である任意の式にマッチするように定義されている。

```
int
commutative_operator (x, mode)
     rtx x;
     enum machine_mode mode;
{
  enum rtx_code code = GET_CODE (x);
  if (GET_MODE (x) != mode)
    return 0;
  return (GET_RTX_CLASS (code) == 'c'
          || code == EQ || code == NE);
}
```

そうすると、以下のパターンは、二つの一般オペランドに適用される交換可能な演算子を含む任意の RTL 式にマッチする。

```
(match_operator:SI 3 "commutative_operator"
  [(match_operand:SI 1 "general_operand" "g")
   (match_operand:SI 2 "general_operand" "g")])
```

ここでベクトル [operands...] は、二つのパターンを含んでいる。なぜなら、マッチすべき式は全て二つのオペランドを含んでいるからである。

このパターンがマッチしたとき、交換可能な演算子の二つのオペランドは、この insn のオペランド 1 とオペランド 2 として記録される。(これは、二つの match_operand により行なわれる。) この insn のオペランド 3 は、交換可能な式全体である。

match_operator のマシンモード m は、match_operand のものと同様に振る舞う。述語関数の二番目の引数として渡され、その関数だけが、マッチすべき式がそのモードを「持っているか」どうかを決定する責任がある。

insn を構築する際には、生成関数の第三引数が、作成されるべき式の演算(すなわち式コード)を指定する。この引数は一個の RTL 式であるべきで、その式コードが、生成関数の引数 1 と 2 をオペランドとする新しい式にコピーされる。引数 3 のサブ式は使われない。式コードだけが問題になる。

match_operator が、insn と照合されるパターンで使われているとき、その match_operator のオペランド番号が、その insn の実際のオペランド番号よりも大きいのが通常は最善である。これによりレジスタ割当が改良される。レジスタ割当では、insn のオペランド 1 と 2 を見て、レジスタの結び付けが可能かどうかを見るからである。

match_operator に制約を指定する方法はない。match_operator に対応する insn のオペランドはどんな制約も持つことはない。全体として再ロードされることがないからである。だが、その operands の一部が match_operand パターンにより照合が行なわれると、その一部はそれ自身の制約があって良い。 

(match_op_dup:m n[operands...])

match_dup に似ているが、オペランドではなく演算子に適用される。insn を構築するときは、オペランド番号 n がここに代入される。しかし、マッチングの際には match_op_dup の動作は異なる。オペランド番号 n は認識テンプレートに先に現れる match_operator により既に決まっており、見た目が同一の式にしかマッチしないということを想定している。 

(match_parallel n predicate [subpat...])

このパターンは、可変数要素の parallel 式一個からなる insn のプレースホルダーである。この式は、insn パターンの最上位レベルにのみ現れるべきである。

insn を構築する際には、オペランド番号 n がこの点で置き換えられる。insn との照合の際には、insn 本体が parallel 式であり、このparallel 式が、少なくとも match_parallel 中の subpat 式の insn ベクトルの要素数と同じ要素数を持つのであれば、各 subpat が parallel の対応する要素に一致し、かつ、関数 predicate が insn の本体である parallel に対してゼロでない値を返すなら、一致が起きる。match_parallel に列挙されたもの以外の parallel の要素を確認するのは述語の役割である。

match_parallel の代表的な使い方は、ロードマルチプル式とストアマルチプル式にマッチさせることである。例えば、

```
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
```

この例は、a29k.md から取ったものである。関数 load_multiple_operations は、a29k.c で定義されており、parallel 中の後続の要素が、このパターンの中のset と同じであるかどうかを検査している。その要素が、後続のレジスタとメモリ位置を参照している場合を除く。

このパターンにマッチする insn は以下のような形式である。

```
(parallel
 [(set (reg:SI 20) (mem:SI (reg:SI 100)))
  (use (reg:SI 179))
  (clobber (reg:SI 179))
  (set (reg:SI 21)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 4))))
  (set (reg:SI 22)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 8))))])
```

(match_par_dup n [subpat...])

match_op_dup と同様だが、match_operator ではなくmatch_parallel 用である。 

(match_insn predicate)

完全な insn にマッチする。他の match_* 認識器とは異なり、match_insn はオペランド番号を取らない。

match_insn のマシンモード m は、match_operand と同様の働きをする。述語関数の第二引数として渡され、マッチした式のモードがそのモードになっているかどうかを決定する責任はその関数にだけある。 

(match_insn2 n predicate)

完全な insn にマッチする。

match_insn2 のマシンモード m は、match_operand と同様の働きをする。述語関数の第二引数として渡され、マッチした式のモードがそのモードになっているかどうかを決定する責任はその関数にだけある。 

(address (match_operand:m n "address_operand" ""))

この複雑な式は、「ロードアドレス」命令中のオペランド番号 n のプレースホルダーである。このオペランドは普通はメモリ位置を指定するが、実際のオペランド値として使われるのはその位置のアドレスであり、その位置の内容ではない。

address 式は RTL コードには決して現れず、マシン記述でのみ使われる。そして、オペランド制約の機能を使わないマシン記述でしか使われることがない。オペランド制約が使われる場合は、制約の文字 p がこの目的を果たす。

m は、アドレスとなるメモリ位置のマシンモードであり、アドレス自身のマシンモードではない。このモードは、ある与えられたターゲットマシン上では常に同じなので(Pmode で、これは普通は SImode である)、それをわざわざ明記する意味はない。つまり、address 式にはマシンモードは書かないのである。いつの日か、異なる種類のオブジェクトのアドレスが異なって見えたり、(PDP-10 のように)使い方が異なっていたりするマシンがサポートされたら、異なる形式はおそらく異なるマシンモードを必要とし、そのモードをaddress 式に書くことになるだろう。

##出力テンプレートとオペランド置換

出力テンプレートは文字列であり、ある命令パターンに対するアセンブラコードをどのように出力するかを指定する。テンプレートのほとんどの部分は、固定文字列であり、そのまま出力される。文字 % を使って、オペランドが代入される位置を指定する。また、アセンブラに変種があるために異なる構文を必要とする場所を特定するのにも使われる。

一番単純な場合では、% の数字 n が続いた場合は、文字列のその部分にオペランド n を出力することを示す。

% の直後に英字1文字と数字1文字が続くと、オペランドの出力形式を別のものに変えることを意味する。英字としては四つの文字が標準で組み込み済の意味を持っており、以下で解説する。マシン記述マクロ PRINT_OPERAND を使って、標準ではない意味を持つ文字を追加定義することができる。

%cdigit を使うと、通常は即値オペランドである事を示す構文を使わなくても、定数値であるオペランドを置き換えることができる。

%ndigit は、表示前に定数値が否定を取られることを除けば %cdigit に同じである。

%adigit を使ってそれがあたかもメモリ参照であるかのように、あるオペランドをアドレスとして扱われる実際のオペランドと置き換えることができる。これは、「ロードアドレス」命令を出力する際に役に立つ。そういう命令のアセンブラ構文では、オペランドをあたかもメモリ参照であるかのように書くことを要求することが多いからである。

%ldigit は、ジャンプ命令に label_ref を代入するのに使われる。

%= は、各命令に対し、コンパイルの全過程で一意的な番号を出力する。これは、複数のアセンブラ命令を生成する一個のテンプレート中で二回以上参照されるローカルラベルを作るときに便利である。

% の後ろに区切り文字が続くと、オペランドを使わない置き換えであることを指定する。標準的な使い方は一個だけである。%% とするとアセンブラコードに % を出力する。その他の非標準的な場合は、マクロ PRINT_OPERAND で定義することができる。また、どの区切り文字が有効かをマクロ PRINT_OPERAND_PUNCT_VALID_P で定義しなければならない。

テンプレートは複数のアセンブラ命令を生成して良い。その場合には、各命令を \; で区切って書く。

RTL にオペランドが二つあり、制約によりその二つが互いに一致することが要求されている場合には、出力テンプレートでは、数字の小さい方のオペランドしか参照してはならない。一致したオペランドはいつも同じではなく、コンパイラの残りの部分で、数字の小さい方のオペランドに出力する適切な RTL 式を置くように調整する。

% の後ろに標準でない英文字や区切り文字を置く使い方の一つに、同一のマシンに対する異なるアセンブラ言語を区別することがある。例えば、68000 には Motorola 形式と MIT 形式がある。Motorola 形式では、ほとんどのオペコード名にピリオドを使うのに対し、MIT 形式では使わない。例えば、MIT 形式で movel と書くオペコードは、Motorola 形式では move.l となる。両方の出力形式に対して同じパターンファイルを使用するが、Motorola 形式でピリオドが必要な場所には文字シーケンス %. を使うようにする。マクロ PRINT_OPERAND は、Motorola 形式では、ピリオドを出力するシーケンスを定義し、MIT 形式向けには何もしないマクロとして定義する。

特別な場合として、テンプレートが一個の文字 # から成っているとコンパイラに対し、最初に insn を分割し、次にその結果の命令を別々に出力することを指示する。これは、出力テンプレートの冗長性を消去するのに役立つ。複数のアセンブラ命令を出力する必要がある define_insn があり、マッチする define_split が既に定義されているなら、出力テンプレートとして単に # を使うことができ、複数のアセンブラ命令を出力する出力テンプレートを書く必要はない。

マクロ ASSEMBLER_DIALECT が定義されていれば、テンプレートで {option0|option1|option2}という形式の構文を使うことができる。アセンブラ言語の文法の複数の方言を記述する。See Instruction Output.

##アセンブラ出力用の C 言語の文

一個の固定テンプレート文字列だけでは、一つの命令パターンで認識される全てのケースに対して、正確で効率の良いアセンブラコードを生成するのが難しいということが良くある。例えば、オペコードはオペランドの種類に依存することがある。あるいは、オペランドの組合せが悪いと余分の機械命令が必要なこともある。

そういうときは、出力制御文字列を @ で開始すると、一行に一個ずつ置いたテンプレートの列とすることが出来る。(空行や行頭の空白、タブは無視される。) このテンプレート群は、命令パターン中の制約の選択肢に対応する(see Multi-Alternative)。例えば、ターゲットの機種が、アドレスを二つ取る加算命令として、レジスタに加算する命令 addr とレジスタの値をメモリ中に加算する命令addm の二つの命令を持っている場合、以下のようにパターンを書くことができる。

```
(define_insn "addsi3"
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (plus:SI (match_operand:SI 1 "general_operand" "0,0")
                 (match_operand:SI 2 "general_operand" "g,r")))]
  ""
  "@
   addr %2,%0
   addm %2,%0")
```

出力制御文字列が * で始まっている場合は、出力テンプレートそのものではなくて、テンプレートを生成する C のコード断片であることを示す。この C コード断片は、return 文を使って、テンプレート文字列を返す必要がある。このテンプレートは C の文字列リテラルを使う場合が多い。文字列リテラルの場合は区切り記号として二重引用符が必要である。テンプレート文字列に二重引用符を含めるには、\ でエスケープする必要がある。

オペランドは、operands という、rtx [] 型の配列に収められている。

即値オペランドが、ある一定の範囲内におさまるかどうかによって、異なるアセンブラコードの生成方法を選択するのは非常に良く行なわれる。しかし、その場合には注意が必要である。とうのは、INTVAL の結果はホストマシンでの整数になるからである。ホストマシンの int のビット数が、ターゲットマシンの定数で使われるモードのビット数より大きければ、INTVAL から得られるビットのいくつかは余計なものである。正しい結果を得るためには、この余分なビットによる値を注意深く取り除かなければならない。

サブルーチン output_asm_insn を使って、あるアセンブラ命令を出力し、その後出力を続けたり、さらに計算を行なうことが可能である。この関数は引数を二つ取る。テンプレート文字列とオペランドのベクトルである。ベクトルは operands であっても良いし、あるいは読者がローカルに宣言し、自分で初期化した、別の rtx の配列でも良い。

ある insn のパターンで、制約に複数の選択肢がある場合は、アセンブラコードの見かけはどの選択肢にマッチしたかでほとんど決まることが多い。その場合、C のコードでは、変数 which_alternative をテストすることができる。この変数は、実際に条件にあった選択肢の順番を表す数(先頭の選択肢は 0で、二番目は 1、等々)である。

例えば、ゼロを格納する命令には、二つのオペコードがあるとしよう。レジスタの場合にはclrreg、メモリ位置の場合は clrmem である。以下に、あるパターンでどのように which_alternative を使って、オペコードを選択するかを示す。

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  "*
  return (which_alternative == 0
          ? \"clrreg %0\" : \"clrmem %0\");
  ")
```

この例は、生成すべきアセンブラコードが選択肢だけで決まるなら、出力制御文字を @ で始めるようにすれば、以下のように指定することもできる。

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,m")
        (const_int 0))]
  ""
  "@
   clrreg %0
   clrmem %0")
```

##オペランド制約

ある命令パターンにおいて、match_operand のそれぞれに、許されるオペランドの型についての制約を指定することができる。制約により、次のような指定が可能である。あるオペランドがレジスタに置かれているかどうか、置かれているならどの種類のレジスタか。オペランドとしてメモリ参照が可能かどうか、可能ならどの種類のアドレスか。オペランドとして即値が可能かどうか、可能ならどういう値が可能か。制約は二つのオペランドが一致することを要求することもできる。

* Simple Constraints: 基本的な制約の使い方
* Multi-Alternative: insn に制約の形が二つある場合
* Class Preferences: レジスタクラスの選択
* Modifiers: 制約の修飾子
* Machine Constraints: 機種毎の制約
* No Constraints: 制約なしの機種

##単純制約

最も単純な種類の制約は全部が英文字からなる文字列である。その一つ一つの文字が、許されるオペランドの一つの種類を記述する。以下に許される英文字を示す。

m

メモリオペランドを指定する。その機種が一般にサポートしているアドレスならどれでも良い。
 
o

メモリオペランドを指定する。ただし、許されるアドレスは「オフセット指定可能な」アドレスだけである。つまり、そのアドレスに小さな整数(実際には、マシンモードにより決まる、バイト数で表したオペランドの幅に収まる数)を加算した結果もまた有効なメモリアドレスとなる。

例えば、アドレスが定数であれば、それはオフセット指定可能である。一個のレジスタと一個の定数(ちょっと大きめの定数もその機種でサポートされている範囲のアドレスのオフセットになっている限り) の和もオフセット指定可能である。しかし、自動インクリメント、自動デクリメントのアドレスはオフセット指定可能でない。もっと複雑な間接／インデックス修飾アドレスがオフセット指定可能かどうかは、その機種がサポートする他のアドレッシングモードに依存する。

別のオペランドにマッチ可能な出力オペランドにおいては、制約文字 oは、<(ターゲット機種に事前デクリメントアドレッシングがあれば)と>(ターゲット機種に事前インクリメントアドレッシングがあれば)の両方を伴う場合にのみ有効である。 

V

オフセット指定可能でないメモリオペランドを指定する。言い換えると、制約 m には収まるが、o には収まらないものは何でもここに入る。 

<

自動デクリメントのアドレスのメモリオペランドを指定する。プリデクリメントでもポストデクリメントのどちらでも良い。 

\>

自動インクリメントのアドレスのメモリオペランドを指定する。プリインクリメントでもポストインクリメントのどちらでも良い。 

r

レジスタオペランドが許される。ただし、レジスタは汎用レジスタである。 

d, a, f, ...

他の文字は、機種依存の方法で、特定のレジスタクラスを表すように定義することができる。68000/68020 では、d、a、f が定義されており、それぞれ、データレジスタ、アドレスレジスタ、浮動小数点レジスタを表す。 

i

整数の即値オペランド(定数値のもの)が許される。これには、値がアセンブル時にならないとわからないシンボリックな定数も含まれる。 

n

既知の数値を持つ整数即値のオペランドが許される。多くのシステムでは、語長よりも小さいオペランドにはアセンブル時の定数は使えない。そのようなオペランドの制約には i ではなく n を使うべきである。 

I, J, K, ... P

他の、I と P の間にある文字は、機種依存の方法で、指定された範囲の明示された整数値を持つ整数の即値オペランドを許すように定義することができる。例えば、68000 では、I は、1 ～ 8 の範囲の値を表すと定義されている。これは、シフト命令で許されているシフト幅の範囲である。 

E

浮動小数点の即値オペランド(式コードは const_double)が許される。ただし、ターゲットの浮動小数点形式がホストマシン(コンパイラが動作するマシン)のものと同じ場合に限られる。 

F

浮動小数点の即値オペランド(式コードは const_double)が許される。 

G, H

G と H は、機種依存の方法で、特定の範囲の値の浮動小数点即値オペランドを許すように定義することができる。 

s

値が明示的な整数ではない、整数即値オペランドが許される。

これは奇異に聞こえるかもしれない。もし、ある insn がコンパイル時には決まっていない値をもつ定数オペランドを許すなら、当然、どんな既知の値でも許さなければならないはずだ。どうして、i の代わりに s を使うのか? その方が、良いコードが生成されることがあるからなのだ。

例えば、68000 の全ワードの命令では即値オペランドを使うことができる。しかし、即値の範囲が -128 と 127 の間にあるなら、その値をレジスタにロードして、そのレジスタを使った方が良いコードになるのである。これは、レジスタへのロードが moveq 命令で行なえるからである。我々はこれが起きるように、文字 K が「-128 と 127 の範囲の外側の整数」という意味を持つように定義し、オペランドの制約にKs と指定している。 

g

任意のレジスタ、メモリ、整数の即値のオペランドが許される。ただし、汎用レジスタでないレジスタは除く。 

X

どんなオペランドでも、たとえ general_operand を満たさないものであっても許される。これは、通常、特定の選択肢が実際にはスクラッチレジスタを必要としないときに、match_scratch の制約で使われる。 

0, 1, 2, ... 9

指定したオペランド番号にマッチするオペランドが許される。数字を同じ選択肢の中で英文字と組み合わせて使うなら、数字は最後に書くこと。

これは、照合制約と呼ばれており、それが実際に意味することは、アセンブラには二つの役割を果たす一個のオペランドしかないということである。この二つの役割は RTL insn で別のものと考えられている。例えば、add insn は RTL には、二つの入力オペランドと一つのオペランドを持っているが、多くの CISC マシンでは、add 命令にはオペランドが二つしかなく、その一つは入力と出力兼用オペランドである。

addl #35,r12

照合制約は以下の状況で使われる。もっと正確に言えば、マッチする二つのオペランドのうち、一つは入力専用で、もう一つは出力専用でなければならない。さらに、数字は制約で使われているオペランド数より小さな数でなければならない。

ある特定の場合にマッチするオペランドは普通それらが見かけが同じであるRTL 式になっているということを意味する。しかし、2,3の特別な場合には特定の種類の違いは許される。例えば、入力オペランドとしての *x は出力オペランドとしての *x++ にマッチする。このような場合に正しい結果を得るには、出力テンプレートではオペランドを出力するさいに常に出力オペランドの番号を使う必要がある。 

p

有効なメモリアドレスであるオペランドが許される。これは、「ロード・アドレス」命令と「プッシュ・アドレス」命令向けである。

制約の中の p には、match_operand の述語のように、address_operand が付随しなければならない。この述語は、match_operand で指定されたモードを、アドレスが有効であるメモリ参照のモードとして解釈する。 

Q, R, S, ... U

Q から U の範囲の文字は、機種依存の形式で定義して、任意のオペランド型を表すのに使える。マシン記述マクロ EXTRA_CONSTRAINT には、一番目の引数としてそのオペランドが、二番目の引数として制約文字が渡される。

これの典型的な使い方は、他の insn のオペランドに影響するメモリ参照の一定の型を区別することである。

これらの制約文字は、レジスタ選択(reg)を受け付けるようには定義しないこと。再ロードパスが想定していないことであり、正しく扱えないだろう。

アセンブラコードを正しいものにするために、各オペランドはその制約を満たさなければならない。しかし、制約を満たさなくても、そのパターンがある insn に適用されるのを妨げるものではない。代わりに、コンパイラがコードを修正して、制約が満足されるようにする。通常これはオペランドをレジスタにコピーすることにより行なわれる。

このため、以下の二つの命令パターンを比べてみよう。

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "general_operand" "r")))]
  ""
  "...")
```

これにはオペランドが二つあり、そのうちの一つは二箇所に現れなければならない。そして、

```
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_operand:SI 1 "general_operand" "0")
                 (match_operand:SI 2 "general_operand" "r")))]
  ""
  "...")
```

こちらは、オペランドが三つあり、そのうちの二つは制約により等しいことが要求される。以下の形の insn を考えてみると、

```
(insn n prev next
  (set (reg:SI 3)
       (plus:SI (reg:SI 6) (reg:SI 109)))
  ...)
```

最初のパターンは全く適合しない。この insn には、正しい場所に二つの同じ部分式がないからである。最初のパターンは、「加算命令には見えないので、他のパターンを試してね。」と言うだろう。一方、二番目のパターンは、「うん、これは加算命令だ。だけどちょっと間違ってるな。」と言うだろう。コンパイラの再ロードパスに対して insn を追加で生成させ、制約が満たされるようにすることを指示する。その結果は以下のようになるだろう。

```
(insn n2 prev n
  (set (reg:SI 3) (reg:SI 6))
  ...)

(insn n n2 next
  (set (reg:SI 3)
       (plus:SI (reg:SI 3) (reg:SI 109)))
  ...)
```

各パターンの各オペランドが、それぞれのオペランド向けに存在しうる、どんな RTL 式も扱えるような制約を持つことを保証するのは読者の責任である。(複数の選択肢が使われている場合は、各パターンは、オペランド式の可能な組合せ毎に、その組合せを扱うことが出来る選択肢を少なくとも一つ持たなければならない。) その制約は可能なオペランドをなんでも許す必要はない。なんでも許すのであればそれは制約ではない。だが、その制約は少なくとも、それに適するような何らかの可能なオペランドを再ロードする方法を指し示す必要がある。

* もし制約が、述語が許すオペランドなら何でも受け付けるなら何の問題もない。このオペランドは再ロードを全く必要としない。

* 例えば、レジスタ以外のあらゆるものを許す制約を持つオペランドは、その述語がレジスタを拒絶するなら安全である。

* 定数値だけを受け付ける述語を持つオペランドは、その制約に文字 i が入っていれば安全である。任意の可能な定数値を受け付けたなら、i がするであろう以上のことはなにもしない。もし述語がもっと選択的なら、制約もまたもっと選択的にして良い。

* 任意のオペランド式は、レジスタにコピーすることにより再ロード可能である。そのため、オペランドの制約がどの種類かのレジスタを許していれば、間違いなく安全である。全てのクラスのレジスタを許す必要はない。コンパイラは、命令を正しいものにするために、あるレジスタを別の適切なクラスのレジスタにコピーする方法を知っている。

* オフセット可能でないメモリ参照は、そのアドレスをレジスタにコピーすることで再ロード可能である。そのため、制約が文字 o を使っていれば、全てのメモリ参照の面倒を見てくれる。

* 定数オペランドは、それを事前に初期化されたデータとして保持するために、メモリスペースを獲得することで、再ロード可能である。そうすると、定数の代わりにメモリ参照が使える。そのため、制約が文字 o や m を使っていれば、定数オペランドは問題ではない。

* 制約が一個の定数とある insn で使われている一個の疑似レジスタを許しているものとする。このとき、その疑似レジスタがハードレジスタに割り当てられておらず、定数に等価であるなら、そのレジスタは定数に置き換えられる。述語が一個の定数と何らかの理由により再認識される insn を認めていなければ、GNU CC が異常終了する。すなわち、述語は、制約により許されるオブジェクトはどんなものであれ常に認識しなければならない。

オペランドの述語はレジスタを認識できるが、制約の方はレジスタを許さない場合はコンパイラが落ちる可能性がある。このオペランドがレジスタになったとき、再ロードパスがうまくいかなくなる。レジスタを一時的にメモリにコピーする方法が分からないためである。

述語が単項演算子を受け付けるなら、制約はそのオペランドに適用される。例えば、ISA レベル 3 の MIPS プロセッサは、SImode の二つのレジスタを加算して、DImode の結果を生成する命令をサポートしているが、これはレジスタが正しく符号拡張される場合だけである。入力オペランドに対するこの述語は、ある SImode のレジスタのsign_extend を受け付ける。sign_extend のオペランドとして必要なレジスタのタイプを示すように制約を書くこと。
